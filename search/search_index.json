{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"jalali_pandas","text":"<p>Jalali (Persian/Shamsi) calendar support for pandas, with native types, indexes, offsets, and accessors.</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>JalaliTimestamp scalar with conversion to/from Gregorian</li> <li>JalaliDatetimeIndex and jalali_date_range for time series work</li> <li>Vectorized conversion utilities</li> <li>Jalali-aware frequency offsets (JME/JMS/JQE/JQS/JYE/JYS/JW)</li> <li>Series/DataFrame accessors under <code>.jalali</code></li> <li>Grouping and resampling helpers for Jalali boundaries</li> </ul>"},{"location":"#quick-example","title":"Quick example","text":"<pre><code>import pandas as pd\nimport jalali_pandas as jp\n\n# Convert Gregorian to Jalali\ns = pd.Series(pd.date_range(\"2023-03-21\", periods=3, freq=\"D\"))\nj = s.jalali.to_jalali()\n\n# Build a Jalali index\nidx = jp.jalali_date_range(\"1402-01-01\", periods=3, freq=\"D\")\n</code></pre>"},{"location":"#next-steps","title":"Next steps","text":"<ul> <li>Installation: Installation</li> <li>Quickstart: Quickstart</li> <li>User guide: Core types</li> <li>Examples: Examples overview</li> </ul>"},{"location":"en/benchmarks/","title":"Benchmarks","text":"<p>The repository no longer ships ASV benchmarks by default. If you want to track performance, you can reintroduce ASV in your fork:</p> <p>1) Add <code>asv</code> to optional dependencies in <code>pyproject.toml</code>. 2) Add an <code>asv.conf.json</code> config and a <code>benchmarks/</code> directory. 3) Run <code>uv run asv run --quick</code>.</p> <p>For ad-hoc performance checks, you can use:</p> <ul> <li><code>scripts/profile_conversion.py</code></li> </ul> <p>If benchmarks are reintroduced, document the workflow here.</p>"},{"location":"en/changelog/","title":"Changelog","text":"<p>See the full changelog in the repository:</p> <p>https://github.com/ghodsizadeh/jalali-pandas/blob/main/CHANGELOG.md</p>"},{"location":"en/contributing/","title":"Contributing","text":"<p>Thanks for contributing to jalali_pandas.</p>"},{"location":"en/contributing/#development-setup","title":"Development setup","text":"<pre><code>uv sync --extra dev\n</code></pre>"},{"location":"en/contributing/#tests","title":"Tests","text":"<pre><code>uv run pytest\nuv run pytest --cov=jalali_pandas --cov-report=xml\n</code></pre>"},{"location":"en/contributing/#linting-and-formatting","title":"Linting and formatting","text":"<pre><code>uv run ruff check jalali_pandas tests\nuv run ruff format --check jalali_pandas tests\n</code></pre>"},{"location":"en/contributing/#type-checking","title":"Type checking","text":"<pre><code>uv run mypy jalali_pandas\nuv run pyright jalali_pandas\n</code></pre>"},{"location":"en/contributing/#docs-build","title":"Docs build","text":"<pre><code>uv sync --extra docs\nuv run mkdocs build --strict\n</code></pre>"},{"location":"en/contributing/#notes","title":"Notes","text":"<ul> <li>Keep public APIs typed.</li> <li>Follow Ruff formatting rules (88 chars).</li> <li>Add tests for accessors/offsets and type behavior.</li> </ul>"},{"location":"en/deployment/","title":"Deployment","text":"<p>This project uses MkDocs + Material. A GitHub Actions workflow should:</p> <p>1) Install docs dependencies 2) Build with <code>mkdocs build --strict</code> 3) Publish the <code>site/</code> directory to GitHub Pages</p> <p>Example steps:</p> <pre><code>uv sync --extra docs\nuv run mkdocs build --strict\n</code></pre> <p>Make sure the workflow adds a <code>.nojekyll</code> file in the published output.</p>"},{"location":"en/installation/","title":"Installation","text":""},{"location":"en/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9+</li> <li>pandas &gt;= 2.0</li> <li>numpy &gt;= 1.23</li> <li>jdatetime &gt;= 4.0</li> </ul>"},{"location":"en/installation/#install-with-pip","title":"Install with pip","text":"<pre><code>pip install -U jalali-pandas\n</code></pre>"},{"location":"en/installation/#install-with-uv","title":"Install with uv","text":"<pre><code>uv pip install jalali-pandas\n</code></pre>"},{"location":"en/installation/#optional-extras-for-contributors","title":"Optional extras (for contributors)","text":"<pre><code>uv sync --extra dev\nuv sync --extra docs\n</code></pre> <p>These install developer tools and documentation tooling defined in <code>pyproject.toml</code>.</p>"},{"location":"en/installation/#verify-installation","title":"Verify installation","text":"<pre><code>import jalali_pandas as jp\nimport pandas as pd\n\nprint(f\"jalali-pandas version: {jp.__version__}\")\nts = jp.JalaliTimestamp(1402, 6, 15)\ngregorian = pd.Timestamp(\"2023-09-06\")\njalali = jp.JalaliTimestamp.from_gregorian(gregorian)\nprint(f\"Created timestamp: {ts}\")\nprint(f\"Converted: {gregorian} -&gt; {jalali}\")\n</code></pre> <p>Expected output:</p> <pre><code>jalali-pandas version: 1.0.0a1\nCreated timestamp: 1402-06-15 00:00:00\nConverted: 2023-09-06 00:00:00 -&gt; 1402-06-15 00:00:00\n</code></pre>"},{"location":"en/quickstart/","title":"Quickstart","text":"<p>This walkthrough introduces the core objects in a few minutes.</p>"},{"location":"en/quickstart/#1-import-and-register-accessors","title":"1) Import and register accessors","text":"<pre><code>import pandas as pd\nimport jalali_pandas as jp\n</code></pre>"},{"location":"en/quickstart/#2-create-a-jalalitimestamp","title":"2) Create a JalaliTimestamp","text":"<pre><code>from jalali_pandas import JalaliTimestamp\n\nts = JalaliTimestamp(1402, 6, 15)\n</code></pre>"},{"location":"en/quickstart/#3-convert-gregorian-jalali","title":"3) Convert Gregorian \u2192 Jalali","text":"<pre><code>gregorian = pd.Timestamp(\"2023-09-06\")\njalali = jp.to_jalali_datetime(gregorian)\n</code></pre>"},{"location":"en/quickstart/#4-build-a-jalali-date-range","title":"4) Build a Jalali date range","text":"<pre><code>idx = jp.jalali_date_range(\"1402-01-01\", periods=5, freq=\"D\")\n</code></pre>"},{"location":"en/quickstart/#5-use-accessors","title":"5) Use accessors","text":"<pre><code>s = pd.Series(pd.date_range(\"2023-03-21\", periods=3, freq=\"D\"))\njalali_series = s.jalali.to_jalali()\nmonths = jalali_series.jalali.month\n</code></pre>"},{"location":"en/quickstart/#6-group-by-jalali-year","title":"6) Group by Jalali year","text":"<pre><code>df = pd.DataFrame({\"date\": s, \"value\": [1, 2, 3]})\ndf[\"jdate\"] = df[\"date\"].jalali.to_jalali()\nresult = df.jalali.groupby(\"year\").sum(numeric_only=True)\n</code></pre> <p>Next: go deeper in Core types.</p>"},{"location":"en/api/","title":"API Reference","text":"<p>The API reference is generated from docstrings using mkdocstrings.</p> <p>Public entry points:</p> <ul> <li><code>jalali_pandas/__init__.py</code></li> <li><code>jalali_pandas/api/__init__.py</code></li> </ul> <p>Use the sections below to explore modules by area.</p>"},{"location":"en/api/accessors/","title":"Accessors","text":"<p>Enhanced Series accessor for Jalali datetime operations.</p> <p>Enhanced DataFrame accessor for Jalali datetime operations.</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor","title":"JalaliSeriesAccessor","text":"<p>Enhanced accessor for Jalali datetime operations on pandas Series.</p> <p>Provides properties and methods for working with Jalali (Persian/Shamsi) dates in pandas Series.</p> <p>Attributes:</p> Name Type Description <code>year</code> <code>Series</code> <p>Jalali year component.</p> <code>month</code> <code>Series</code> <p>Jalali month component (1-12).</p> <code>day</code> <code>Series</code> <p>Jalali day component.</p> <code>hour</code> <code>Series</code> <p>Hour component (0-23).</p> <code>minute</code> <code>Series</code> <p>Minute component (0-59).</p> <code>second</code> <code>Series</code> <p>Second component (0-59).</p> <code>microsecond</code> <code>Series</code> <p>Microsecond component.</p> <code>nanosecond</code> <code>Series</code> <p>Nanosecond component.</p> <code>quarter</code> <code>Series</code> <p>Quarter of the year (1-4).</p> <code>weekday</code> <code>Series</code> <p>Day of week (0=Saturday, 6=Friday).</p> <code>dayofweek</code> <code>Series</code> <p>Alias for weekday.</p> <code>dayofyear</code> <code>Series</code> <p>Day of year (1-366).</p> <code>daysinmonth</code> <code>Series</code> <p>Number of days in the month.</p> <code>week</code> <code>Series</code> <p>Week of year.</p> <code>weekofyear</code> <code>Series</code> <p>Alias for week.</p> <code>is_leap_year</code> <code>Series</code> <p>Whether the year is a leap year.</p> <code>is_month_start</code> <code>Series</code> <p>Whether the date is the first day of the month.</p> <code>is_month_end</code> <code>Series</code> <p>Whether the date is the last day of the month.</p> <code>is_quarter_start</code> <code>Series</code> <p>Whether the date is the first day of a quarter.</p> <code>is_quarter_end</code> <code>Series</code> <p>Whether the date is the last day of a quarter.</p> <code>is_year_start</code> <code>Series</code> <p>Whether the date is the first day of the year.</p> <code>is_year_end</code> <code>Series</code> <p>Whether the date is the last day of the year.</p> <code>date</code> <code>Series</code> <p>Date part (time set to midnight).</p> <code>time</code> <code>Series</code> <p>Time part as Python time objects.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import jalali_pandas\n&gt;&gt;&gt; s = pd.Series(pd.date_range(\"2023-03-21\", periods=5))\n&gt;&gt;&gt; s.jalali.to_jalali()\n&gt;&gt;&gt; s.jalali.year\n&gt;&gt;&gt; s.jalali.month_name()\n</code></pre> Source code in <code>jalali_pandas/accessors/series.py</code> <pre><code>@pd.api.extensions.register_series_accessor(\"jalali\")\nclass JalaliSeriesAccessor:\n    \"\"\"Enhanced accessor for Jalali datetime operations on pandas Series.\n\n    Provides properties and methods for working with Jalali (Persian/Shamsi)\n    dates in pandas Series.\n\n    Attributes:\n        year: Jalali year component.\n        month: Jalali month component (1-12).\n        day: Jalali day component.\n        hour: Hour component (0-23).\n        minute: Minute component (0-59).\n        second: Second component (0-59).\n        microsecond: Microsecond component.\n        nanosecond: Nanosecond component.\n        quarter: Quarter of the year (1-4).\n        weekday: Day of week (0=Saturday, 6=Friday).\n        dayofweek: Alias for weekday.\n        dayofyear: Day of year (1-366).\n        daysinmonth: Number of days in the month.\n        week: Week of year.\n        weekofyear: Alias for week.\n        is_leap_year: Whether the year is a leap year.\n        is_month_start: Whether the date is the first day of the month.\n        is_month_end: Whether the date is the last day of the month.\n        is_quarter_start: Whether the date is the first day of a quarter.\n        is_quarter_end: Whether the date is the last day of a quarter.\n        is_year_start: Whether the date is the first day of the year.\n        is_year_end: Whether the date is the last day of the year.\n        date: Date part (time set to midnight).\n        time: Time part as Python time objects.\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; import jalali_pandas\n        &gt;&gt;&gt; s = pd.Series(pd.date_range(\"2023-03-21\", periods=5))\n        &gt;&gt;&gt; s.jalali.to_jalali()\n        &gt;&gt;&gt; s.jalali.year\n        &gt;&gt;&gt; s.jalali.month_name()\n    \"\"\"\n\n    def __init__(self, pandas_obj: pd.Series) -&gt; None:\n        \"\"\"Initialize the accessor.\n\n        Args:\n            pandas_obj: A pandas Series containing datetime data.\n        \"\"\"\n        self._obj: pd.Series = pandas_obj\n\n    def _validate(self) -&gt; None:\n        \"\"\"Validate pandas series contains jdatetime objects.\n\n        Raises:\n            TypeError: If series doesn't contain jdatetime or string dates.\n        \"\"\"\n        if len(self._obj) == 0:\n            return\n        first_valid = (\n            self._obj.dropna().iloc[0] if len(self._obj.dropna()) &gt; 0 else None\n        )\n        if first_valid is not None and not isinstance(\n            first_valid, (str, jdatetime.date, jdatetime.datetime)\n        ):\n            raise TypeError(\"pandas series must be jdatetime or string of jdate\")\n\n    def _get_jdate_attr(self, attr: str) -&gt; pd.Series:\n        \"\"\"Get an attribute from jdatetime objects in the series.\n\n        Args:\n            attr: Attribute name to get.\n\n        Returns:\n            Series with the attribute values.\n        \"\"\"\n        self._validate()\n\n        def get_attr(x: Any) -&gt; Any:\n            if pd.isna(x):\n                return np.nan\n            val = getattr(x, attr, None)\n            if callable(val):\n                return val()\n            return val\n\n        return cast(pd.Series, self._obj.apply(get_attr))\n\n    # -------------------------------------------------------------------------\n    # Conversion Methods\n    # -------------------------------------------------------------------------\n\n    def to_jalali(self) -&gt; pd.Series:\n        \"\"\"Convert Gregorian datetime to Jalali datetime.\n\n        Returns:\n            Series of jdatetime objects.\n        \"\"\"\n        return cast(\n            pd.Series,\n            self._obj.apply(\n                lambda x: jdatetime.datetime.fromgregorian(date=x)\n                if not pd.isna(x)\n                else pd.NaT\n            ),\n        )\n\n    def to_gregorian(self) -&gt; pd.Series:\n        \"\"\"Convert Jalali datetime to Gregorian datetime.\n\n        Returns:\n            Series of Python datetime objects.\n        \"\"\"\n        self._validate()\n        return cast(\n            pd.Series,\n            self._obj.apply(lambda x: x.togregorian() if not pd.isna(x) else pd.NaT),\n        )\n\n    def parse_jalali(self, format: str = \"%Y-%m-%d\") -&gt; pd.Series:\n        \"\"\"Parse string dates to jdatetime objects.\n\n        Args:\n            format: strftime format string. Defaults to \"%Y-%m-%d\".\n\n        Returns:\n            Series of jdatetime objects.\n        \"\"\"\n        return cast(\n            pd.Series,\n            self._obj.apply(\n                lambda x: jdatetime.datetime.strptime(x, format)\n                if not pd.isna(x)\n                else pd.NaT\n            ),\n        )\n\n    # -------------------------------------------------------------------------\n    # Basic Properties\n    # -------------------------------------------------------------------------\n\n    @property\n    def year(self) -&gt; pd.Series:\n        \"\"\"Get Jalali year.\"\"\"\n        return self._get_jdate_attr(\"year\")\n\n    @property\n    def month(self) -&gt; pd.Series:\n        \"\"\"Get Jalali month (1-12).\"\"\"\n        return self._get_jdate_attr(\"month\")\n\n    @property\n    def day(self) -&gt; pd.Series:\n        \"\"\"Get Jalali day.\"\"\"\n        return self._get_jdate_attr(\"day\")\n\n    @property\n    def hour(self) -&gt; pd.Series:\n        \"\"\"Get hour component (0-23).\"\"\"\n        return self._get_jdate_attr(\"hour\")\n\n    @property\n    def minute(self) -&gt; pd.Series:\n        \"\"\"Get minute component (0-59).\"\"\"\n        return self._get_jdate_attr(\"minute\")\n\n    @property\n    def second(self) -&gt; pd.Series:\n        \"\"\"Get second component (0-59).\"\"\"\n        return self._get_jdate_attr(\"second\")\n\n    @property\n    def microsecond(self) -&gt; pd.Series:\n        \"\"\"Get microsecond component.\"\"\"\n        return self._get_jdate_attr(\"microsecond\")\n\n    @property\n    def nanosecond(self) -&gt; pd.Series:\n        \"\"\"Get nanosecond component (always 0 for jdatetime).\"\"\"\n        self._validate()\n        return cast(\n            pd.Series,\n            self._obj.apply(lambda x: 0 if not pd.isna(x) else np.nan),\n        )\n\n    @property\n    def weekday(self) -&gt; pd.Series:\n        \"\"\"Get Jalali weekday (0=Saturday, 6=Friday).\"\"\"\n        return self._get_jdate_attr(\"weekday\")\n\n    @property\n    def dayofweek(self) -&gt; pd.Series:\n        \"\"\"Alias for weekday.\"\"\"\n        return self.weekday\n\n    @property\n    def weeknumber(self) -&gt; pd.Series:\n        \"\"\"Get week number of the year.\"\"\"\n        return self._get_jdate_attr(\"weeknumber\")\n\n    @property\n    def week(self) -&gt; pd.Series:\n        \"\"\"Get week number of the year.\"\"\"\n        self._validate()\n\n        def get_week(x: Any) -&gt; Any:\n            if pd.isna(x):\n                return np.nan\n            return week_of_year(x.year, x.month, x.day)\n\n        return cast(pd.Series, self._obj.apply(get_week))\n\n    @property\n    def weekofyear(self) -&gt; pd.Series:\n        \"\"\"Alias for week.\"\"\"\n        return self.week\n\n    @property\n    def quarter(self) -&gt; pd.Series:\n        \"\"\"Get Jalali quarter (1-4).\"\"\"\n        self._validate()\n\n        def get_quarter(x: Any) -&gt; Any:\n            if pd.isna(x):\n                return np.nan\n            return quarter_of_month(x.month)\n\n        return cast(pd.Series, self._obj.apply(get_quarter))\n\n    @property\n    def dayofyear(self) -&gt; pd.Series:\n        \"\"\"Get day of year (1-366).\"\"\"\n        self._validate()\n\n        def get_dayofyear(x: Any) -&gt; Any:\n            if pd.isna(x):\n                return np.nan\n            return day_of_year(x.year, x.month, x.day)\n\n        return cast(pd.Series, self._obj.apply(get_dayofyear))\n\n    @property\n    def daysinmonth(self) -&gt; pd.Series:\n        \"\"\"Get number of days in the month.\"\"\"\n        self._validate()\n\n        def get_daysinmonth(x: Any) -&gt; Any:\n            if pd.isna(x):\n                return np.nan\n            return days_in_month(x.year, x.month)\n\n        return cast(pd.Series, self._obj.apply(get_daysinmonth))\n\n    @property\n    def days_in_month(self) -&gt; pd.Series:\n        \"\"\"Alias for daysinmonth.\"\"\"\n        return self.daysinmonth\n\n    # -------------------------------------------------------------------------\n    # Boolean Properties\n    # -------------------------------------------------------------------------\n\n    @property\n    def is_leap_year(self) -&gt; pd.Series:\n        \"\"\"Check if the year is a leap year.\"\"\"\n        self._validate()\n\n        def check_leap(x: Any) -&gt; Any:\n            if pd.isna(x):\n                return False\n            return is_leap_year(x.year)\n\n        return cast(pd.Series, self._obj.apply(check_leap))\n\n    @property\n    def is_month_start(self) -&gt; pd.Series:\n        \"\"\"Check if the date is the first day of the month.\"\"\"\n        self._validate()\n\n        def check_month_start(x: Any) -&gt; Any:\n            if pd.isna(x):\n                return False\n            return x.day == 1\n\n        return cast(pd.Series, self._obj.apply(check_month_start))\n\n    @property\n    def is_month_end(self) -&gt; pd.Series:\n        \"\"\"Check if the date is the last day of the month.\"\"\"\n        self._validate()\n\n        def check_month_end(x: Any) -&gt; Any:\n            if pd.isna(x):\n                return False\n            return x.day == days_in_month(x.year, x.month)\n\n        return cast(pd.Series, self._obj.apply(check_month_end))\n\n    @property\n    def is_quarter_start(self) -&gt; pd.Series:\n        \"\"\"Check if the date is the first day of a quarter.\"\"\"\n        self._validate()\n\n        def check_quarter_start(x: Any) -&gt; Any:\n            if pd.isna(x):\n                return False\n            return x.month in (1, 4, 7, 10) and x.day == 1\n\n        return cast(pd.Series, self._obj.apply(check_quarter_start))\n\n    @property\n    def is_quarter_end(self) -&gt; pd.Series:\n        \"\"\"Check if the date is the last day of a quarter.\"\"\"\n        self._validate()\n\n        def check_quarter_end(x: Any) -&gt; Any:\n            if pd.isna(x):\n                return False\n            if x.month not in (3, 6, 9, 12):\n                return False\n            return x.day == days_in_month(x.year, x.month)\n\n        return cast(pd.Series, self._obj.apply(check_quarter_end))\n\n    @property\n    def is_year_start(self) -&gt; pd.Series:\n        \"\"\"Check if the date is the first day of the year (Nowruz).\"\"\"\n        self._validate()\n\n        def check_year_start(x: Any) -&gt; Any:\n            if pd.isna(x):\n                return False\n            return x.month == 1 and x.day == 1\n\n        return cast(pd.Series, self._obj.apply(check_year_start))\n\n    @property\n    def is_year_end(self) -&gt; pd.Series:\n        \"\"\"Check if the date is the last day of the year.\"\"\"\n        self._validate()\n\n        def check_year_end(x: Any) -&gt; Any:\n            if pd.isna(x):\n                return False\n            return x.month == 12 and x.day == days_in_month(x.year, 12)\n\n        return cast(pd.Series, self._obj.apply(check_year_end))\n\n    # -------------------------------------------------------------------------\n    # Date/Time Properties\n    # -------------------------------------------------------------------------\n\n    @property\n    def date(self) -&gt; pd.Series:\n        \"\"\"Get date part (time set to midnight).\"\"\"\n        self._validate()\n\n        def get_date(x: Any) -&gt; Any:\n            if pd.isna(x):\n                return pd.NaT\n            if isinstance(x, jdatetime.datetime):\n                return jdatetime.datetime(x.year, x.month, x.day)\n            return x\n\n        return cast(pd.Series, self._obj.apply(get_date))\n\n    @property\n    def time(self) -&gt; pd.Series:\n        \"\"\"Get time part as Python time objects.\"\"\"\n        self._validate()\n\n        def get_time(x: Any) -&gt; Any:\n            if pd.isna(x):\n                return None\n            if isinstance(x, jdatetime.datetime):\n                return time(\n                    hour=x.hour,\n                    minute=x.minute,\n                    second=x.second,\n                    microsecond=x.microsecond,\n                )\n            return time(0, 0, 0)\n\n        return cast(pd.Series, self._obj.apply(get_time))\n\n    # -------------------------------------------------------------------------\n    # String Methods\n    # -------------------------------------------------------------------------\n\n    def strftime(self, date_format: str) -&gt; pd.Series:\n        \"\"\"Format dates as strings.\n\n        Args:\n            date_format: strftime format string.\n\n        Returns:\n            Series of formatted strings.\n        \"\"\"\n        self._validate()\n\n        def format_date(x: Any) -&gt; Any:\n            if pd.isna(x):\n                return None\n            return x.strftime(date_format)\n\n        return cast(pd.Series, self._obj.apply(format_date))\n\n    def month_name(self, locale: Literal[\"fa\", \"en\"] = \"en\") -&gt; pd.Series:\n        \"\"\"Get month names.\n\n        Args:\n            locale: Language for month names. 'fa' for Persian, 'en' for English.\n                Defaults to 'en'.\n\n        Returns:\n            Series of month names.\n        \"\"\"\n        self._validate()\n        names = MONTH_NAMES_FA if locale == \"fa\" else MONTH_NAMES_EN\n\n        def get_month_name(x: Any) -&gt; Any:\n            if pd.isna(x):\n                return None\n            return names[x.month - 1]\n\n        return cast(pd.Series, self._obj.apply(get_month_name))\n\n    def day_name(self, locale: Literal[\"fa\", \"en\"] = \"en\") -&gt; pd.Series:\n        \"\"\"Get day names.\n\n        Args:\n            locale: Language for day names. 'fa' for Persian, 'en' for English.\n                Defaults to 'en'.\n\n        Returns:\n            Series of day names.\n        \"\"\"\n        self._validate()\n        names = WEEKDAY_NAMES_FA if locale == \"fa\" else WEEKDAY_NAMES_EN\n\n        def get_day_name(x: Any) -&gt; Any:\n            if pd.isna(x):\n                return None\n            wd = weekday_of_jalali(x.year, x.month, x.day)\n            return names[wd]\n\n        return cast(pd.Series, self._obj.apply(get_day_name))\n\n    # -------------------------------------------------------------------------\n    # Normalization Methods\n    # -------------------------------------------------------------------------\n\n    def normalize(self) -&gt; pd.Series:\n        \"\"\"Normalize dates to midnight.\n\n        Returns:\n            Series with time components set to zero.\n        \"\"\"\n        self._validate()\n\n        def normalize_date(x: Any) -&gt; Any:\n            if pd.isna(x):\n                return pd.NaT\n            if isinstance(x, jdatetime.datetime):\n                return jdatetime.datetime(x.year, x.month, x.day)\n            return x\n\n        return cast(pd.Series, self._obj.apply(normalize_date))\n\n    def floor(self, freq: str) -&gt; pd.Series:\n        \"\"\"Floor dates to specified frequency.\n\n        Args:\n            freq: Frequency string. Supported: 'D' (day), 'h' (hour),\n                'min' (minute), 's' (second).\n\n        Returns:\n            Series with floored dates.\n        \"\"\"\n        self._validate()\n\n        def floor_date(x: Any) -&gt; Any:\n            if pd.isna(x):\n                return pd.NaT\n            if not isinstance(x, jdatetime.datetime):\n                return x\n\n            if freq in (\"D\", \"d\"):\n                return jdatetime.datetime(x.year, x.month, x.day)\n            elif freq in (\"h\", \"H\"):\n                return jdatetime.datetime(x.year, x.month, x.day, x.hour)\n            elif freq in (\"min\", \"T\"):\n                return jdatetime.datetime(x.year, x.month, x.day, x.hour, x.minute)\n            elif freq in (\"s\", \"S\"):\n                return jdatetime.datetime(\n                    x.year, x.month, x.day, x.hour, x.minute, x.second\n                )\n            else:\n                raise ValueError(f\"Unsupported frequency: {freq}\")\n\n        return cast(pd.Series, self._obj.apply(floor_date))\n\n    def ceil(self, freq: str) -&gt; pd.Series:\n        \"\"\"Ceil dates to specified frequency.\n\n        Args:\n            freq: Frequency string. Supported: 'D' (day), 'h' (hour),\n                'min' (minute), 's' (second).\n\n        Returns:\n            Series with ceiled dates.\n        \"\"\"\n        self._validate()\n\n        def ceil_date(x: Any) -&gt; Any:\n            if pd.isna(x):\n                return pd.NaT\n            if not isinstance(x, jdatetime.datetime):\n                return x\n\n            if freq in (\"D\", \"d\"):\n                if x.hour &gt; 0 or x.minute &gt; 0 or x.second &gt; 0 or x.microsecond &gt; 0:\n                    # Add one day\n                    greg = x.togregorian()\n                    greg = greg + pd.Timedelta(days=1)\n                    new_j = jdatetime.datetime.fromgregorian(datetime=greg)\n                    return jdatetime.datetime(new_j.year, new_j.month, new_j.day)\n                return jdatetime.datetime(x.year, x.month, x.day)\n            elif freq in (\"h\", \"H\"):\n                if x.minute &gt; 0 or x.second &gt; 0 or x.microsecond &gt; 0:\n                    greg = x.togregorian()\n                    greg = greg + pd.Timedelta(hours=1)\n                    new_j = jdatetime.datetime.fromgregorian(datetime=greg)\n                    return jdatetime.datetime(\n                        new_j.year, new_j.month, new_j.day, new_j.hour\n                    )\n                return jdatetime.datetime(x.year, x.month, x.day, x.hour)\n            elif freq in (\"min\", \"T\"):\n                if x.second &gt; 0 or x.microsecond &gt; 0:\n                    greg = x.togregorian()\n                    greg = greg + pd.Timedelta(minutes=1)\n                    new_j = jdatetime.datetime.fromgregorian(datetime=greg)\n                    return jdatetime.datetime(\n                        new_j.year, new_j.month, new_j.day, new_j.hour, new_j.minute\n                    )\n                return jdatetime.datetime(x.year, x.month, x.day, x.hour, x.minute)\n            elif freq in (\"s\", \"S\"):\n                if x.microsecond &gt; 0:\n                    greg = x.togregorian()\n                    greg = greg + pd.Timedelta(seconds=1)\n                    new_j = jdatetime.datetime.fromgregorian(datetime=greg)\n                    return jdatetime.datetime(\n                        new_j.year,\n                        new_j.month,\n                        new_j.day,\n                        new_j.hour,\n                        new_j.minute,\n                        new_j.second,\n                    )\n                return jdatetime.datetime(\n                    x.year, x.month, x.day, x.hour, x.minute, x.second\n                )\n            else:\n                raise ValueError(f\"Unsupported frequency: {freq}\")\n\n        return cast(pd.Series, self._obj.apply(ceil_date))\n\n    def round(self, freq: str) -&gt; pd.Series:\n        \"\"\"Round dates to specified frequency.\n\n        Args:\n            freq: Frequency string. Supported: 'D' (day), 'h' (hour),\n                'min' (minute), 's' (second).\n\n        Returns:\n            Series with rounded dates.\n        \"\"\"\n        self._validate()\n\n        def round_date(x: Any) -&gt; Any:\n            if pd.isna(x):\n                return pd.NaT\n            if not isinstance(x, jdatetime.datetime):\n                return x\n\n            if freq in (\"D\", \"d\"):\n                # Round to nearest day (12:00 is the midpoint)\n                if x.hour &gt;= 12:\n                    greg = x.togregorian()\n                    greg = greg + pd.Timedelta(days=1)\n                    new_j = jdatetime.datetime.fromgregorian(datetime=greg)\n                    return jdatetime.datetime(new_j.year, new_j.month, new_j.day)\n                return jdatetime.datetime(x.year, x.month, x.day)\n            elif freq in (\"h\", \"H\"):\n                if x.minute &gt;= 30:\n                    greg = x.togregorian()\n                    greg = greg + pd.Timedelta(hours=1)\n                    new_j = jdatetime.datetime.fromgregorian(datetime=greg)\n                    return jdatetime.datetime(\n                        new_j.year, new_j.month, new_j.day, new_j.hour\n                    )\n                return jdatetime.datetime(x.year, x.month, x.day, x.hour)\n            elif freq in (\"min\", \"T\"):\n                if x.second &gt;= 30:\n                    greg = x.togregorian()\n                    greg = greg + pd.Timedelta(minutes=1)\n                    new_j = jdatetime.datetime.fromgregorian(datetime=greg)\n                    return jdatetime.datetime(\n                        new_j.year, new_j.month, new_j.day, new_j.hour, new_j.minute\n                    )\n                return jdatetime.datetime(x.year, x.month, x.day, x.hour, x.minute)\n            elif freq in (\"s\", \"S\"):\n                if x.microsecond &gt;= 500000:\n                    greg = x.togregorian()\n                    greg = greg + pd.Timedelta(seconds=1)\n                    new_j = jdatetime.datetime.fromgregorian(datetime=greg)\n                    return jdatetime.datetime(\n                        new_j.year,\n                        new_j.month,\n                        new_j.day,\n                        new_j.hour,\n                        new_j.minute,\n                        new_j.second,\n                    )\n                return jdatetime.datetime(\n                    x.year, x.month, x.day, x.hour, x.minute, x.second\n                )\n            else:\n                raise ValueError(f\"Unsupported frequency: {freq}\")\n\n        return cast(pd.Series, self._obj.apply(round_date))\n\n    # -------------------------------------------------------------------------\n    # Timezone Methods\n    # -------------------------------------------------------------------------\n\n    def tz_localize(\n        self,\n        tz: dt_tzinfo | str | None,\n        ambiguous: str = \"raise\",\n        nonexistent: str = \"raise\",\n    ) -&gt; pd.Series:\n        \"\"\"Localize tz-naive dates to a timezone.\n\n        This converts the jdatetime objects to Gregorian, localizes them,\n        and returns the localized Gregorian datetimes.\n\n        Args:\n            tz: Timezone to localize to.\n            ambiguous: How to handle ambiguous times. Defaults to 'raise'.\n            nonexistent: How to handle nonexistent times. Defaults to 'raise'.\n\n        Returns:\n            Series of timezone-aware Gregorian datetimes.\n        \"\"\"\n        self._validate()\n        gregorian = self.to_gregorian()\n        dt_index = pd.DatetimeIndex(pd.to_datetime(gregorian))\n        localized = dt_index.tz_localize(\n            tz, ambiguous=ambiguous, nonexistent=nonexistent\n        )\n        return cast(\n            pd.Series,\n            pd.Series(localized, index=self._obj.index, name=self._obj.name),\n        )\n\n    def tz_convert(self, tz: dt_tzinfo | str | None) -&gt; pd.Series:\n        \"\"\"Convert tz-aware dates to another timezone.\n\n        This converts the jdatetime objects to Gregorian, converts timezone,\n        and returns the converted Gregorian datetimes.\n\n        Args:\n            tz: Target timezone.\n\n        Returns:\n            Series of timezone-converted Gregorian datetimes.\n        \"\"\"\n        self._validate()\n        gregorian = self.to_gregorian()\n        dt_index = pd.DatetimeIndex(pd.to_datetime(gregorian))\n        converted = dt_index.tz_convert(tz)\n        return cast(\n            pd.Series,\n            pd.Series(converted, index=self._obj.index, name=self._obj.name),\n        )\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.date","title":"date  <code>property</code>","text":"<pre><code>date: Series\n</code></pre> <p>Get date part (time set to midnight).</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.day","title":"day  <code>property</code>","text":"<pre><code>day: Series\n</code></pre> <p>Get Jalali day.</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.dayofweek","title":"dayofweek  <code>property</code>","text":"<pre><code>dayofweek: Series\n</code></pre> <p>Alias for weekday.</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.dayofyear","title":"dayofyear  <code>property</code>","text":"<pre><code>dayofyear: Series\n</code></pre> <p>Get day of year (1-366).</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.days_in_month","title":"days_in_month  <code>property</code>","text":"<pre><code>days_in_month: Series\n</code></pre> <p>Alias for daysinmonth.</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.daysinmonth","title":"daysinmonth  <code>property</code>","text":"<pre><code>daysinmonth: Series\n</code></pre> <p>Get number of days in the month.</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.hour","title":"hour  <code>property</code>","text":"<pre><code>hour: Series\n</code></pre> <p>Get hour component (0-23).</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.is_leap_year","title":"is_leap_year  <code>property</code>","text":"<pre><code>is_leap_year: Series\n</code></pre> <p>Check if the year is a leap year.</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.is_month_end","title":"is_month_end  <code>property</code>","text":"<pre><code>is_month_end: Series\n</code></pre> <p>Check if the date is the last day of the month.</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.is_month_start","title":"is_month_start  <code>property</code>","text":"<pre><code>is_month_start: Series\n</code></pre> <p>Check if the date is the first day of the month.</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.is_quarter_end","title":"is_quarter_end  <code>property</code>","text":"<pre><code>is_quarter_end: Series\n</code></pre> <p>Check if the date is the last day of a quarter.</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.is_quarter_start","title":"is_quarter_start  <code>property</code>","text":"<pre><code>is_quarter_start: Series\n</code></pre> <p>Check if the date is the first day of a quarter.</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.is_year_end","title":"is_year_end  <code>property</code>","text":"<pre><code>is_year_end: Series\n</code></pre> <p>Check if the date is the last day of the year.</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.is_year_start","title":"is_year_start  <code>property</code>","text":"<pre><code>is_year_start: Series\n</code></pre> <p>Check if the date is the first day of the year (Nowruz).</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.microsecond","title":"microsecond  <code>property</code>","text":"<pre><code>microsecond: Series\n</code></pre> <p>Get microsecond component.</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.minute","title":"minute  <code>property</code>","text":"<pre><code>minute: Series\n</code></pre> <p>Get minute component (0-59).</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.month","title":"month  <code>property</code>","text":"<pre><code>month: Series\n</code></pre> <p>Get Jalali month (1-12).</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.nanosecond","title":"nanosecond  <code>property</code>","text":"<pre><code>nanosecond: Series\n</code></pre> <p>Get nanosecond component (always 0 for jdatetime).</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.quarter","title":"quarter  <code>property</code>","text":"<pre><code>quarter: Series\n</code></pre> <p>Get Jalali quarter (1-4).</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.second","title":"second  <code>property</code>","text":"<pre><code>second: Series\n</code></pre> <p>Get second component (0-59).</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.time","title":"time  <code>property</code>","text":"<pre><code>time: Series\n</code></pre> <p>Get time part as Python time objects.</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.week","title":"week  <code>property</code>","text":"<pre><code>week: Series\n</code></pre> <p>Get week number of the year.</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.weekday","title":"weekday  <code>property</code>","text":"<pre><code>weekday: Series\n</code></pre> <p>Get Jalali weekday (0=Saturday, 6=Friday).</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.weeknumber","title":"weeknumber  <code>property</code>","text":"<pre><code>weeknumber: Series\n</code></pre> <p>Get week number of the year.</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.weekofyear","title":"weekofyear  <code>property</code>","text":"<pre><code>weekofyear: Series\n</code></pre> <p>Alias for week.</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.year","title":"year  <code>property</code>","text":"<pre><code>year: Series\n</code></pre> <p>Get Jalali year.</p>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.__init__","title":"__init__","text":"<pre><code>__init__(pandas_obj: Series) -&gt; None\n</code></pre> <p>Initialize the accessor.</p> <p>Parameters:</p> Name Type Description Default <code>pandas_obj</code> <code>Series</code> <p>A pandas Series containing datetime data.</p> required Source code in <code>jalali_pandas/accessors/series.py</code> <pre><code>def __init__(self, pandas_obj: pd.Series) -&gt; None:\n    \"\"\"Initialize the accessor.\n\n    Args:\n        pandas_obj: A pandas Series containing datetime data.\n    \"\"\"\n    self._obj: pd.Series = pandas_obj\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.ceil","title":"ceil","text":"<pre><code>ceil(freq: str) -&gt; pd.Series\n</code></pre> <p>Ceil dates to specified frequency.</p> <p>Parameters:</p> Name Type Description Default <code>freq</code> <code>str</code> <p>Frequency string. Supported: 'D' (day), 'h' (hour), 'min' (minute), 's' (second).</p> required <p>Returns:</p> Type Description <code>Series</code> <p>Series with ceiled dates.</p> Source code in <code>jalali_pandas/accessors/series.py</code> <pre><code>def ceil(self, freq: str) -&gt; pd.Series:\n    \"\"\"Ceil dates to specified frequency.\n\n    Args:\n        freq: Frequency string. Supported: 'D' (day), 'h' (hour),\n            'min' (minute), 's' (second).\n\n    Returns:\n        Series with ceiled dates.\n    \"\"\"\n    self._validate()\n\n    def ceil_date(x: Any) -&gt; Any:\n        if pd.isna(x):\n            return pd.NaT\n        if not isinstance(x, jdatetime.datetime):\n            return x\n\n        if freq in (\"D\", \"d\"):\n            if x.hour &gt; 0 or x.minute &gt; 0 or x.second &gt; 0 or x.microsecond &gt; 0:\n                # Add one day\n                greg = x.togregorian()\n                greg = greg + pd.Timedelta(days=1)\n                new_j = jdatetime.datetime.fromgregorian(datetime=greg)\n                return jdatetime.datetime(new_j.year, new_j.month, new_j.day)\n            return jdatetime.datetime(x.year, x.month, x.day)\n        elif freq in (\"h\", \"H\"):\n            if x.minute &gt; 0 or x.second &gt; 0 or x.microsecond &gt; 0:\n                greg = x.togregorian()\n                greg = greg + pd.Timedelta(hours=1)\n                new_j = jdatetime.datetime.fromgregorian(datetime=greg)\n                return jdatetime.datetime(\n                    new_j.year, new_j.month, new_j.day, new_j.hour\n                )\n            return jdatetime.datetime(x.year, x.month, x.day, x.hour)\n        elif freq in (\"min\", \"T\"):\n            if x.second &gt; 0 or x.microsecond &gt; 0:\n                greg = x.togregorian()\n                greg = greg + pd.Timedelta(minutes=1)\n                new_j = jdatetime.datetime.fromgregorian(datetime=greg)\n                return jdatetime.datetime(\n                    new_j.year, new_j.month, new_j.day, new_j.hour, new_j.minute\n                )\n            return jdatetime.datetime(x.year, x.month, x.day, x.hour, x.minute)\n        elif freq in (\"s\", \"S\"):\n            if x.microsecond &gt; 0:\n                greg = x.togregorian()\n                greg = greg + pd.Timedelta(seconds=1)\n                new_j = jdatetime.datetime.fromgregorian(datetime=greg)\n                return jdatetime.datetime(\n                    new_j.year,\n                    new_j.month,\n                    new_j.day,\n                    new_j.hour,\n                    new_j.minute,\n                    new_j.second,\n                )\n            return jdatetime.datetime(\n                x.year, x.month, x.day, x.hour, x.minute, x.second\n            )\n        else:\n            raise ValueError(f\"Unsupported frequency: {freq}\")\n\n    return cast(pd.Series, self._obj.apply(ceil_date))\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.day_name","title":"day_name","text":"<pre><code>day_name(locale: Literal['fa', 'en'] = 'en') -&gt; pd.Series\n</code></pre> <p>Get day names.</p> <p>Parameters:</p> Name Type Description Default <code>locale</code> <code>Literal['fa', 'en']</code> <p>Language for day names. 'fa' for Persian, 'en' for English. Defaults to 'en'.</p> <code>'en'</code> <p>Returns:</p> Type Description <code>Series</code> <p>Series of day names.</p> Source code in <code>jalali_pandas/accessors/series.py</code> <pre><code>def day_name(self, locale: Literal[\"fa\", \"en\"] = \"en\") -&gt; pd.Series:\n    \"\"\"Get day names.\n\n    Args:\n        locale: Language for day names. 'fa' for Persian, 'en' for English.\n            Defaults to 'en'.\n\n    Returns:\n        Series of day names.\n    \"\"\"\n    self._validate()\n    names = WEEKDAY_NAMES_FA if locale == \"fa\" else WEEKDAY_NAMES_EN\n\n    def get_day_name(x: Any) -&gt; Any:\n        if pd.isna(x):\n            return None\n        wd = weekday_of_jalali(x.year, x.month, x.day)\n        return names[wd]\n\n    return cast(pd.Series, self._obj.apply(get_day_name))\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.floor","title":"floor","text":"<pre><code>floor(freq: str) -&gt; pd.Series\n</code></pre> <p>Floor dates to specified frequency.</p> <p>Parameters:</p> Name Type Description Default <code>freq</code> <code>str</code> <p>Frequency string. Supported: 'D' (day), 'h' (hour), 'min' (minute), 's' (second).</p> required <p>Returns:</p> Type Description <code>Series</code> <p>Series with floored dates.</p> Source code in <code>jalali_pandas/accessors/series.py</code> <pre><code>def floor(self, freq: str) -&gt; pd.Series:\n    \"\"\"Floor dates to specified frequency.\n\n    Args:\n        freq: Frequency string. Supported: 'D' (day), 'h' (hour),\n            'min' (minute), 's' (second).\n\n    Returns:\n        Series with floored dates.\n    \"\"\"\n    self._validate()\n\n    def floor_date(x: Any) -&gt; Any:\n        if pd.isna(x):\n            return pd.NaT\n        if not isinstance(x, jdatetime.datetime):\n            return x\n\n        if freq in (\"D\", \"d\"):\n            return jdatetime.datetime(x.year, x.month, x.day)\n        elif freq in (\"h\", \"H\"):\n            return jdatetime.datetime(x.year, x.month, x.day, x.hour)\n        elif freq in (\"min\", \"T\"):\n            return jdatetime.datetime(x.year, x.month, x.day, x.hour, x.minute)\n        elif freq in (\"s\", \"S\"):\n            return jdatetime.datetime(\n                x.year, x.month, x.day, x.hour, x.minute, x.second\n            )\n        else:\n            raise ValueError(f\"Unsupported frequency: {freq}\")\n\n    return cast(pd.Series, self._obj.apply(floor_date))\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.month_name","title":"month_name","text":"<pre><code>month_name(locale: Literal['fa', 'en'] = 'en') -&gt; pd.Series\n</code></pre> <p>Get month names.</p> <p>Parameters:</p> Name Type Description Default <code>locale</code> <code>Literal['fa', 'en']</code> <p>Language for month names. 'fa' for Persian, 'en' for English. Defaults to 'en'.</p> <code>'en'</code> <p>Returns:</p> Type Description <code>Series</code> <p>Series of month names.</p> Source code in <code>jalali_pandas/accessors/series.py</code> <pre><code>def month_name(self, locale: Literal[\"fa\", \"en\"] = \"en\") -&gt; pd.Series:\n    \"\"\"Get month names.\n\n    Args:\n        locale: Language for month names. 'fa' for Persian, 'en' for English.\n            Defaults to 'en'.\n\n    Returns:\n        Series of month names.\n    \"\"\"\n    self._validate()\n    names = MONTH_NAMES_FA if locale == \"fa\" else MONTH_NAMES_EN\n\n    def get_month_name(x: Any) -&gt; Any:\n        if pd.isna(x):\n            return None\n        return names[x.month - 1]\n\n    return cast(pd.Series, self._obj.apply(get_month_name))\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.normalize","title":"normalize","text":"<pre><code>normalize() -&gt; pd.Series\n</code></pre> <p>Normalize dates to midnight.</p> <p>Returns:</p> Type Description <code>Series</code> <p>Series with time components set to zero.</p> Source code in <code>jalali_pandas/accessors/series.py</code> <pre><code>def normalize(self) -&gt; pd.Series:\n    \"\"\"Normalize dates to midnight.\n\n    Returns:\n        Series with time components set to zero.\n    \"\"\"\n    self._validate()\n\n    def normalize_date(x: Any) -&gt; Any:\n        if pd.isna(x):\n            return pd.NaT\n        if isinstance(x, jdatetime.datetime):\n            return jdatetime.datetime(x.year, x.month, x.day)\n        return x\n\n    return cast(pd.Series, self._obj.apply(normalize_date))\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.parse_jalali","title":"parse_jalali","text":"<pre><code>parse_jalali(format: str = '%Y-%m-%d') -&gt; pd.Series\n</code></pre> <p>Parse string dates to jdatetime objects.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>str</code> <p>strftime format string. Defaults to \"%Y-%m-%d\".</p> <code>'%Y-%m-%d'</code> <p>Returns:</p> Type Description <code>Series</code> <p>Series of jdatetime objects.</p> Source code in <code>jalali_pandas/accessors/series.py</code> <pre><code>def parse_jalali(self, format: str = \"%Y-%m-%d\") -&gt; pd.Series:\n    \"\"\"Parse string dates to jdatetime objects.\n\n    Args:\n        format: strftime format string. Defaults to \"%Y-%m-%d\".\n\n    Returns:\n        Series of jdatetime objects.\n    \"\"\"\n    return cast(\n        pd.Series,\n        self._obj.apply(\n            lambda x: jdatetime.datetime.strptime(x, format)\n            if not pd.isna(x)\n            else pd.NaT\n        ),\n    )\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.round","title":"round","text":"<pre><code>round(freq: str) -&gt; pd.Series\n</code></pre> <p>Round dates to specified frequency.</p> <p>Parameters:</p> Name Type Description Default <code>freq</code> <code>str</code> <p>Frequency string. Supported: 'D' (day), 'h' (hour), 'min' (minute), 's' (second).</p> required <p>Returns:</p> Type Description <code>Series</code> <p>Series with rounded dates.</p> Source code in <code>jalali_pandas/accessors/series.py</code> <pre><code>def round(self, freq: str) -&gt; pd.Series:\n    \"\"\"Round dates to specified frequency.\n\n    Args:\n        freq: Frequency string. Supported: 'D' (day), 'h' (hour),\n            'min' (minute), 's' (second).\n\n    Returns:\n        Series with rounded dates.\n    \"\"\"\n    self._validate()\n\n    def round_date(x: Any) -&gt; Any:\n        if pd.isna(x):\n            return pd.NaT\n        if not isinstance(x, jdatetime.datetime):\n            return x\n\n        if freq in (\"D\", \"d\"):\n            # Round to nearest day (12:00 is the midpoint)\n            if x.hour &gt;= 12:\n                greg = x.togregorian()\n                greg = greg + pd.Timedelta(days=1)\n                new_j = jdatetime.datetime.fromgregorian(datetime=greg)\n                return jdatetime.datetime(new_j.year, new_j.month, new_j.day)\n            return jdatetime.datetime(x.year, x.month, x.day)\n        elif freq in (\"h\", \"H\"):\n            if x.minute &gt;= 30:\n                greg = x.togregorian()\n                greg = greg + pd.Timedelta(hours=1)\n                new_j = jdatetime.datetime.fromgregorian(datetime=greg)\n                return jdatetime.datetime(\n                    new_j.year, new_j.month, new_j.day, new_j.hour\n                )\n            return jdatetime.datetime(x.year, x.month, x.day, x.hour)\n        elif freq in (\"min\", \"T\"):\n            if x.second &gt;= 30:\n                greg = x.togregorian()\n                greg = greg + pd.Timedelta(minutes=1)\n                new_j = jdatetime.datetime.fromgregorian(datetime=greg)\n                return jdatetime.datetime(\n                    new_j.year, new_j.month, new_j.day, new_j.hour, new_j.minute\n                )\n            return jdatetime.datetime(x.year, x.month, x.day, x.hour, x.minute)\n        elif freq in (\"s\", \"S\"):\n            if x.microsecond &gt;= 500000:\n                greg = x.togregorian()\n                greg = greg + pd.Timedelta(seconds=1)\n                new_j = jdatetime.datetime.fromgregorian(datetime=greg)\n                return jdatetime.datetime(\n                    new_j.year,\n                    new_j.month,\n                    new_j.day,\n                    new_j.hour,\n                    new_j.minute,\n                    new_j.second,\n                )\n            return jdatetime.datetime(\n                x.year, x.month, x.day, x.hour, x.minute, x.second\n            )\n        else:\n            raise ValueError(f\"Unsupported frequency: {freq}\")\n\n    return cast(pd.Series, self._obj.apply(round_date))\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.strftime","title":"strftime","text":"<pre><code>strftime(date_format: str) -&gt; pd.Series\n</code></pre> <p>Format dates as strings.</p> <p>Parameters:</p> Name Type Description Default <code>date_format</code> <code>str</code> <p>strftime format string.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>Series of formatted strings.</p> Source code in <code>jalali_pandas/accessors/series.py</code> <pre><code>def strftime(self, date_format: str) -&gt; pd.Series:\n    \"\"\"Format dates as strings.\n\n    Args:\n        date_format: strftime format string.\n\n    Returns:\n        Series of formatted strings.\n    \"\"\"\n    self._validate()\n\n    def format_date(x: Any) -&gt; Any:\n        if pd.isna(x):\n            return None\n        return x.strftime(date_format)\n\n    return cast(pd.Series, self._obj.apply(format_date))\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.to_gregorian","title":"to_gregorian","text":"<pre><code>to_gregorian() -&gt; pd.Series\n</code></pre> <p>Convert Jalali datetime to Gregorian datetime.</p> <p>Returns:</p> Type Description <code>Series</code> <p>Series of Python datetime objects.</p> Source code in <code>jalali_pandas/accessors/series.py</code> <pre><code>def to_gregorian(self) -&gt; pd.Series:\n    \"\"\"Convert Jalali datetime to Gregorian datetime.\n\n    Returns:\n        Series of Python datetime objects.\n    \"\"\"\n    self._validate()\n    return cast(\n        pd.Series,\n        self._obj.apply(lambda x: x.togregorian() if not pd.isna(x) else pd.NaT),\n    )\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.to_jalali","title":"to_jalali","text":"<pre><code>to_jalali() -&gt; pd.Series\n</code></pre> <p>Convert Gregorian datetime to Jalali datetime.</p> <p>Returns:</p> Type Description <code>Series</code> <p>Series of jdatetime objects.</p> Source code in <code>jalali_pandas/accessors/series.py</code> <pre><code>def to_jalali(self) -&gt; pd.Series:\n    \"\"\"Convert Gregorian datetime to Jalali datetime.\n\n    Returns:\n        Series of jdatetime objects.\n    \"\"\"\n    return cast(\n        pd.Series,\n        self._obj.apply(\n            lambda x: jdatetime.datetime.fromgregorian(date=x)\n            if not pd.isna(x)\n            else pd.NaT\n        ),\n    )\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.tz_convert","title":"tz_convert","text":"<pre><code>tz_convert(tz: tzinfo | str | None) -&gt; pd.Series\n</code></pre> <p>Convert tz-aware dates to another timezone.</p> <p>This converts the jdatetime objects to Gregorian, converts timezone, and returns the converted Gregorian datetimes.</p> <p>Parameters:</p> Name Type Description Default <code>tz</code> <code>tzinfo | str | None</code> <p>Target timezone.</p> required <p>Returns:</p> Type Description <code>Series</code> <p>Series of timezone-converted Gregorian datetimes.</p> Source code in <code>jalali_pandas/accessors/series.py</code> <pre><code>def tz_convert(self, tz: dt_tzinfo | str | None) -&gt; pd.Series:\n    \"\"\"Convert tz-aware dates to another timezone.\n\n    This converts the jdatetime objects to Gregorian, converts timezone,\n    and returns the converted Gregorian datetimes.\n\n    Args:\n        tz: Target timezone.\n\n    Returns:\n        Series of timezone-converted Gregorian datetimes.\n    \"\"\"\n    self._validate()\n    gregorian = self.to_gregorian()\n    dt_index = pd.DatetimeIndex(pd.to_datetime(gregorian))\n    converted = dt_index.tz_convert(tz)\n    return cast(\n        pd.Series,\n        pd.Series(converted, index=self._obj.index, name=self._obj.name),\n    )\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.series.JalaliSeriesAccessor.tz_localize","title":"tz_localize","text":"<pre><code>tz_localize(tz: tzinfo | str | None, ambiguous: str = 'raise', nonexistent: str = 'raise') -&gt; pd.Series\n</code></pre> <p>Localize tz-naive dates to a timezone.</p> <p>This converts the jdatetime objects to Gregorian, localizes them, and returns the localized Gregorian datetimes.</p> <p>Parameters:</p> Name Type Description Default <code>tz</code> <code>tzinfo | str | None</code> <p>Timezone to localize to.</p> required <code>ambiguous</code> <code>str</code> <p>How to handle ambiguous times. Defaults to 'raise'.</p> <code>'raise'</code> <code>nonexistent</code> <code>str</code> <p>How to handle nonexistent times. Defaults to 'raise'.</p> <code>'raise'</code> <p>Returns:</p> Type Description <code>Series</code> <p>Series of timezone-aware Gregorian datetimes.</p> Source code in <code>jalali_pandas/accessors/series.py</code> <pre><code>def tz_localize(\n    self,\n    tz: dt_tzinfo | str | None,\n    ambiguous: str = \"raise\",\n    nonexistent: str = \"raise\",\n) -&gt; pd.Series:\n    \"\"\"Localize tz-naive dates to a timezone.\n\n    This converts the jdatetime objects to Gregorian, localizes them,\n    and returns the localized Gregorian datetimes.\n\n    Args:\n        tz: Timezone to localize to.\n        ambiguous: How to handle ambiguous times. Defaults to 'raise'.\n        nonexistent: How to handle nonexistent times. Defaults to 'raise'.\n\n    Returns:\n        Series of timezone-aware Gregorian datetimes.\n    \"\"\"\n    self._validate()\n    gregorian = self.to_gregorian()\n    dt_index = pd.DatetimeIndex(pd.to_datetime(gregorian))\n    localized = dt_index.tz_localize(\n        tz, ambiguous=ambiguous, nonexistent=nonexistent\n    )\n    return cast(\n        pd.Series,\n        pd.Series(localized, index=self._obj.index, name=self._obj.name),\n    )\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.dataframe.JalaliDataFrameAccessor","title":"JalaliDataFrameAccessor","text":"<p>Enhanced accessor for Jalali datetime operations on pandas DataFrames.</p> <p>Provides methods for working with Jalali (Persian/Shamsi) dates in pandas DataFrames, including groupby, resample, and column conversion.</p> <p>Attributes:</p> Name Type Description <code>jdate</code> <code>str</code> <p>Name of the detected Jalali date column.</p> <code>columns</code> <code>Index[Any]</code> <p>DataFrame columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import jalali_pandas\n&gt;&gt;&gt; df = pd.DataFrame({\n...     'date': pd.date_range('2023-03-21', periods=5),\n...     'value': [1, 2, 3, 4, 5]\n... })\n&gt;&gt;&gt; df['jdate'] = df['date'].jalali.to_jalali()\n&gt;&gt;&gt; df.jalali.groupby('month').sum()\n</code></pre> Source code in <code>jalali_pandas/accessors/dataframe.py</code> <pre><code>@pd.api.extensions.register_dataframe_accessor(\"jalali\")\nclass JalaliDataFrameAccessor:\n    \"\"\"Enhanced accessor for Jalali datetime operations on pandas DataFrames.\n\n    Provides methods for working with Jalali (Persian/Shamsi) dates in\n    pandas DataFrames, including groupby, resample, and column conversion.\n\n    Attributes:\n        jdate: Name of the detected Jalali date column.\n        columns: DataFrame columns.\n\n    Examples:\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; import jalali_pandas\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     'date': pd.date_range('2023-03-21', periods=5),\n        ...     'value': [1, 2, 3, 4, 5]\n        ... })\n        &gt;&gt;&gt; df['jdate'] = df['date'].jalali.to_jalali()\n        &gt;&gt;&gt; df.jalali.groupby('month').sum()\n    \"\"\"\n\n    TEMP_COLUMNS: list[str] = [\n        \"__year\",\n        \"__month\",\n        \"__quarter\",\n        \"__weekday\",\n        \"__day\",\n        \"__week\",\n        \"__dayofyear\",\n    ]\n\n    def __init__(self, pandas_obj: pd.DataFrame) -&gt; None:\n        \"\"\"Initialize the accessor.\n\n        Args:\n            pandas_obj: A pandas DataFrame containing Jalali datetime data.\n        \"\"\"\n        self._obj: pd.DataFrame = pandas_obj\n        self.columns: pd.Index[Any] = self._obj.columns\n        self.jdate: str = \"jdate\"\n        self._validate()\n\n    def _validate(self) -&gt; None:\n        \"\"\"Check if the DataFrame has a jdatetime column.\n\n        Raises:\n            ValueError: If no jdatetime column is found.\n        \"\"\"\n        for col in self.columns:\n            if len(self._obj) &gt; 0:\n                first_val = self._obj[col].iloc[0]\n                if isinstance(first_val, (jdatetime.date, jdatetime.datetime)):\n                    self.jdate = str(col)\n                    return\n        raise ValueError(\"No jdatetime column found in the dataframe.\")\n\n    def set_date_column(self, column: str) -&gt; JalaliDataFrameAccessor:\n        \"\"\"Set the Jalali date column to use for operations.\n\n        Args:\n            column: Name of the column containing Jalali dates.\n\n        Returns:\n            Self for method chaining.\n\n        Raises:\n            ValueError: If column doesn't exist or doesn't contain jdatetime.\n        \"\"\"\n        if column not in self.columns:\n            raise ValueError(f\"Column '{column}' not found in DataFrame.\")\n\n        if len(self._obj) &gt; 0:\n            first_val = self._obj[column].iloc[0]\n            if not isinstance(first_val, (jdatetime.date, jdatetime.datetime)):\n                raise ValueError(\n                    f\"Column '{column}' does not contain jdatetime objects.\"\n                )\n\n        self.jdate = column\n        return self\n\n    @property\n    def _df(self) -&gt; pd.DataFrame:\n        \"\"\"Generate temp DataFrame with extracted date components.\n\n        Returns:\n            DataFrame with year, month, day, quarter, weekday columns.\n        \"\"\"\n        df = self._obj.copy()\n        df[\"__year\"] = df[self.jdate].jalali.year\n        df[\"__month\"] = df[self.jdate].jalali.month\n        df[\"__day\"] = df[self.jdate].jalali.day\n        df[\"__quarter\"] = df[self.jdate].jalali.quarter\n        df[\"__weekday\"] = df[self.jdate].jalali.weekday\n        df[\"__week\"] = df[self.jdate].jalali.week\n        df[\"__dayofyear\"] = df[self.jdate].jalali.dayofyear\n        return df\n\n    def _clean_groupby(self, group: DataFrameGroupByT) -&gt; DataFrameGroupByT:\n        \"\"\"Clean the groupby object by removing temp columns.\n\n        Args:\n            group: The groupby object to clean.\n\n        Returns:\n            Cleaned groupby object with only original columns.\n        \"\"\"\n        numeric_columns: pd.Index[Any] = cast(\n            pd.DataFrame, self._obj.select_dtypes(include=\"number\")\n        ).columns\n        remaining_columns = [\n            col\n            for col in numeric_columns\n            if col in set(self.columns).difference(self.TEMP_COLUMNS)\n        ]\n        if not remaining_columns:\n            return group\n        return cast(DataFrameGroupByT, group[remaining_columns])\n\n    def groupby(self, grouper: str = \"md\") -&gt; DataFrameGroupByT:\n        \"\"\"Group by Jalali date components.\n\n        Args:\n            grouper: Grouping key. Options:\n                - 'year': Group by year\n                - 'month': Group by month\n                - 'day': Group by day\n                - 'week': Group by week number\n                - 'dayofweek': Group by day of week\n                - 'dayofmonth': Group by day of month (alias for 'day')\n                - 'quarter': Group by quarter\n                - 'dayofyear': Group by day of year\n                - 'ym': Group by year and month\n                - 'yq': Group by year and quarter\n                - 'ymd': Group by year, month, and day\n                - 'md': Group by month and day (default)\n\n        Returns:\n            DataFrameGroupBy object.\n\n        Raises:\n            ValueError: If grouper is not a valid option.\n        \"\"\"\n        possible_keys = [\n            \"year\",\n            \"month\",\n            \"day\",\n            \"week\",\n            \"dayofweek\",\n            \"dayofmonth\",\n            \"quarter\",\n            \"dayofyear\",\n            \"ym\",\n            \"yq\",\n            \"ymd\",\n            \"md\",\n        ]\n        df = self._df\n        if grouper not in possible_keys:\n            raise ValueError(\n                f\"{grouper} is not a valid groupby type. Choose from {possible_keys}\"\n            )\n\n        keys: dict[str, list[str]] = {\n            \"md\": [\"month\", \"day\"],\n            \"ym\": [\"year\", \"month\"],\n            \"yq\": [\"year\", \"quarter\"],\n            \"ymd\": [\"year\", \"month\", \"day\"],\n        }\n        grouper_cols: list[str]\n        if grouper in keys:\n            grouper_cols = [f\"__{g}\" for g in keys[grouper]]\n        elif grouper == \"dayofmonth\":\n            grouper_cols = [\"__day\"]\n        else:\n            grouper_cols = [f\"__{grouper}\"]\n\n        group = cast(DataFrameGroupByT, df.groupby(grouper_cols))\n        return self._clean_groupby(group)\n\n    def resample(self, resample_type: str) -&gt; pd.DataFrame:\n        \"\"\"Resample by Jalali frequency.\n\n        Groups the DataFrame by Jalali calendar periods and aggregates.\n\n        Args:\n            resample_type: The resample frequency. Options:\n                - 'month': Group by Jalali month\n                - 'quarter': Group by Jalali quarter\n                - 'year': Group by Jalali year\n                - 'week': Group by Jalali week\n\n        Returns:\n            DataFrame with aggregated values grouped by the specified period.\n\n        Raises:\n            ValueError: If resample_type is not valid.\n\n        Examples:\n            &gt;&gt;&gt; df.jalali.resample('month')\n            &gt;&gt;&gt; df.jalali.resample('quarter')\n        \"\"\"\n        valid_types = [\"month\", \"quarter\", \"year\", \"week\"]\n        if resample_type not in valid_types:\n            raise ValueError(\n                f\"{resample_type} is not a valid resample type. \"\n                f\"Choose from {valid_types}\"\n            )\n\n        type_to_groupby: dict[str, str] = {\n            \"month\": \"ym\",\n            \"quarter\": \"yq\",\n            \"year\": \"year\",\n            \"week\": \"week\",\n        }\n\n        groupby_key = type_to_groupby[resample_type]\n        return self.groupby(groupby_key).sum(numeric_only=True).reset_index(drop=True)\n\n    def convert_columns(\n        self,\n        columns: list[str] | str,\n        to_jalali: bool = True,\n        format: str = \"%Y-%m-%d\",\n    ) -&gt; pd.DataFrame:\n        \"\"\"Convert date columns between Jalali and Gregorian.\n\n        Args:\n            columns: Column name(s) to convert.\n            to_jalali: If True, convert Gregorian to Jalali.\n                If False, convert Jalali to Gregorian. Defaults to True.\n            format: Format string for parsing string dates. Defaults to \"%Y-%m-%d\".\n\n        Returns:\n            DataFrame with converted columns.\n\n        Examples:\n            &gt;&gt;&gt; df.jalali.convert_columns('date', to_jalali=True)\n            &gt;&gt;&gt; df.jalali.convert_columns(['date1', 'date2'], to_jalali=False)\n        \"\"\"\n        df = self._obj.copy()\n\n        if isinstance(columns, str):\n            columns = [columns]\n\n        for col in columns:\n            if col not in df.columns:\n                raise ValueError(f\"Column '{col}' not found in DataFrame.\")\n\n            if to_jalali:\n                df[col] = df[col].jalali.to_jalali()\n            else:\n                if df[col].dtype == object:\n                    first_val = (\n                        df[col].dropna().iloc[0] if len(df[col].dropna()) &gt; 0 else None\n                    )\n                    if isinstance(first_val, str):\n                        df[col] = df[col].jalali.parse_jalali(format)\n                df[col] = df[col].jalali.to_gregorian()\n\n        return df\n\n    def to_period(self, freq: str = \"M\") -&gt; pd.DataFrame:\n        \"\"\"Convert Jalali dates to period representation.\n\n        Args:\n            freq: Frequency for period. Options:\n                - 'Y': Year\n                - 'Q': Quarter\n                - 'M': Month (default)\n                - 'W': Week\n                - 'D': Day\n\n        Returns:\n            DataFrame with period column added.\n        \"\"\"\n        df = self._obj.copy()\n\n        def get_period(x: Any) -&gt; str | None:\n            if pd.isna(x):\n                return None\n            if freq == \"Y\":\n                return f\"{x.year}\"\n            elif freq == \"Q\":\n                q = (x.month - 1) // 3 + 1\n                return f\"{x.year}Q{q}\"\n            elif freq == \"M\":\n                return f\"{x.year}-{x.month:02d}\"\n            elif freq == \"W\":\n                from jalali_pandas.core.calendar import week_of_year\n\n                w = week_of_year(x.year, x.month, x.day)\n                return f\"{x.year}W{w:02d}\"\n            elif freq == \"D\":\n                return f\"{x.year}-{x.month:02d}-{x.day:02d}\"\n            else:\n                raise ValueError(f\"Unsupported frequency: {freq}\")\n\n        df[f\"{self.jdate}_period\"] = df[self.jdate].apply(get_period)\n        return df\n\n    def filter_by_year(self, year: int | list[int]) -&gt; pd.DataFrame:\n        \"\"\"Filter DataFrame by Jalali year(s).\n\n        Args:\n            year: Year or list of years to filter by.\n\n        Returns:\n            Filtered DataFrame.\n        \"\"\"\n        years = [year] if isinstance(year, int) else year\n        mask = self._obj[self.jdate].jalali.year.isin(years)\n        return cast(pd.DataFrame, self._obj[mask].copy())\n\n    def filter_by_month(self, month: int | list[int]) -&gt; pd.DataFrame:\n        \"\"\"Filter DataFrame by Jalali month(s).\n\n        Args:\n            month: Month or list of months to filter by (1-12).\n\n        Returns:\n            Filtered DataFrame.\n        \"\"\"\n        months = [month] if isinstance(month, int) else month\n        mask = self._obj[self.jdate].jalali.month.isin(months)\n        return cast(pd.DataFrame, self._obj[mask].copy())\n\n    def filter_by_quarter(self, quarter: int | list[int]) -&gt; pd.DataFrame:\n        \"\"\"Filter DataFrame by Jalali quarter(s).\n\n        Args:\n            quarter: Quarter or list of quarters to filter by (1-4).\n\n        Returns:\n            Filtered DataFrame.\n        \"\"\"\n        quarters = [quarter] if isinstance(quarter, int) else quarter\n        mask = self._obj[self.jdate].jalali.quarter.isin(quarters)\n        return cast(pd.DataFrame, self._obj[mask].copy())\n\n    def filter_by_date_range(\n        self,\n        start: str | jdatetime.date | None = None,\n        end: str | jdatetime.date | None = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"Filter DataFrame by Jalali date range.\n\n        Args:\n            start: Start date (inclusive). Can be string 'YYYY-MM-DD' or jdatetime.\n            end: End date (inclusive). Can be string 'YYYY-MM-DD' or jdatetime.\n\n        Returns:\n            Filtered DataFrame.\n        \"\"\"\n        df = self._obj.copy()\n        mask = pd.Series([True] * len(df), index=df.index)\n\n        if start is not None:\n            if isinstance(start, str):\n                start = jdatetime.datetime.strptime(start, \"%Y-%m-%d\")\n            mask = mask &amp; (df[self.jdate] &gt;= start)\n\n        if end is not None:\n            if isinstance(end, str):\n                end = jdatetime.datetime.strptime(end, \"%Y-%m-%d\")\n            mask = mask &amp; (df[self.jdate] &lt;= end)\n\n        return cast(pd.DataFrame, df[mask].copy())\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.dataframe.JalaliDataFrameAccessor.__init__","title":"__init__","text":"<pre><code>__init__(pandas_obj: DataFrame) -&gt; None\n</code></pre> <p>Initialize the accessor.</p> <p>Parameters:</p> Name Type Description Default <code>pandas_obj</code> <code>DataFrame</code> <p>A pandas DataFrame containing Jalali datetime data.</p> required Source code in <code>jalali_pandas/accessors/dataframe.py</code> <pre><code>def __init__(self, pandas_obj: pd.DataFrame) -&gt; None:\n    \"\"\"Initialize the accessor.\n\n    Args:\n        pandas_obj: A pandas DataFrame containing Jalali datetime data.\n    \"\"\"\n    self._obj: pd.DataFrame = pandas_obj\n    self.columns: pd.Index[Any] = self._obj.columns\n    self.jdate: str = \"jdate\"\n    self._validate()\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.dataframe.JalaliDataFrameAccessor.convert_columns","title":"convert_columns","text":"<pre><code>convert_columns(columns: list[str] | str, to_jalali: bool = True, format: str = '%Y-%m-%d') -&gt; pd.DataFrame\n</code></pre> <p>Convert date columns between Jalali and Gregorian.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>list[str] | str</code> <p>Column name(s) to convert.</p> required <code>to_jalali</code> <code>bool</code> <p>If True, convert Gregorian to Jalali. If False, convert Jalali to Gregorian. Defaults to True.</p> <code>True</code> <code>format</code> <code>str</code> <p>Format string for parsing string dates. Defaults to \"%Y-%m-%d\".</p> <code>'%Y-%m-%d'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with converted columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df.jalali.convert_columns('date', to_jalali=True)\n&gt;&gt;&gt; df.jalali.convert_columns(['date1', 'date2'], to_jalali=False)\n</code></pre> Source code in <code>jalali_pandas/accessors/dataframe.py</code> <pre><code>def convert_columns(\n    self,\n    columns: list[str] | str,\n    to_jalali: bool = True,\n    format: str = \"%Y-%m-%d\",\n) -&gt; pd.DataFrame:\n    \"\"\"Convert date columns between Jalali and Gregorian.\n\n    Args:\n        columns: Column name(s) to convert.\n        to_jalali: If True, convert Gregorian to Jalali.\n            If False, convert Jalali to Gregorian. Defaults to True.\n        format: Format string for parsing string dates. Defaults to \"%Y-%m-%d\".\n\n    Returns:\n        DataFrame with converted columns.\n\n    Examples:\n        &gt;&gt;&gt; df.jalali.convert_columns('date', to_jalali=True)\n        &gt;&gt;&gt; df.jalali.convert_columns(['date1', 'date2'], to_jalali=False)\n    \"\"\"\n    df = self._obj.copy()\n\n    if isinstance(columns, str):\n        columns = [columns]\n\n    for col in columns:\n        if col not in df.columns:\n            raise ValueError(f\"Column '{col}' not found in DataFrame.\")\n\n        if to_jalali:\n            df[col] = df[col].jalali.to_jalali()\n        else:\n            if df[col].dtype == object:\n                first_val = (\n                    df[col].dropna().iloc[0] if len(df[col].dropna()) &gt; 0 else None\n                )\n                if isinstance(first_val, str):\n                    df[col] = df[col].jalali.parse_jalali(format)\n            df[col] = df[col].jalali.to_gregorian()\n\n    return df\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.dataframe.JalaliDataFrameAccessor.filter_by_date_range","title":"filter_by_date_range","text":"<pre><code>filter_by_date_range(start: str | date | None = None, end: str | date | None = None) -&gt; pd.DataFrame\n</code></pre> <p>Filter DataFrame by Jalali date range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str | date | None</code> <p>Start date (inclusive). Can be string 'YYYY-MM-DD' or jdatetime.</p> <code>None</code> <code>end</code> <code>str | date | None</code> <p>End date (inclusive). Can be string 'YYYY-MM-DD' or jdatetime.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Filtered DataFrame.</p> Source code in <code>jalali_pandas/accessors/dataframe.py</code> <pre><code>def filter_by_date_range(\n    self,\n    start: str | jdatetime.date | None = None,\n    end: str | jdatetime.date | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"Filter DataFrame by Jalali date range.\n\n    Args:\n        start: Start date (inclusive). Can be string 'YYYY-MM-DD' or jdatetime.\n        end: End date (inclusive). Can be string 'YYYY-MM-DD' or jdatetime.\n\n    Returns:\n        Filtered DataFrame.\n    \"\"\"\n    df = self._obj.copy()\n    mask = pd.Series([True] * len(df), index=df.index)\n\n    if start is not None:\n        if isinstance(start, str):\n            start = jdatetime.datetime.strptime(start, \"%Y-%m-%d\")\n        mask = mask &amp; (df[self.jdate] &gt;= start)\n\n    if end is not None:\n        if isinstance(end, str):\n            end = jdatetime.datetime.strptime(end, \"%Y-%m-%d\")\n        mask = mask &amp; (df[self.jdate] &lt;= end)\n\n    return cast(pd.DataFrame, df[mask].copy())\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.dataframe.JalaliDataFrameAccessor.filter_by_month","title":"filter_by_month","text":"<pre><code>filter_by_month(month: int | list[int]) -&gt; pd.DataFrame\n</code></pre> <p>Filter DataFrame by Jalali month(s).</p> <p>Parameters:</p> Name Type Description Default <code>month</code> <code>int | list[int]</code> <p>Month or list of months to filter by (1-12).</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Filtered DataFrame.</p> Source code in <code>jalali_pandas/accessors/dataframe.py</code> <pre><code>def filter_by_month(self, month: int | list[int]) -&gt; pd.DataFrame:\n    \"\"\"Filter DataFrame by Jalali month(s).\n\n    Args:\n        month: Month or list of months to filter by (1-12).\n\n    Returns:\n        Filtered DataFrame.\n    \"\"\"\n    months = [month] if isinstance(month, int) else month\n    mask = self._obj[self.jdate].jalali.month.isin(months)\n    return cast(pd.DataFrame, self._obj[mask].copy())\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.dataframe.JalaliDataFrameAccessor.filter_by_quarter","title":"filter_by_quarter","text":"<pre><code>filter_by_quarter(quarter: int | list[int]) -&gt; pd.DataFrame\n</code></pre> <p>Filter DataFrame by Jalali quarter(s).</p> <p>Parameters:</p> Name Type Description Default <code>quarter</code> <code>int | list[int]</code> <p>Quarter or list of quarters to filter by (1-4).</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Filtered DataFrame.</p> Source code in <code>jalali_pandas/accessors/dataframe.py</code> <pre><code>def filter_by_quarter(self, quarter: int | list[int]) -&gt; pd.DataFrame:\n    \"\"\"Filter DataFrame by Jalali quarter(s).\n\n    Args:\n        quarter: Quarter or list of quarters to filter by (1-4).\n\n    Returns:\n        Filtered DataFrame.\n    \"\"\"\n    quarters = [quarter] if isinstance(quarter, int) else quarter\n    mask = self._obj[self.jdate].jalali.quarter.isin(quarters)\n    return cast(pd.DataFrame, self._obj[mask].copy())\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.dataframe.JalaliDataFrameAccessor.filter_by_year","title":"filter_by_year","text":"<pre><code>filter_by_year(year: int | list[int]) -&gt; pd.DataFrame\n</code></pre> <p>Filter DataFrame by Jalali year(s).</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int | list[int]</code> <p>Year or list of years to filter by.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Filtered DataFrame.</p> Source code in <code>jalali_pandas/accessors/dataframe.py</code> <pre><code>def filter_by_year(self, year: int | list[int]) -&gt; pd.DataFrame:\n    \"\"\"Filter DataFrame by Jalali year(s).\n\n    Args:\n        year: Year or list of years to filter by.\n\n    Returns:\n        Filtered DataFrame.\n    \"\"\"\n    years = [year] if isinstance(year, int) else year\n    mask = self._obj[self.jdate].jalali.year.isin(years)\n    return cast(pd.DataFrame, self._obj[mask].copy())\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.dataframe.JalaliDataFrameAccessor.groupby","title":"groupby","text":"<pre><code>groupby(grouper: str = 'md') -&gt; DataFrameGroupByT\n</code></pre> <p>Group by Jalali date components.</p> <p>Parameters:</p> Name Type Description Default <code>grouper</code> <code>str</code> <p>Grouping key. Options: - 'year': Group by year - 'month': Group by month - 'day': Group by day - 'week': Group by week number - 'dayofweek': Group by day of week - 'dayofmonth': Group by day of month (alias for 'day') - 'quarter': Group by quarter - 'dayofyear': Group by day of year - 'ym': Group by year and month - 'yq': Group by year and quarter - 'ymd': Group by year, month, and day - 'md': Group by month and day (default)</p> <code>'md'</code> <p>Returns:</p> Type Description <code>DataFrameGroupByT</code> <p>DataFrameGroupBy object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If grouper is not a valid option.</p> Source code in <code>jalali_pandas/accessors/dataframe.py</code> <pre><code>def groupby(self, grouper: str = \"md\") -&gt; DataFrameGroupByT:\n    \"\"\"Group by Jalali date components.\n\n    Args:\n        grouper: Grouping key. Options:\n            - 'year': Group by year\n            - 'month': Group by month\n            - 'day': Group by day\n            - 'week': Group by week number\n            - 'dayofweek': Group by day of week\n            - 'dayofmonth': Group by day of month (alias for 'day')\n            - 'quarter': Group by quarter\n            - 'dayofyear': Group by day of year\n            - 'ym': Group by year and month\n            - 'yq': Group by year and quarter\n            - 'ymd': Group by year, month, and day\n            - 'md': Group by month and day (default)\n\n    Returns:\n        DataFrameGroupBy object.\n\n    Raises:\n        ValueError: If grouper is not a valid option.\n    \"\"\"\n    possible_keys = [\n        \"year\",\n        \"month\",\n        \"day\",\n        \"week\",\n        \"dayofweek\",\n        \"dayofmonth\",\n        \"quarter\",\n        \"dayofyear\",\n        \"ym\",\n        \"yq\",\n        \"ymd\",\n        \"md\",\n    ]\n    df = self._df\n    if grouper not in possible_keys:\n        raise ValueError(\n            f\"{grouper} is not a valid groupby type. Choose from {possible_keys}\"\n        )\n\n    keys: dict[str, list[str]] = {\n        \"md\": [\"month\", \"day\"],\n        \"ym\": [\"year\", \"month\"],\n        \"yq\": [\"year\", \"quarter\"],\n        \"ymd\": [\"year\", \"month\", \"day\"],\n    }\n    grouper_cols: list[str]\n    if grouper in keys:\n        grouper_cols = [f\"__{g}\" for g in keys[grouper]]\n    elif grouper == \"dayofmonth\":\n        grouper_cols = [\"__day\"]\n    else:\n        grouper_cols = [f\"__{grouper}\"]\n\n    group = cast(DataFrameGroupByT, df.groupby(grouper_cols))\n    return self._clean_groupby(group)\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.dataframe.JalaliDataFrameAccessor.resample","title":"resample","text":"<pre><code>resample(resample_type: str) -&gt; pd.DataFrame\n</code></pre> <p>Resample by Jalali frequency.</p> <p>Groups the DataFrame by Jalali calendar periods and aggregates.</p> <p>Parameters:</p> Name Type Description Default <code>resample_type</code> <code>str</code> <p>The resample frequency. Options: - 'month': Group by Jalali month - 'quarter': Group by Jalali quarter - 'year': Group by Jalali year - 'week': Group by Jalali week</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with aggregated values grouped by the specified period.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If resample_type is not valid.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df.jalali.resample('month')\n&gt;&gt;&gt; df.jalali.resample('quarter')\n</code></pre> Source code in <code>jalali_pandas/accessors/dataframe.py</code> <pre><code>def resample(self, resample_type: str) -&gt; pd.DataFrame:\n    \"\"\"Resample by Jalali frequency.\n\n    Groups the DataFrame by Jalali calendar periods and aggregates.\n\n    Args:\n        resample_type: The resample frequency. Options:\n            - 'month': Group by Jalali month\n            - 'quarter': Group by Jalali quarter\n            - 'year': Group by Jalali year\n            - 'week': Group by Jalali week\n\n    Returns:\n        DataFrame with aggregated values grouped by the specified period.\n\n    Raises:\n        ValueError: If resample_type is not valid.\n\n    Examples:\n        &gt;&gt;&gt; df.jalali.resample('month')\n        &gt;&gt;&gt; df.jalali.resample('quarter')\n    \"\"\"\n    valid_types = [\"month\", \"quarter\", \"year\", \"week\"]\n    if resample_type not in valid_types:\n        raise ValueError(\n            f\"{resample_type} is not a valid resample type. \"\n            f\"Choose from {valid_types}\"\n        )\n\n    type_to_groupby: dict[str, str] = {\n        \"month\": \"ym\",\n        \"quarter\": \"yq\",\n        \"year\": \"year\",\n        \"week\": \"week\",\n    }\n\n    groupby_key = type_to_groupby[resample_type]\n    return self.groupby(groupby_key).sum(numeric_only=True).reset_index(drop=True)\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.dataframe.JalaliDataFrameAccessor.set_date_column","title":"set_date_column","text":"<pre><code>set_date_column(column: str) -&gt; JalaliDataFrameAccessor\n</code></pre> <p>Set the Jalali date column to use for operations.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>Name of the column containing Jalali dates.</p> required <p>Returns:</p> Type Description <code>JalaliDataFrameAccessor</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If column doesn't exist or doesn't contain jdatetime.</p> Source code in <code>jalali_pandas/accessors/dataframe.py</code> <pre><code>def set_date_column(self, column: str) -&gt; JalaliDataFrameAccessor:\n    \"\"\"Set the Jalali date column to use for operations.\n\n    Args:\n        column: Name of the column containing Jalali dates.\n\n    Returns:\n        Self for method chaining.\n\n    Raises:\n        ValueError: If column doesn't exist or doesn't contain jdatetime.\n    \"\"\"\n    if column not in self.columns:\n        raise ValueError(f\"Column '{column}' not found in DataFrame.\")\n\n    if len(self._obj) &gt; 0:\n        first_val = self._obj[column].iloc[0]\n        if not isinstance(first_val, (jdatetime.date, jdatetime.datetime)):\n            raise ValueError(\n                f\"Column '{column}' does not contain jdatetime objects.\"\n            )\n\n    self.jdate = column\n    return self\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.accessors.dataframe.JalaliDataFrameAccessor.to_period","title":"to_period","text":"<pre><code>to_period(freq: str = 'M') -&gt; pd.DataFrame\n</code></pre> <p>Convert Jalali dates to period representation.</p> <p>Parameters:</p> Name Type Description Default <code>freq</code> <code>str</code> <p>Frequency for period. Options: - 'Y': Year - 'Q': Quarter - 'M': Month (default) - 'W': Week - 'D': Day</p> <code>'M'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with period column added.</p> Source code in <code>jalali_pandas/accessors/dataframe.py</code> <pre><code>def to_period(self, freq: str = \"M\") -&gt; pd.DataFrame:\n    \"\"\"Convert Jalali dates to period representation.\n\n    Args:\n        freq: Frequency for period. Options:\n            - 'Y': Year\n            - 'Q': Quarter\n            - 'M': Month (default)\n            - 'W': Week\n            - 'D': Day\n\n    Returns:\n        DataFrame with period column added.\n    \"\"\"\n    df = self._obj.copy()\n\n    def get_period(x: Any) -&gt; str | None:\n        if pd.isna(x):\n            return None\n        if freq == \"Y\":\n            return f\"{x.year}\"\n        elif freq == \"Q\":\n            q = (x.month - 1) // 3 + 1\n            return f\"{x.year}Q{q}\"\n        elif freq == \"M\":\n            return f\"{x.year}-{x.month:02d}\"\n        elif freq == \"W\":\n            from jalali_pandas.core.calendar import week_of_year\n\n            w = week_of_year(x.year, x.month, x.day)\n            return f\"{x.year}W{w:02d}\"\n        elif freq == \"D\":\n            return f\"{x.year}-{x.month:02d}-{x.day:02d}\"\n        else:\n            raise ValueError(f\"Unsupported frequency: {freq}\")\n\n    df[f\"{self.jdate}_period\"] = df[self.jdate].apply(get_period)\n    return df\n</code></pre>"},{"location":"en/api/accessors/#legacy-accessors","title":"Legacy accessors","text":"<p>Handle Jalali dates in pandas DataFrames.</p> <p>Handle Jalali dates in pandas series.</p>"},{"location":"en/api/accessors/#jalali_pandas.df_handler.JalaliDataframeAccessor","title":"JalaliDataframeAccessor","text":"<p>Accessor methods on pandas DataFrames to handle Jalali dates.</p> Source code in <code>jalali_pandas/df_handler.py</code> <pre><code>class JalaliDataframeAccessor:\n    \"\"\"Accessor methods on pandas DataFrames to handle Jalali dates.\"\"\"\n\n    TEMP_COLUMNS = [\"__year\", \"__month\", \"__quarter\", \"__weekday\", \"__day\"]\n\n    def __init__(self, pandas_obj: pd.DataFrame) -&gt; None:\n        \"\"\"Initialize the accessor.\n\n        Args:\n            pandas_obj: A pandas DataFrame containing Jalali datetime data.\n        \"\"\"\n        self._obj: pd.DataFrame = pandas_obj\n        self.columns: pd.Index[Any] = self._obj.columns\n        self.jdate: str = \"jdate\"\n        self._validate()\n\n    def _validate(self) -&gt; None:\n        \"\"\"Check if the DataFrame has a jdatetime column.\n\n        Raises:\n            ValueError: If no jdatetime column is found.\n        \"\"\"\n        for col in self.columns:\n            if isinstance(self._obj[col].iloc[0], jdatetime.date):\n                self.jdate = str(col)\n                return\n        raise ValueError(\"No jdatetime column found in the dataframe.\")\n\n    @property\n    def _df(self) -&gt; pd.DataFrame:\n        \"\"\"Generate temp DataFrame for groupby.\n\n        Returns:\n            pd.DataFrame: DataFrame with year, month, day, quarter, weekday columns.\n        \"\"\"\n        df = self._obj.copy()\n        df[\"__year\"] = df[self.jdate].jalali.year\n        df[\"__month\"] = df[self.jdate].jalali.month\n        df[\"__day\"] = df[self.jdate].jalali.day\n        df[\"__quarter\"] = df[self.jdate].jalali.quarter\n        df[\"__weekday\"] = df[self.jdate].jalali.weekday\n        return df\n\n    def _clean_groupby(self, group: DataFrameGroupByT) -&gt; DataFrameGroupByT:\n        \"\"\"Clean the groupby object by removing temp columns.\n\n        Args:\n            group: The groupby object to clean.\n\n        Returns:\n            Cleaned groupby object with only original columns.\n        \"\"\"\n        numeric_columns: pd.Index[Any] = cast(\n            pd.DataFrame, self._obj.select_dtypes(include=\"number\")\n        ).columns\n        remaining_columns = [\n            col\n            for col in numeric_columns\n            if col in set(self.columns).difference(self.TEMP_COLUMNS)\n        ]\n        if not remaining_columns:\n            return group\n        return cast(DataFrameGroupByT, group[remaining_columns])\n\n    def groupby(self, grouper: str = \"md\") -&gt; DataFrameGroupByT:\n        \"\"\"Group by Jalali date components.\n\n        Args:\n            grouper: Grouping key. Options: year, month, day, week, dayofweek,\n                dayofmonth, ym, yq, ymd, md. Defaults to 'md'.\n\n        Returns:\n            DataFrameGroupBy object.\n\n        Raises:\n            ValueError: If grouper is not a valid option.\n        \"\"\"\n        possible_keys = [\n            \"year\",\n            \"month\",\n            \"day\",\n            \"week\",\n            \"dayofweek\",\n            \"dayofmonth\",\n            \"ym\",\n            \"yq\",\n            \"ymd\",\n            \"md\",\n        ]\n        df = self._df\n        if grouper not in possible_keys:\n            raise ValueError(\n                f\"{grouper} is not a valid groupby type. Choose from {possible_keys}\"\n            )\n\n        keys: dict[str, list[str]] = {\n            \"md\": [\"month\", \"day\"],\n            \"ym\": [\"year\", \"month\"],\n            \"yq\": [\"year\", \"quarter\"],\n            \"ymd\": [\"year\", \"month\", \"day\"],\n        }\n        grouper_cols: list[str]\n        if grouper in keys:\n            grouper_cols = [f\"__{g}\" for g in keys[grouper]]\n        else:\n            grouper_cols = [f\"__{grouper}\"]\n\n        group = cast(DataFrameGroupByT, df.groupby(grouper_cols))\n        return self._clean_groupby(group)\n\n    def resample(self, resample_type: str) -&gt; pd.DataFrame:\n        \"\"\"Resample by Jalali frequency.\n\n        Groups the DataFrame by Jalali calendar periods and aggregates.\n\n        Args:\n            resample_type: The resample frequency. Options:\n                - 'month': Group by Jalali month\n                - 'quarter': Group by Jalali quarter\n                - 'year': Group by Jalali year\n\n        Returns:\n            DataFrame with aggregated values grouped by the specified period.\n\n        Examples:\n            &gt;&gt;&gt; df.jalali.resample('month')\n            &gt;&gt;&gt; df.jalali.resample('quarter')\n        \"\"\"\n        valid_types = [\"month\", \"quarter\", \"year\"]\n        if resample_type not in valid_types:\n            raise ValueError(\n                f\"{resample_type} is not a valid resample type. \"\n                f\"Choose from {valid_types}\"\n            )\n\n        # Map resample type to groupby key\n        type_to_groupby: dict[str, str] = {\n            \"month\": \"ym\",\n            \"quarter\": \"yq\",\n            \"year\": \"year\",\n        }\n\n        groupby_key = type_to_groupby[resample_type]\n        return self.groupby(groupby_key).sum(numeric_only=True).reset_index(drop=True)\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.df_handler.JalaliDataframeAccessor.__init__","title":"__init__","text":"<pre><code>__init__(pandas_obj: DataFrame) -&gt; None\n</code></pre> <p>Initialize the accessor.</p> <p>Parameters:</p> Name Type Description Default <code>pandas_obj</code> <code>DataFrame</code> <p>A pandas DataFrame containing Jalali datetime data.</p> required Source code in <code>jalali_pandas/df_handler.py</code> <pre><code>def __init__(self, pandas_obj: pd.DataFrame) -&gt; None:\n    \"\"\"Initialize the accessor.\n\n    Args:\n        pandas_obj: A pandas DataFrame containing Jalali datetime data.\n    \"\"\"\n    self._obj: pd.DataFrame = pandas_obj\n    self.columns: pd.Index[Any] = self._obj.columns\n    self.jdate: str = \"jdate\"\n    self._validate()\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.df_handler.JalaliDataframeAccessor.groupby","title":"groupby","text":"<pre><code>groupby(grouper: str = 'md') -&gt; DataFrameGroupByT\n</code></pre> <p>Group by Jalali date components.</p> <p>Parameters:</p> Name Type Description Default <code>grouper</code> <code>str</code> <p>Grouping key. Options: year, month, day, week, dayofweek, dayofmonth, ym, yq, ymd, md. Defaults to 'md'.</p> <code>'md'</code> <p>Returns:</p> Type Description <code>DataFrameGroupByT</code> <p>DataFrameGroupBy object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If grouper is not a valid option.</p> Source code in <code>jalali_pandas/df_handler.py</code> <pre><code>def groupby(self, grouper: str = \"md\") -&gt; DataFrameGroupByT:\n    \"\"\"Group by Jalali date components.\n\n    Args:\n        grouper: Grouping key. Options: year, month, day, week, dayofweek,\n            dayofmonth, ym, yq, ymd, md. Defaults to 'md'.\n\n    Returns:\n        DataFrameGroupBy object.\n\n    Raises:\n        ValueError: If grouper is not a valid option.\n    \"\"\"\n    possible_keys = [\n        \"year\",\n        \"month\",\n        \"day\",\n        \"week\",\n        \"dayofweek\",\n        \"dayofmonth\",\n        \"ym\",\n        \"yq\",\n        \"ymd\",\n        \"md\",\n    ]\n    df = self._df\n    if grouper not in possible_keys:\n        raise ValueError(\n            f\"{grouper} is not a valid groupby type. Choose from {possible_keys}\"\n        )\n\n    keys: dict[str, list[str]] = {\n        \"md\": [\"month\", \"day\"],\n        \"ym\": [\"year\", \"month\"],\n        \"yq\": [\"year\", \"quarter\"],\n        \"ymd\": [\"year\", \"month\", \"day\"],\n    }\n    grouper_cols: list[str]\n    if grouper in keys:\n        grouper_cols = [f\"__{g}\" for g in keys[grouper]]\n    else:\n        grouper_cols = [f\"__{grouper}\"]\n\n    group = cast(DataFrameGroupByT, df.groupby(grouper_cols))\n    return self._clean_groupby(group)\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.df_handler.JalaliDataframeAccessor.resample","title":"resample","text":"<pre><code>resample(resample_type: str) -&gt; pd.DataFrame\n</code></pre> <p>Resample by Jalali frequency.</p> <p>Groups the DataFrame by Jalali calendar periods and aggregates.</p> <p>Parameters:</p> Name Type Description Default <code>resample_type</code> <code>str</code> <p>The resample frequency. Options: - 'month': Group by Jalali month - 'quarter': Group by Jalali quarter - 'year': Group by Jalali year</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with aggregated values grouped by the specified period.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df.jalali.resample('month')\n&gt;&gt;&gt; df.jalali.resample('quarter')\n</code></pre> Source code in <code>jalali_pandas/df_handler.py</code> <pre><code>def resample(self, resample_type: str) -&gt; pd.DataFrame:\n    \"\"\"Resample by Jalali frequency.\n\n    Groups the DataFrame by Jalali calendar periods and aggregates.\n\n    Args:\n        resample_type: The resample frequency. Options:\n            - 'month': Group by Jalali month\n            - 'quarter': Group by Jalali quarter\n            - 'year': Group by Jalali year\n\n    Returns:\n        DataFrame with aggregated values grouped by the specified period.\n\n    Examples:\n        &gt;&gt;&gt; df.jalali.resample('month')\n        &gt;&gt;&gt; df.jalali.resample('quarter')\n    \"\"\"\n    valid_types = [\"month\", \"quarter\", \"year\"]\n    if resample_type not in valid_types:\n        raise ValueError(\n            f\"{resample_type} is not a valid resample type. \"\n            f\"Choose from {valid_types}\"\n        )\n\n    # Map resample type to groupby key\n    type_to_groupby: dict[str, str] = {\n        \"month\": \"ym\",\n        \"quarter\": \"yq\",\n        \"year\": \"year\",\n    }\n\n    groupby_key = type_to_groupby[resample_type]\n    return self.groupby(groupby_key).sum(numeric_only=True).reset_index(drop=True)\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.serie_handler.JalaliSerieAccessor","title":"JalaliSerieAccessor","text":"<p>Accessor methods on pandas series to handle Jalali dates.</p> Source code in <code>jalali_pandas/serie_handler.py</code> <pre><code>class JalaliSerieAccessor:\n    \"\"\"Accessor methods on pandas series to handle Jalali dates.\"\"\"\n\n    def __init__(self, pandas_obj: pd.Series[Any]) -&gt; None:\n        \"\"\"Initialize the accessor.\n\n        Args:\n            pandas_obj: A pandas Series containing datetime data.\n        \"\"\"\n        self._obj = pandas_obj\n\n    def _validate(self) -&gt; None:\n        \"\"\"Validate pandas series contains jdatetime objects.\n\n        Raises:\n            TypeError: If series doesn't contain jdatetime or string dates.\n        \"\"\"\n        if not all(isinstance(x, (str, jdatetime.date)) for x in self._obj):\n            raise TypeError(\"pandas series must be jdatetime or string of jdate\")\n\n    def to_jalali(self) -&gt; pd.Series[Any]:\n        \"\"\"convert python datetime to jalali datetime.\n\n        Returns:\n            pd.Series:  pd.Series of jalali datetime.\n        \"\"\"\n        return cast(\n            pd.Series,\n            self._obj.apply(lambda x: jdatetime.datetime.fromgregorian(date=x)),\n        )\n\n    def to_gregorian(self) -&gt; pd.Series[Any]:\n        \"\"\"convert jalali datetime to python default datetime.\n\n        Returns:\n            pd.Series: pd.Series of python datetime.\n        \"\"\"\n\n        return cast(pd.Series, self._obj.apply(jdatetime.datetime.togregorian))\n\n    #  pylint: disable=redefined-builtin\n    def parse_jalali(self, format: str = \"%Y-%m-%d\") -&gt; pd.Series[Any]:\n        \"\"\"[summary]\n\n        Args:\n            format (str, optional): like gregorian datetime format. Defaults to \"%Y-%m-%d\".\n\n        Returns:\n            pd.Series: pd.Series of jalali datetime.\n        \"\"\"\n        return cast(\n            pd.Series, self._obj.apply(lambda x: jdatetime.datetime.strptime(x, format))\n        )\n\n    @property\n    def year(self) -&gt; pd.Series[Any]:\n        \"\"\"get Jalali year\n\n        Returns:\n            pd.Series: Jalali year\n        \"\"\"\n        self._validate()\n        return cast(pd.Series, self._obj.apply(lambda x: x.year))\n\n    @property\n    def month(self) -&gt; pd.Series[Any]:\n        \"\"\"get Jalali\n\n\n        Returns:\n            pd.Series: Jalali month\n        \"\"\"\n        self._validate()\n        return cast(pd.Series, self._obj.apply(lambda x: x.month))\n\n    @property\n    def day(self) -&gt; pd.Series[Any]:\n        \"\"\"get Jalali day\n\n        Returns:\n            pd.Series: Jalali day\n        \"\"\"\n        self._validate()\n        return cast(pd.Series, self._obj.apply(lambda x: x.day))\n\n    @property\n    def hour(self) -&gt; pd.Series[Any]:\n        \"\"\"get Jalali hour\n\n        Returns:\n            pd.Series: Jalali hour\n        \"\"\"\n        self._validate()\n        return cast(pd.Series, self._obj.apply(lambda x: x.hour))\n\n    @property\n    def minute(self) -&gt; pd.Series[Any]:\n        \"\"\"get Jalali minute\n\n        Returns:\n            pd.Series: Jalali minute\n        \"\"\"\n        self._validate()\n        return cast(pd.Series, self._obj.apply(lambda x: x.minute))\n\n    @property\n    def second(self) -&gt; pd.Series[Any]:\n        \"\"\"get Jalali second\n\n        Returns:\n            pd.Series: Jalali second\n        \"\"\"\n        self._validate()\n        return cast(pd.Series, self._obj.apply(lambda x: x.second))\n\n    @property\n    def weekday(self) -&gt; pd.Series[Any]:\n        \"\"\"get Jalali weekday\n\n        Returns:\n            pd.Series: Jalali weekday\n        \"\"\"\n        self._validate()\n        return cast(pd.Series, self._obj.apply(lambda x: x.weekday()))\n\n    @property\n    def weeknumber(self) -&gt; pd.Series[Any]:\n        \"\"\"get Jalali day of year\n\n        Returns:\n            pd.Series: Jalali day of year\n        \"\"\"\n        self._validate()\n        return cast(pd.Series, self._obj.apply(lambda x: x.weeknumber()))\n\n    @property\n    def quarter(self) -&gt; pd.Series[Any]:\n        \"\"\"Get Jalali quarter.\n\n        Returns:\n            pd.Series: Jalali quarter (1-4).\n        \"\"\"\n        self._validate()\n        month = self.month\n        return cast(pd.Series, month.apply(lambda x: (x - 1) // 3 + 1))\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.serie_handler.JalaliSerieAccessor.day","title":"day  <code>property</code>","text":"<pre><code>day: Series[Any]\n</code></pre> <p>get Jalali day</p> <p>Returns:</p> Type Description <code>Series[Any]</code> <p>pd.Series: Jalali day</p>"},{"location":"en/api/accessors/#jalali_pandas.serie_handler.JalaliSerieAccessor.hour","title":"hour  <code>property</code>","text":"<pre><code>hour: Series[Any]\n</code></pre> <p>get Jalali hour</p> <p>Returns:</p> Type Description <code>Series[Any]</code> <p>pd.Series: Jalali hour</p>"},{"location":"en/api/accessors/#jalali_pandas.serie_handler.JalaliSerieAccessor.minute","title":"minute  <code>property</code>","text":"<pre><code>minute: Series[Any]\n</code></pre> <p>get Jalali minute</p> <p>Returns:</p> Type Description <code>Series[Any]</code> <p>pd.Series: Jalali minute</p>"},{"location":"en/api/accessors/#jalali_pandas.serie_handler.JalaliSerieAccessor.month","title":"month  <code>property</code>","text":"<pre><code>month: Series[Any]\n</code></pre> <p>get Jalali</p> <p>Returns:</p> Type Description <code>Series[Any]</code> <p>pd.Series: Jalali month</p>"},{"location":"en/api/accessors/#jalali_pandas.serie_handler.JalaliSerieAccessor.quarter","title":"quarter  <code>property</code>","text":"<pre><code>quarter: Series[Any]\n</code></pre> <p>Get Jalali quarter.</p> <p>Returns:</p> Type Description <code>Series[Any]</code> <p>pd.Series: Jalali quarter (1-4).</p>"},{"location":"en/api/accessors/#jalali_pandas.serie_handler.JalaliSerieAccessor.second","title":"second  <code>property</code>","text":"<pre><code>second: Series[Any]\n</code></pre> <p>get Jalali second</p> <p>Returns:</p> Type Description <code>Series[Any]</code> <p>pd.Series: Jalali second</p>"},{"location":"en/api/accessors/#jalali_pandas.serie_handler.JalaliSerieAccessor.weekday","title":"weekday  <code>property</code>","text":"<pre><code>weekday: Series[Any]\n</code></pre> <p>get Jalali weekday</p> <p>Returns:</p> Type Description <code>Series[Any]</code> <p>pd.Series: Jalali weekday</p>"},{"location":"en/api/accessors/#jalali_pandas.serie_handler.JalaliSerieAccessor.weeknumber","title":"weeknumber  <code>property</code>","text":"<pre><code>weeknumber: Series[Any]\n</code></pre> <p>get Jalali day of year</p> <p>Returns:</p> Type Description <code>Series[Any]</code> <p>pd.Series: Jalali day of year</p>"},{"location":"en/api/accessors/#jalali_pandas.serie_handler.JalaliSerieAccessor.year","title":"year  <code>property</code>","text":"<pre><code>year: Series[Any]\n</code></pre> <p>get Jalali year</p> <p>Returns:</p> Type Description <code>Series[Any]</code> <p>pd.Series: Jalali year</p>"},{"location":"en/api/accessors/#jalali_pandas.serie_handler.JalaliSerieAccessor.__init__","title":"__init__","text":"<pre><code>__init__(pandas_obj: Series[Any]) -&gt; None\n</code></pre> <p>Initialize the accessor.</p> <p>Parameters:</p> Name Type Description Default <code>pandas_obj</code> <code>Series[Any]</code> <p>A pandas Series containing datetime data.</p> required Source code in <code>jalali_pandas/serie_handler.py</code> <pre><code>def __init__(self, pandas_obj: pd.Series[Any]) -&gt; None:\n    \"\"\"Initialize the accessor.\n\n    Args:\n        pandas_obj: A pandas Series containing datetime data.\n    \"\"\"\n    self._obj = pandas_obj\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.serie_handler.JalaliSerieAccessor.parse_jalali","title":"parse_jalali","text":"<pre><code>parse_jalali(format: str = '%Y-%m-%d') -&gt; pd.Series[Any]\n</code></pre> <p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>str</code> <p>like gregorian datetime format. Defaults to \"%Y-%m-%d\".</p> <code>'%Y-%m-%d'</code> <p>Returns:</p> Type Description <code>Series[Any]</code> <p>pd.Series: pd.Series of jalali datetime.</p> Source code in <code>jalali_pandas/serie_handler.py</code> <pre><code>def parse_jalali(self, format: str = \"%Y-%m-%d\") -&gt; pd.Series[Any]:\n    \"\"\"[summary]\n\n    Args:\n        format (str, optional): like gregorian datetime format. Defaults to \"%Y-%m-%d\".\n\n    Returns:\n        pd.Series: pd.Series of jalali datetime.\n    \"\"\"\n    return cast(\n        pd.Series, self._obj.apply(lambda x: jdatetime.datetime.strptime(x, format))\n    )\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.serie_handler.JalaliSerieAccessor.to_gregorian","title":"to_gregorian","text":"<pre><code>to_gregorian() -&gt; pd.Series[Any]\n</code></pre> <p>convert jalali datetime to python default datetime.</p> <p>Returns:</p> Type Description <code>Series[Any]</code> <p>pd.Series: pd.Series of python datetime.</p> Source code in <code>jalali_pandas/serie_handler.py</code> <pre><code>def to_gregorian(self) -&gt; pd.Series[Any]:\n    \"\"\"convert jalali datetime to python default datetime.\n\n    Returns:\n        pd.Series: pd.Series of python datetime.\n    \"\"\"\n\n    return cast(pd.Series, self._obj.apply(jdatetime.datetime.togregorian))\n</code></pre>"},{"location":"en/api/accessors/#jalali_pandas.serie_handler.JalaliSerieAccessor.to_jalali","title":"to_jalali","text":"<pre><code>to_jalali() -&gt; pd.Series[Any]\n</code></pre> <p>convert python datetime to jalali datetime.</p> <p>Returns:</p> Type Description <code>Series[Any]</code> <p>pd.Series:  pd.Series of jalali datetime.</p> Source code in <code>jalali_pandas/serie_handler.py</code> <pre><code>def to_jalali(self) -&gt; pd.Series[Any]:\n    \"\"\"convert python datetime to jalali datetime.\n\n    Returns:\n        pd.Series:  pd.Series of jalali datetime.\n    \"\"\"\n    return cast(\n        pd.Series,\n        self._obj.apply(lambda x: jdatetime.datetime.fromgregorian(date=x)),\n    )\n</code></pre>"},{"location":"en/api/api/","title":"Public API","text":"<p>Conversion functions for Jalali datetime.</p> <p>Date range generation for Jalali calendar.</p> <p>JalaliGrouper - Grouper for Jalali calendar-based grouping.</p> <p>This module provides a Grouper class that enables grouping pandas DataFrames by Jalali calendar periods (month, quarter, year).</p>"},{"location":"en/api/api/#jalali_pandas.api.conversion.to_gregorian_datetime","title":"to_gregorian_datetime","text":"<pre><code>to_gregorian_datetime(arg: JalaliTimestamp | JalaliDatetimeIndex | Series) -&gt; pd.Timestamp | pd.DatetimeIndex | pd.Series\n</code></pre> <p>Convert Jalali datetime to Gregorian datetime.</p> <p>Parameters:</p> Name Type Description Default <code>arg</code> <code>JalaliTimestamp | JalaliDatetimeIndex | Series</code> <p>The Jalali datetime object to convert. Can be: - JalaliTimestamp: Returns pd.Timestamp - JalaliDatetimeIndex: Returns pd.DatetimeIndex - pd.Series with Jalali data: Returns pd.Series with Gregorian data</p> required <p>Returns:</p> Type Description <code>Timestamp | DatetimeIndex | Series</code> <ul> <li>pd.Timestamp for JalaliTimestamp input</li> </ul> <code>Timestamp | DatetimeIndex | Series</code> <ul> <li>pd.DatetimeIndex for JalaliDatetimeIndex input</li> </ul> <code>Timestamp | DatetimeIndex | Series</code> <ul> <li>pd.Series for Series input</li> </ul> <p>Raises:</p> Type Description <code>TypeError</code> <p>If input type is not supported.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ts = JalaliTimestamp(1402, 6, 15)\n&gt;&gt;&gt; to_gregorian_datetime(ts)\nTimestamp('2023-09-06 00:00:00')\n</code></pre> <pre><code>&gt;&gt;&gt; idx = JalaliDatetimeIndex([\"1402-01-01\", \"1402-01-02\"])\n&gt;&gt;&gt; to_gregorian_datetime(idx)\nDatetimeIndex(['2023-03-21', '2023-03-22'], dtype='datetime64[ns]', freq=None)\n</code></pre> Source code in <code>jalali_pandas/api/conversion.py</code> <pre><code>def to_gregorian_datetime(\n    arg: JalaliTimestamp | JalaliDatetimeIndex | pd.Series,\n) -&gt; pd.Timestamp | pd.DatetimeIndex | pd.Series:\n    \"\"\"Convert Jalali datetime to Gregorian datetime.\n\n    Parameters:\n        arg: The Jalali datetime object to convert. Can be:\n            - JalaliTimestamp: Returns pd.Timestamp\n            - JalaliDatetimeIndex: Returns pd.DatetimeIndex\n            - pd.Series with Jalali data: Returns pd.Series with Gregorian data\n\n    Returns:\n        - pd.Timestamp for JalaliTimestamp input\n        - pd.DatetimeIndex for JalaliDatetimeIndex input\n        - pd.Series for Series input\n\n    Raises:\n        TypeError: If input type is not supported.\n\n    Examples:\n        &gt;&gt;&gt; ts = JalaliTimestamp(1402, 6, 15)\n        &gt;&gt;&gt; to_gregorian_datetime(ts)\n        Timestamp('2023-09-06 00:00:00')\n\n        &gt;&gt;&gt; idx = JalaliDatetimeIndex([\"1402-01-01\", \"1402-01-02\"])\n        &gt;&gt;&gt; to_gregorian_datetime(idx)\n        DatetimeIndex(['2023-03-21', '2023-03-22'], dtype='datetime64[ns]', freq=None)\n    \"\"\"\n    if isinstance(arg, JalaliTimestamp):\n        return arg.to_gregorian()\n\n    if isinstance(arg, JalaliDatetimeIndex):\n        return arg.to_gregorian()\n\n    if isinstance(arg, pd.Series):\n        # Check if it's a Jalali series\n        if hasattr(arg.dtype, \"name\") and \"jalali\" in str(arg.dtype.name).lower():\n            greg_vals: list[Any] = []\n            for val in arg:\n                if pd.isna(val):\n                    greg_vals.append(pd.NaT)\n                elif isinstance(val, JalaliTimestamp):\n                    greg_vals.append(val.to_gregorian())\n                else:\n                    greg_vals.append(pd.NaT)\n            return pd.Series(greg_vals, index=arg.index, name=arg.name)\n\n        # Try to convert each element\n        greg_results: list[Any] = []\n        for val in arg:\n            if pd.isna(val):\n                greg_results.append(pd.NaT)\n            elif isinstance(val, JalaliTimestamp):\n                greg_results.append(val.to_gregorian())\n            else:\n                raise TypeError(f\"Cannot convert {type(val)} to Gregorian datetime\")\n        return pd.Series(greg_results, index=arg.index, name=arg.name)\n\n    raise TypeError(f\"Cannot convert {type(arg)} to Gregorian datetime\")\n</code></pre>"},{"location":"en/api/api/#jalali_pandas.api.conversion.to_jalali_datetime","title":"to_jalali_datetime","text":"<pre><code>to_jalali_datetime(arg: str | JalaliTimestamp | datetime | Timestamp | Sequence[str] | DatetimeIndex | Series, format: str | None = None, errors: ErrorsType = 'raise') -&gt; JalaliTimestamp | JalaliDatetimeIndex | pd.Series\n</code></pre> <p>Convert argument to Jalali datetime.</p> <p>This function converts various datetime-like inputs to Jalali datetime objects. It can handle strings, pandas Timestamps, DatetimeIndex, and Series.</p> <p>Parameters:</p> Name Type Description Default <code>arg</code> <code>str | JalaliTimestamp | datetime | Timestamp | Sequence[str] | DatetimeIndex | Series</code> <p>The object to convert. Can be: - str: A date string to parse - JalaliTimestamp: Returned as-is - datetime/pd.Timestamp: Converted from Gregorian - Sequence[str]: List of date strings - pd.DatetimeIndex: Converted from Gregorian - pd.Series: Each element converted</p> required <code>format</code> <code>str | None</code> <p>strftime format string for parsing strings. If None, tries common formats.</p> <code>None</code> <code>errors</code> <code>ErrorsType</code> <p>How to handle errors: - \"raise\": Raise an exception on invalid input - \"coerce\": Set invalid values to NaT - \"ignore\": Return the input unchanged on error</p> <code>'raise'</code> <p>Returns:</p> Type Description <code>JalaliTimestamp | JalaliDatetimeIndex | Series</code> <ul> <li>JalaliTimestamp for scalar inputs</li> </ul> <code>JalaliTimestamp | JalaliDatetimeIndex | Series</code> <ul> <li>JalaliDatetimeIndex for array-like inputs</li> </ul> <code>JalaliTimestamp | JalaliDatetimeIndex | Series</code> <ul> <li>pd.Series for Series inputs</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>If parsing fails and errors=\"raise\".</p> <code>TypeError</code> <p>If input type is not supported.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; to_jalali_datetime(\"1402-06-15\")\nJalaliTimestamp('1402-06-15T00:00:00')\n</code></pre> <pre><code>&gt;&gt;&gt; to_jalali_datetime(pd.Timestamp(\"2023-09-06\"))\nJalaliTimestamp('1402-06-15T00:00:00')\n</code></pre> <pre><code>&gt;&gt;&gt; to_jalali_datetime([\"1402-01-01\", \"1402-01-02\"])\nJalaliDatetimeIndex(['1402-01-01', '1402-01-02'],\n                   dtype='jalali_datetime64[ns]', freq=None)\n</code></pre> Source code in <code>jalali_pandas/api/conversion.py</code> <pre><code>def to_jalali_datetime(\n    arg: str\n    | JalaliTimestamp\n    | datetime\n    | pd.Timestamp\n    | Sequence[str]\n    | pd.DatetimeIndex\n    | pd.Series,\n    format: str | None = None,\n    errors: ErrorsType = \"raise\",\n) -&gt; JalaliTimestamp | JalaliDatetimeIndex | pd.Series:\n    \"\"\"Convert argument to Jalali datetime.\n\n    This function converts various datetime-like inputs to Jalali datetime\n    objects. It can handle strings, pandas Timestamps, DatetimeIndex, and Series.\n\n    Parameters:\n        arg: The object to convert. Can be:\n            - str: A date string to parse\n            - JalaliTimestamp: Returned as-is\n            - datetime/pd.Timestamp: Converted from Gregorian\n            - Sequence[str]: List of date strings\n            - pd.DatetimeIndex: Converted from Gregorian\n            - pd.Series: Each element converted\n        format: strftime format string for parsing strings.\n            If None, tries common formats.\n        errors: How to handle errors:\n            - \"raise\": Raise an exception on invalid input\n            - \"coerce\": Set invalid values to NaT\n            - \"ignore\": Return the input unchanged on error\n\n    Returns:\n        - JalaliTimestamp for scalar inputs\n        - JalaliDatetimeIndex for array-like inputs\n        - pd.Series for Series inputs\n\n    Raises:\n        ValueError: If parsing fails and errors=\"raise\".\n        TypeError: If input type is not supported.\n\n    Examples:\n        &gt;&gt;&gt; to_jalali_datetime(\"1402-06-15\")\n        JalaliTimestamp('1402-06-15T00:00:00')\n\n        &gt;&gt;&gt; to_jalali_datetime(pd.Timestamp(\"2023-09-06\"))\n        JalaliTimestamp('1402-06-15T00:00:00')\n\n        &gt;&gt;&gt; to_jalali_datetime([\"1402-01-01\", \"1402-01-02\"])\n        JalaliDatetimeIndex(['1402-01-01', '1402-01-02'],\n                           dtype='jalali_datetime64[ns]', freq=None)\n    \"\"\"\n    # Handle scalar string\n    if isinstance(arg, str):\n        return _parse_string_scalar(arg, format, errors)\n\n    # Handle JalaliTimestamp (return as-is)\n    if isinstance(arg, JalaliTimestamp):\n        return arg\n\n    # Handle pandas Timestamp\n    if isinstance(arg, pd.Timestamp):\n        return JalaliTimestamp.from_gregorian(arg)\n\n    # Handle datetime\n    from datetime import datetime\n\n    if isinstance(arg, datetime) and not isinstance(arg, pd.Timestamp):\n        return JalaliTimestamp.from_gregorian(pd.Timestamp(arg))\n\n    # Handle Series\n    if isinstance(arg, pd.Series):\n        return _convert_series(arg, format, errors)\n\n    # Handle DatetimeIndex\n    if isinstance(arg, pd.DatetimeIndex):\n        return _convert_datetime_index(arg, errors)\n\n    # Handle sequence (list, tuple, etc.)\n    try:\n        # Try to iterate\n        items = list(arg)  # type: ignore[arg-type]\n        return _convert_sequence(items, format, errors)\n    except TypeError:\n        pass\n\n    raise TypeError(f\"Cannot convert {type(arg)} to Jalali datetime\")\n</code></pre>"},{"location":"en/api/api/#jalali_pandas.api.date_range.jalali_date_range","title":"jalali_date_range","text":"<pre><code>jalali_date_range(start: str | JalaliTimestamp | None = None, end: str | JalaliTimestamp | None = None, periods: int | None = None, freq: str | JalaliOffset | None = None, tz: tzinfo | str | None = None, normalize: bool = False, name: Hashable = None, inclusive: Literal['both', 'neither', 'left', 'right'] = 'both') -&gt; JalaliDatetimeIndex\n</code></pre> <p>Return a fixed frequency JalaliDatetimeIndex.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str | JalaliTimestamp | None</code> <p>Left bound for generating dates.</p> <code>None</code> <code>end</code> <code>str | JalaliTimestamp | None</code> <p>Right bound for generating dates.</p> <code>None</code> <code>periods</code> <code>int | None</code> <p>Number of periods to generate.</p> <code>None</code> <code>freq</code> <code>str | JalaliOffset | None</code> <p>Frequency string or JalaliOffset. Defaults to 'D' (daily).</p> <code>None</code> <code>tz</code> <code>tzinfo | str | None</code> <p>Timezone name for the resulting index.</p> <code>None</code> <code>normalize</code> <code>bool</code> <p>Normalize start/end dates to midnight.</p> <code>False</code> <code>name</code> <code>Hashable</code> <p>Name of the resulting index.</p> <code>None</code> <code>inclusive</code> <code>Literal['both', 'neither', 'left', 'right']</code> <p>Include boundaries; \"both\", \"neither\", \"left\", \"right\".</p> <code>'both'</code> <p>Returns:</p> Type Description <code>JalaliDatetimeIndex</code> <p>JalaliDatetimeIndex with the requested frequency.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If invalid parameter combinations are provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; jalali_date_range(\"1402-01-01\", periods=5, freq=\"D\")\nJalaliDatetimeIndex(['1402-01-01', '1402-01-02', '1402-01-03',\n                    '1402-01-04', '1402-01-05'],\n                   dtype='jalali_datetime64[ns]', freq='D')\n</code></pre> <pre><code>&gt;&gt;&gt; jalali_date_range(\"1402-01-01\", \"1402-03-31\", freq=\"JME\")\nJalaliDatetimeIndex(['1402-01-31', '1402-02-31', '1402-03-31'],\n                   dtype='jalali_datetime64[ns]', freq='JME')\n</code></pre> Source code in <code>jalali_pandas/api/date_range.py</code> <pre><code>def jalali_date_range(\n    start: str | JalaliTimestamp | None = None,\n    end: str | JalaliTimestamp | None = None,\n    periods: int | None = None,\n    freq: str | JalaliOffset | None = None,\n    tz: tzinfo | str | None = None,\n    normalize: bool = False,\n    name: Hashable = None,\n    inclusive: Literal[\"both\", \"neither\", \"left\", \"right\"] = \"both\",\n) -&gt; JalaliDatetimeIndex:\n    \"\"\"Return a fixed frequency JalaliDatetimeIndex.\n\n    Parameters:\n        start: Left bound for generating dates.\n        end: Right bound for generating dates.\n        periods: Number of periods to generate.\n        freq: Frequency string or JalaliOffset. Defaults to 'D' (daily).\n        tz: Timezone name for the resulting index.\n        normalize: Normalize start/end dates to midnight.\n        name: Name of the resulting index.\n        inclusive: Include boundaries; \"both\", \"neither\", \"left\", \"right\".\n\n    Returns:\n        JalaliDatetimeIndex with the requested frequency.\n\n    Raises:\n        ValueError: If invalid parameter combinations are provided.\n\n    Examples:\n        &gt;&gt;&gt; jalali_date_range(\"1402-01-01\", periods=5, freq=\"D\")\n        JalaliDatetimeIndex(['1402-01-01', '1402-01-02', '1402-01-03',\n                            '1402-01-04', '1402-01-05'],\n                           dtype='jalali_datetime64[ns]', freq='D')\n\n        &gt;&gt;&gt; jalali_date_range(\"1402-01-01\", \"1402-03-31\", freq=\"JME\")\n        JalaliDatetimeIndex(['1402-01-31', '1402-02-31', '1402-03-31'],\n                           dtype='jalali_datetime64[ns]', freq='JME')\n    \"\"\"\n    # Validate parameter combinations\n    _validate_params(start, end, periods, freq)\n\n    # Parse start and end\n    start_ts = _parse_timestamp(start) if start is not None else None\n    end_ts = _parse_timestamp(end) if end is not None else None\n\n    # Normalize if requested\n    if normalize:\n        if start_ts is not None:\n            start_ts = start_ts.normalize()\n        if end_ts is not None:\n            end_ts = end_ts.normalize()\n\n    # Default frequency\n    if freq is None:\n        freq = \"D\"\n\n    # Parse frequency string to offset\n    offset = _parse_frequency(freq)\n\n    # Generate the date range\n    dates = _generate_range(start_ts, end_ts, periods, offset, inclusive)\n\n    # Create the index\n    tz_str = str(tz) if tz is not None and not isinstance(tz, str) else tz\n    dtype = JalaliDatetimeDtype(tz=tz_str)\n    array = JalaliDatetimeArray._from_sequence(dates, dtype=dtype)\n\n    freq_str = freq if isinstance(freq, str) else str(offset)\n    return JalaliDatetimeIndex._simple_new(array, name=name, freq=freq_str)\n</code></pre>"},{"location":"en/api/api/#jalali_pandas.api.grouper.JalaliGrouper","title":"JalaliGrouper","text":"<p>Grouper for Jalali calendar-based grouping.</p> <p>This class provides grouping by Jalali calendar periods such as month end (JME), quarter end (JQE), year end (JYE), etc.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str | None</code> <p>Column name containing datetime values to group by.</p> <code>None</code> <code>freq</code> <code>str | JalaliOffset | None</code> <p>Jalali frequency string (e.g., 'JME', 'JQE', 'JYE') or JalaliOffset.</p> <code>None</code> <code>closed</code> <code>str | None</code> <p>Which side of bin interval is closed ('left' or 'right').</p> <code>None</code> <code>label</code> <code>str | None</code> <p>Which bin edge label to use ('left' or 'right').</p> <code>None</code> <code>sort</code> <code>bool</code> <p>Whether to sort the resulting groups.</p> <code>True</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\n...     'date': pd.date_range('2023-03-21', periods=90, freq='D'),\n...     'value': range(90)\n... })\n&gt;&gt;&gt; grouper = JalaliGrouper(key='date', freq='JME')\n&gt;&gt;&gt; df.groupby(grouper.get_grouper(df)).sum()\n</code></pre> Source code in <code>jalali_pandas/api/grouper.py</code> <pre><code>class JalaliGrouper:\n    \"\"\"Grouper for Jalali calendar-based grouping.\n\n    This class provides grouping by Jalali calendar periods such as\n    month end (JME), quarter end (JQE), year end (JYE), etc.\n\n    Parameters:\n        key: Column name containing datetime values to group by.\n        freq: Jalali frequency string (e.g., 'JME', 'JQE', 'JYE') or JalaliOffset.\n        closed: Which side of bin interval is closed ('left' or 'right').\n        label: Which bin edge label to use ('left' or 'right').\n        sort: Whether to sort the resulting groups.\n\n    Examples:\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     'date': pd.date_range('2023-03-21', periods=90, freq='D'),\n        ...     'value': range(90)\n        ... })\n        &gt;&gt;&gt; grouper = JalaliGrouper(key='date', freq='JME')\n        &gt;&gt;&gt; df.groupby(grouper.get_grouper(df)).sum()\n    \"\"\"\n\n    def __init__(\n        self,\n        key: str | None = None,\n        freq: str | JalaliOffset | None = None,\n        closed: str | None = None,\n        label: str | None = None,\n        sort: bool = True,\n    ) -&gt; None:\n        \"\"\"Initialize JalaliGrouper.\n\n        Args:\n            key: Column name containing datetime values.\n            freq: Jalali frequency string or offset.\n            closed: Which side of bin interval is closed.\n            label: Which bin edge label to use.\n            sort: Whether to sort results.\n        \"\"\"\n        self._jalali_freq = freq\n        self._jalali_offset: JalaliOffset | None = None\n        self._closed = closed\n        self._label = label\n        self._sort = sort\n\n        # Parse frequency if string\n        if isinstance(freq, str):\n            with contextlib.suppress(ValueError):\n                self._jalali_offset = parse_jalali_frequency(freq)\n\n        # Store key and sort for our use\n        self._key = key\n        self._sort_groups = sort\n\n    @property\n    def key(self) -&gt; str | None:\n        \"\"\"Return the key column name.\"\"\"\n        return self._key\n\n    def get_grouper(self, obj: pd.DataFrame | pd.Series[Any]) -&gt; pd.Series[Any]:\n        \"\"\"Get the grouper Series for groupby operations.\n\n        Args:\n            obj: DataFrame or Series to group.\n\n        Returns:\n            Series of group labels.\n        \"\"\"\n        # Get the datetime column\n        if self._key is not None:\n            datetime_col = obj[self._key]\n        elif isinstance(obj.index, pd.DatetimeIndex):\n            datetime_col = obj.index.to_series()\n        else:\n            raise ValueError(\n                \"JalaliGrouper requires either a 'key' parameter or a DatetimeIndex\"\n            )\n\n        # Convert to Jalali and compute group labels\n        return self._compute_jalali_groups(datetime_col)\n\n    def _compute_jalali_groups(self, datetime_col: pd.Series[Any]) -&gt; pd.Series[Any]:\n        \"\"\"Compute Jalali-based group labels for datetime values.\n\n        Args:\n            datetime_col: Series of datetime values.\n\n        Returns:\n            Series of group labels (Jalali period boundaries).\n        \"\"\"\n        labels: list[Any] = []\n\n        for dt in datetime_col:\n            if pd.isna(dt):\n                labels.append(pd.NaT)\n                continue\n\n            # Convert to JalaliTimestamp\n            if isinstance(dt, pd.Timestamp):\n                jts = JalaliTimestamp.from_gregorian(dt)\n            elif isinstance(dt, JalaliTimestamp):\n                jts = dt\n            else:\n                # Try to convert\n                jts = JalaliTimestamp.from_gregorian(pd.Timestamp(dt))\n\n            # Get the period boundary using rollforward\n            if self._jalali_offset is not None:\n                boundary = self._jalali_offset.rollforward(jts)\n                # Convert back to Gregorian for grouping\n                labels.append(boundary.to_gregorian())\n            else:\n                labels.append(jts.to_gregorian())\n\n        return pd.Series(labels, index=datetime_col.index)\n</code></pre>"},{"location":"en/api/api/#jalali_pandas.api.grouper.JalaliGrouper.key","title":"key  <code>property</code>","text":"<pre><code>key: str | None\n</code></pre> <p>Return the key column name.</p>"},{"location":"en/api/api/#jalali_pandas.api.grouper.JalaliGrouper.__init__","title":"__init__","text":"<pre><code>__init__(key: str | None = None, freq: str | JalaliOffset | None = None, closed: str | None = None, label: str | None = None, sort: bool = True) -&gt; None\n</code></pre> <p>Initialize JalaliGrouper.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str | None</code> <p>Column name containing datetime values.</p> <code>None</code> <code>freq</code> <code>str | JalaliOffset | None</code> <p>Jalali frequency string or offset.</p> <code>None</code> <code>closed</code> <code>str | None</code> <p>Which side of bin interval is closed.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>Which bin edge label to use.</p> <code>None</code> <code>sort</code> <code>bool</code> <p>Whether to sort results.</p> <code>True</code> Source code in <code>jalali_pandas/api/grouper.py</code> <pre><code>def __init__(\n    self,\n    key: str | None = None,\n    freq: str | JalaliOffset | None = None,\n    closed: str | None = None,\n    label: str | None = None,\n    sort: bool = True,\n) -&gt; None:\n    \"\"\"Initialize JalaliGrouper.\n\n    Args:\n        key: Column name containing datetime values.\n        freq: Jalali frequency string or offset.\n        closed: Which side of bin interval is closed.\n        label: Which bin edge label to use.\n        sort: Whether to sort results.\n    \"\"\"\n    self._jalali_freq = freq\n    self._jalali_offset: JalaliOffset | None = None\n    self._closed = closed\n    self._label = label\n    self._sort = sort\n\n    # Parse frequency if string\n    if isinstance(freq, str):\n        with contextlib.suppress(ValueError):\n            self._jalali_offset = parse_jalali_frequency(freq)\n\n    # Store key and sort for our use\n    self._key = key\n    self._sort_groups = sort\n</code></pre>"},{"location":"en/api/api/#jalali_pandas.api.grouper.JalaliGrouper.get_grouper","title":"get_grouper","text":"<pre><code>get_grouper(obj: DataFrame | Series[Any]) -&gt; pd.Series[Any]\n</code></pre> <p>Get the grouper Series for groupby operations.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>DataFrame | Series[Any]</code> <p>DataFrame or Series to group.</p> required <p>Returns:</p> Type Description <code>Series[Any]</code> <p>Series of group labels.</p> Source code in <code>jalali_pandas/api/grouper.py</code> <pre><code>def get_grouper(self, obj: pd.DataFrame | pd.Series[Any]) -&gt; pd.Series[Any]:\n    \"\"\"Get the grouper Series for groupby operations.\n\n    Args:\n        obj: DataFrame or Series to group.\n\n    Returns:\n        Series of group labels.\n    \"\"\"\n    # Get the datetime column\n    if self._key is not None:\n        datetime_col = obj[self._key]\n    elif isinstance(obj.index, pd.DatetimeIndex):\n        datetime_col = obj.index.to_series()\n    else:\n        raise ValueError(\n            \"JalaliGrouper requires either a 'key' parameter or a DatetimeIndex\"\n        )\n\n    # Convert to Jalali and compute group labels\n    return self._compute_jalali_groups(datetime_col)\n</code></pre>"},{"location":"en/api/api/#jalali_pandas.api.grouper.JalaliResampler","title":"JalaliResampler","text":"<p>Resampler for Jalali calendar-based resampling.</p> <p>This class provides a resampler interface similar to pandas Resampler but uses Jalali calendar boundaries for grouping.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Series[Any] | DataFrame</code> <p>Series or DataFrame to resample.</p> required <code>offset</code> <code>JalaliOffset</code> <p>JalaliOffset for determining period boundaries.</p> required <code>closed</code> <code>Literal['right', 'left'] | None</code> <p>Which side of bin interval is closed.</p> <code>None</code> <code>label</code> <code>Literal['right', 'left'] | None</code> <p>Which bin edge label to use.</p> <code>None</code> Source code in <code>jalali_pandas/api/grouper.py</code> <pre><code>class JalaliResampler:\n    \"\"\"Resampler for Jalali calendar-based resampling.\n\n    This class provides a resampler interface similar to pandas Resampler\n    but uses Jalali calendar boundaries for grouping.\n\n    Parameters:\n        obj: Series or DataFrame to resample.\n        offset: JalaliOffset for determining period boundaries.\n        closed: Which side of bin interval is closed.\n        label: Which bin edge label to use.\n    \"\"\"\n\n    def __init__(\n        self,\n        obj: pd.Series[Any] | pd.DataFrame,\n        offset: JalaliOffset,\n        closed: Literal[\"right\", \"left\"] | None = None,\n        label: Literal[\"right\", \"left\"] | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize JalaliResampler.\"\"\"\n        self._obj = obj\n        self._offset = offset\n        self._closed = closed or \"right\"\n        self._label = label or \"right\"\n        self._groups = self._compute_groups()\n\n    def _compute_groups(self) -&gt; pd.Series[Any]:\n        \"\"\"Compute group labels based on Jalali period boundaries.\"\"\"\n        if isinstance(self._obj.index, pd.DatetimeIndex):\n            index = self._obj.index\n        else:\n            raise ValueError(\"Resampling requires a DatetimeIndex\")\n\n        labels: list[Any] = []\n        for ts in index:\n            if pd.isna(ts):\n                labels.append(pd.NaT)\n                continue\n\n            # Convert to JalaliTimestamp\n            jts = JalaliTimestamp.from_gregorian(ts)\n\n            # Get the period boundary using rollforward\n            boundary = self._offset.rollforward(jts)\n\n            # Convert back to Gregorian for the label\n            labels.append(boundary.to_gregorian())\n\n        return pd.Series(labels, index=index)\n\n    def _apply_agg(self, func: str) -&gt; Any:\n        \"\"\"Apply aggregation function to groups.\"\"\"\n        return getattr(self._obj.groupby(self._groups), func)()\n\n    def sum(self, **kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame:\n        \"\"\"Compute sum of groups.\"\"\"\n        return self._obj.groupby(self._groups).sum(**kwargs)\n\n    def mean(self, **kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame:\n        \"\"\"Compute mean of groups.\"\"\"\n        return self._obj.groupby(self._groups).mean(**kwargs)\n\n    def min(self, **kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame:\n        \"\"\"Compute min of groups.\"\"\"\n        return self._obj.groupby(self._groups).min(**kwargs)\n\n    def max(self, **kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame:\n        \"\"\"Compute max of groups.\"\"\"\n        return self._obj.groupby(self._groups).max(**kwargs)\n\n    def count(self) -&gt; pd.Series[Any] | pd.DataFrame:\n        \"\"\"Compute count of groups.\"\"\"\n        return self._obj.groupby(self._groups).count()\n\n    def first(self, **kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame:\n        \"\"\"Compute first value of groups.\"\"\"\n        return self._obj.groupby(self._groups).first(**kwargs)\n\n    def last(self, **kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame:\n        \"\"\"Compute last value of groups.\"\"\"\n        return self._obj.groupby(self._groups).last(**kwargs)\n\n    def std(self, **kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame:\n        \"\"\"Compute standard deviation of groups.\"\"\"\n        return self._obj.groupby(self._groups).std(**kwargs)\n\n    def var(self, **kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame:\n        \"\"\"Compute variance of groups.\"\"\"\n        return self._obj.groupby(self._groups).var(**kwargs)\n\n    def median(self, **kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame:\n        \"\"\"Compute median of groups.\"\"\"\n        return self._obj.groupby(self._groups).median(**kwargs)\n\n    def agg(self, func: Any, *args: Any, **kwargs: Any) -&gt; Any:\n        \"\"\"Aggregate using one or more operations.\"\"\"\n        return self._obj.groupby(self._groups).agg(func, *args, **kwargs)\n\n    def apply(self, func: Any, *args: Any, **kwargs: Any) -&gt; Any:\n        \"\"\"Apply function to groups.\"\"\"\n        return self._obj.groupby(self._groups).apply(func, *args, **kwargs)\n</code></pre>"},{"location":"en/api/api/#jalali_pandas.api.grouper.JalaliResampler.__init__","title":"__init__","text":"<pre><code>__init__(obj: Series[Any] | DataFrame, offset: JalaliOffset, closed: Literal['right', 'left'] | None = None, label: Literal['right', 'left'] | None = None) -&gt; None\n</code></pre> <p>Initialize JalaliResampler.</p> Source code in <code>jalali_pandas/api/grouper.py</code> <pre><code>def __init__(\n    self,\n    obj: pd.Series[Any] | pd.DataFrame,\n    offset: JalaliOffset,\n    closed: Literal[\"right\", \"left\"] | None = None,\n    label: Literal[\"right\", \"left\"] | None = None,\n) -&gt; None:\n    \"\"\"Initialize JalaliResampler.\"\"\"\n    self._obj = obj\n    self._offset = offset\n    self._closed = closed or \"right\"\n    self._label = label or \"right\"\n    self._groups = self._compute_groups()\n</code></pre>"},{"location":"en/api/api/#jalali_pandas.api.grouper.JalaliResampler.agg","title":"agg","text":"<pre><code>agg(func: Any, *args: Any, **kwargs: Any) -&gt; Any\n</code></pre> <p>Aggregate using one or more operations.</p> Source code in <code>jalali_pandas/api/grouper.py</code> <pre><code>def agg(self, func: Any, *args: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"Aggregate using one or more operations.\"\"\"\n    return self._obj.groupby(self._groups).agg(func, *args, **kwargs)\n</code></pre>"},{"location":"en/api/api/#jalali_pandas.api.grouper.JalaliResampler.apply","title":"apply","text":"<pre><code>apply(func: Any, *args: Any, **kwargs: Any) -&gt; Any\n</code></pre> <p>Apply function to groups.</p> Source code in <code>jalali_pandas/api/grouper.py</code> <pre><code>def apply(self, func: Any, *args: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"Apply function to groups.\"\"\"\n    return self._obj.groupby(self._groups).apply(func, *args, **kwargs)\n</code></pre>"},{"location":"en/api/api/#jalali_pandas.api.grouper.JalaliResampler.count","title":"count","text":"<pre><code>count() -&gt; pd.Series[Any] | pd.DataFrame\n</code></pre> <p>Compute count of groups.</p> Source code in <code>jalali_pandas/api/grouper.py</code> <pre><code>def count(self) -&gt; pd.Series[Any] | pd.DataFrame:\n    \"\"\"Compute count of groups.\"\"\"\n    return self._obj.groupby(self._groups).count()\n</code></pre>"},{"location":"en/api/api/#jalali_pandas.api.grouper.JalaliResampler.first","title":"first","text":"<pre><code>first(**kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame\n</code></pre> <p>Compute first value of groups.</p> Source code in <code>jalali_pandas/api/grouper.py</code> <pre><code>def first(self, **kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame:\n    \"\"\"Compute first value of groups.\"\"\"\n    return self._obj.groupby(self._groups).first(**kwargs)\n</code></pre>"},{"location":"en/api/api/#jalali_pandas.api.grouper.JalaliResampler.last","title":"last","text":"<pre><code>last(**kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame\n</code></pre> <p>Compute last value of groups.</p> Source code in <code>jalali_pandas/api/grouper.py</code> <pre><code>def last(self, **kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame:\n    \"\"\"Compute last value of groups.\"\"\"\n    return self._obj.groupby(self._groups).last(**kwargs)\n</code></pre>"},{"location":"en/api/api/#jalali_pandas.api.grouper.JalaliResampler.max","title":"max","text":"<pre><code>max(**kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame\n</code></pre> <p>Compute max of groups.</p> Source code in <code>jalali_pandas/api/grouper.py</code> <pre><code>def max(self, **kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame:\n    \"\"\"Compute max of groups.\"\"\"\n    return self._obj.groupby(self._groups).max(**kwargs)\n</code></pre>"},{"location":"en/api/api/#jalali_pandas.api.grouper.JalaliResampler.mean","title":"mean","text":"<pre><code>mean(**kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame\n</code></pre> <p>Compute mean of groups.</p> Source code in <code>jalali_pandas/api/grouper.py</code> <pre><code>def mean(self, **kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame:\n    \"\"\"Compute mean of groups.\"\"\"\n    return self._obj.groupby(self._groups).mean(**kwargs)\n</code></pre>"},{"location":"en/api/api/#jalali_pandas.api.grouper.JalaliResampler.median","title":"median","text":"<pre><code>median(**kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame\n</code></pre> <p>Compute median of groups.</p> Source code in <code>jalali_pandas/api/grouper.py</code> <pre><code>def median(self, **kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame:\n    \"\"\"Compute median of groups.\"\"\"\n    return self._obj.groupby(self._groups).median(**kwargs)\n</code></pre>"},{"location":"en/api/api/#jalali_pandas.api.grouper.JalaliResampler.min","title":"min","text":"<pre><code>min(**kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame\n</code></pre> <p>Compute min of groups.</p> Source code in <code>jalali_pandas/api/grouper.py</code> <pre><code>def min(self, **kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame:\n    \"\"\"Compute min of groups.\"\"\"\n    return self._obj.groupby(self._groups).min(**kwargs)\n</code></pre>"},{"location":"en/api/api/#jalali_pandas.api.grouper.JalaliResampler.std","title":"std","text":"<pre><code>std(**kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame\n</code></pre> <p>Compute standard deviation of groups.</p> Source code in <code>jalali_pandas/api/grouper.py</code> <pre><code>def std(self, **kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame:\n    \"\"\"Compute standard deviation of groups.\"\"\"\n    return self._obj.groupby(self._groups).std(**kwargs)\n</code></pre>"},{"location":"en/api/api/#jalali_pandas.api.grouper.JalaliResampler.sum","title":"sum","text":"<pre><code>sum(**kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame\n</code></pre> <p>Compute sum of groups.</p> Source code in <code>jalali_pandas/api/grouper.py</code> <pre><code>def sum(self, **kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame:\n    \"\"\"Compute sum of groups.\"\"\"\n    return self._obj.groupby(self._groups).sum(**kwargs)\n</code></pre>"},{"location":"en/api/api/#jalali_pandas.api.grouper.JalaliResampler.var","title":"var","text":"<pre><code>var(**kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame\n</code></pre> <p>Compute variance of groups.</p> Source code in <code>jalali_pandas/api/grouper.py</code> <pre><code>def var(self, **kwargs: Any) -&gt; pd.Series[Any] | pd.DataFrame:\n    \"\"\"Compute variance of groups.\"\"\"\n    return self._obj.groupby(self._groups).var(**kwargs)\n</code></pre>"},{"location":"en/api/api/#jalali_pandas.api.grouper.jalali_groupby","title":"jalali_groupby","text":"<pre><code>jalali_groupby(df: DataFrame, key: str, freq: str | JalaliOffset, **kwargs: Any) -&gt; pd.core.groupby.DataFrameGroupBy\n</code></pre> <p>Group a DataFrame by Jalali calendar periods.</p> <p>This is a convenience function that creates a JalaliGrouper and applies it to the DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame to group.</p> required <code>key</code> <code>str</code> <p>Column name containing datetime values.</p> required <code>freq</code> <code>str | JalaliOffset</code> <p>Jalali frequency string (e.g., 'JME', 'JQE', 'JYE').</p> required <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to JalaliGrouper.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrameGroupBy</code> <p>DataFrameGroupBy object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\n...     'date': pd.date_range('2023-03-21', periods=90, freq='D'),\n...     'value': range(90)\n... })\n&gt;&gt;&gt; jalali_groupby(df, 'date', 'JME').sum()\n</code></pre> Source code in <code>jalali_pandas/api/grouper.py</code> <pre><code>def jalali_groupby(\n    df: pd.DataFrame,\n    key: str,\n    freq: str | JalaliOffset,\n    **kwargs: Any,\n) -&gt; pd.core.groupby.DataFrameGroupBy:  # type: ignore[type-arg]\n    \"\"\"Group a DataFrame by Jalali calendar periods.\n\n    This is a convenience function that creates a JalaliGrouper and applies\n    it to the DataFrame.\n\n    Args:\n        df: DataFrame to group.\n        key: Column name containing datetime values.\n        freq: Jalali frequency string (e.g., 'JME', 'JQE', 'JYE').\n        **kwargs: Additional arguments passed to JalaliGrouper.\n\n    Returns:\n        DataFrameGroupBy object.\n\n    Examples:\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     'date': pd.date_range('2023-03-21', periods=90, freq='D'),\n        ...     'value': range(90)\n        ... })\n        &gt;&gt;&gt; jalali_groupby(df, 'date', 'JME').sum()\n    \"\"\"\n    grouper = JalaliGrouper(key=key, freq=freq, **kwargs)\n    return df.groupby(grouper)\n</code></pre>"},{"location":"en/api/api/#jalali_pandas.api.grouper.resample_jalali","title":"resample_jalali","text":"<pre><code>resample_jalali(series_or_df: Series[Any] | DataFrame, freq: str | JalaliOffset, closed: Literal['right', 'left'] | None = None, label: Literal['right', 'left'] | None = None) -&gt; JalaliResampler\n</code></pre> <p>Resample a Series or DataFrame using Jalali calendar boundaries.</p> <p>This function provides resampling functionality using Jalali calendar period boundaries instead of Gregorian.</p> <p>Parameters:</p> Name Type Description Default <code>series_or_df</code> <code>Series[Any] | DataFrame</code> <p>Series or DataFrame with DatetimeIndex.</p> required <code>freq</code> <code>str | JalaliOffset</code> <p>Jalali frequency string or offset.</p> required <code>closed</code> <code>Literal['right', 'left'] | None</code> <p>Which side of bin interval is closed.</p> <code>None</code> <code>label</code> <code>Literal['right', 'left'] | None</code> <p>Which bin edge label to use.</p> <code>None</code> <p>Returns:</p> Type Description <code>JalaliResampler</code> <p>JalaliResampler object with aggregation methods.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; idx = pd.date_range('2023-03-21', periods=90, freq='D')\n&gt;&gt;&gt; s = pd.Series(range(90), index=idx)\n&gt;&gt;&gt; resample_jalali(s, 'JME').sum()\n</code></pre> Source code in <code>jalali_pandas/api/grouper.py</code> <pre><code>def resample_jalali(\n    series_or_df: pd.Series[Any] | pd.DataFrame,\n    freq: str | JalaliOffset,\n    closed: Literal[\"right\", \"left\"] | None = None,\n    label: Literal[\"right\", \"left\"] | None = None,\n) -&gt; JalaliResampler:\n    \"\"\"Resample a Series or DataFrame using Jalali calendar boundaries.\n\n    This function provides resampling functionality using Jalali calendar\n    period boundaries instead of Gregorian.\n\n    Args:\n        series_or_df: Series or DataFrame with DatetimeIndex.\n        freq: Jalali frequency string or offset.\n        closed: Which side of bin interval is closed.\n        label: Which bin edge label to use.\n\n    Returns:\n        JalaliResampler object with aggregation methods.\n\n    Examples:\n        &gt;&gt;&gt; idx = pd.date_range('2023-03-21', periods=90, freq='D')\n        &gt;&gt;&gt; s = pd.Series(range(90), index=idx)\n        &gt;&gt;&gt; resample_jalali(s, 'JME').sum()\n    \"\"\"\n    # Parse frequency\n    offset = parse_jalali_frequency(freq) if isinstance(freq, str) else freq\n\n    return JalaliResampler(series_or_df, offset, closed=closed, label=label)\n</code></pre>"},{"location":"en/api/core/","title":"Core","text":"<p>JalaliTimestamp - Scalar Jalali datetime type.</p> <p>JalaliDatetimeDtype - ExtensionDtype for Jalali datetime.</p> <p>JalaliDatetimeArray - ExtensionArray for Jalali datetime.</p> <p>JalaliDatetimeIndex - Index for Jalali datetime data.</p> <p>Jalali calendar rules and utilities.</p> <p>Vectorized conversion utilities for Jalali-Gregorian date conversions.</p> <p>This module provides optimized conversion functions using NumPy for efficient batch processing of date conversions.</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp","title":"JalaliTimestamp","text":"<p>A Jalali (Persian/Shamsi) calendar timestamp.</p> <p>Similar to pandas.Timestamp but for the Jalali calendar system.</p> <p>Attributes:</p> Name Type Description <code>year</code> <code>int</code> <p>Jalali year.</p> <code>month</code> <code>int</code> <p>Jalali month (1-12).</p> <code>day</code> <code>int</code> <p>Jalali day (1-31).</p> <code>hour</code> <code>int</code> <p>Hour (0-23).</p> <code>minute</code> <code>int</code> <p>Minute (0-59).</p> <code>second</code> <code>int</code> <p>Second (0-59).</p> <code>microsecond</code> <code>int</code> <p>Microsecond (0-999999).</p> <code>nanosecond</code> <code>int</code> <p>Nanosecond (0-999).</p> <code>tzinfo</code> <code>tzinfo | None</code> <p>Timezone information.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ts = JalaliTimestamp(1402, 6, 15)\n&gt;&gt;&gt; ts.year\n1402\n&gt;&gt;&gt; ts.month\n6\n&gt;&gt;&gt; ts.to_gregorian()\nTimestamp('2023-09-06 00:00:00')\n</code></pre> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>class JalaliTimestamp:\n    \"\"\"A Jalali (Persian/Shamsi) calendar timestamp.\n\n    Similar to pandas.Timestamp but for the Jalali calendar system.\n\n    Attributes:\n        year: Jalali year.\n        month: Jalali month (1-12).\n        day: Jalali day (1-31).\n        hour: Hour (0-23).\n        minute: Minute (0-59).\n        second: Second (0-59).\n        microsecond: Microsecond (0-999999).\n        nanosecond: Nanosecond (0-999).\n        tzinfo: Timezone information.\n\n    Examples:\n        &gt;&gt;&gt; ts = JalaliTimestamp(1402, 6, 15)\n        &gt;&gt;&gt; ts.year\n        1402\n        &gt;&gt;&gt; ts.month\n        6\n        &gt;&gt;&gt; ts.to_gregorian()\n        Timestamp('2023-09-06 00:00:00')\n    \"\"\"\n\n    __slots__ = (\n        \"_year\",\n        \"_month\",\n        \"_day\",\n        \"_hour\",\n        \"_minute\",\n        \"_second\",\n        \"_microsecond\",\n        \"_nanosecond\",\n        \"_tzinfo\",\n        \"_gregorian_cache\",\n    )\n\n    def __init__(\n        self,\n        year: int,\n        month: int = 1,\n        day: int = 1,\n        hour: int = 0,\n        minute: int = 0,\n        second: int = 0,\n        microsecond: int = 0,\n        nanosecond: int = 0,\n        tzinfo: dt_tzinfo | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize a JalaliTimestamp.\n\n        Args:\n            year: Jalali year.\n            month: Jalali month (1-12). Defaults to 1.\n            day: Jalali day. Defaults to 1.\n            hour: Hour (0-23). Defaults to 0.\n            minute: Minute (0-59). Defaults to 0.\n            second: Second (0-59). Defaults to 0.\n            microsecond: Microsecond (0-999999). Defaults to 0.\n            nanosecond: Nanosecond (0-999). Defaults to 0.\n            tzinfo: Timezone. Defaults to None.\n\n        Raises:\n            ValueError: If any component is out of valid range.\n        \"\"\"\n        validate_jalali_date(year, month, day)\n\n        if not 0 &lt;= hour &lt;= 23:\n            raise ValueError(f\"Hour must be 0-23, got {hour}\")\n        if not 0 &lt;= minute &lt;= 59:\n            raise ValueError(f\"Minute must be 0-59, got {minute}\")\n        if not 0 &lt;= second &lt;= 59:\n            raise ValueError(f\"Second must be 0-59, got {second}\")\n        if not 0 &lt;= microsecond &lt;= 999999:\n            raise ValueError(f\"Microsecond must be 0-999999, got {microsecond}\")\n        if not 0 &lt;= nanosecond &lt;= 999:\n            raise ValueError(f\"Nanosecond must be 0-999, got {nanosecond}\")\n\n        self._year = year\n        self._month = month\n        self._day = day\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._nanosecond = nanosecond\n        self._tzinfo = tzinfo\n        self._gregorian_cache: pd.Timestamp | None = None\n\n    # -------------------------------------------------------------------------\n    # Properties\n    # -------------------------------------------------------------------------\n\n    @property\n    def year(self) -&gt; int:\n        \"\"\"Jalali year.\"\"\"\n        return self._year\n\n    @property\n    def month(self) -&gt; int:\n        \"\"\"Jalali month (1-12).\"\"\"\n        return self._month\n\n    @property\n    def day(self) -&gt; int:\n        \"\"\"Jalali day (1-31).\"\"\"\n        return self._day\n\n    @property\n    def hour(self) -&gt; int:\n        \"\"\"Hour (0-23).\"\"\"\n        return self._hour\n\n    @property\n    def minute(self) -&gt; int:\n        \"\"\"Minute (0-59).\"\"\"\n        return self._minute\n\n    @property\n    def second(self) -&gt; int:\n        \"\"\"Second (0-59).\"\"\"\n        return self._second\n\n    @property\n    def microsecond(self) -&gt; int:\n        \"\"\"Microsecond (0-999999).\"\"\"\n        return self._microsecond\n\n    @property\n    def nanosecond(self) -&gt; int:\n        \"\"\"Nanosecond (0-999).\"\"\"\n        return self._nanosecond\n\n    @property\n    def tzinfo(self) -&gt; dt_tzinfo | None:\n        \"\"\"Timezone information.\"\"\"\n        return self._tzinfo\n\n    @property\n    def tz(self) -&gt; dt_tzinfo | None:\n        \"\"\"Alias for tzinfo.\"\"\"\n        return self._tzinfo\n\n    # -------------------------------------------------------------------------\n    # Derived Properties\n    # -------------------------------------------------------------------------\n\n    @property\n    def quarter(self) -&gt; int:\n        \"\"\"Quarter of the year (1-4).\"\"\"\n        return quarter_of_month(self._month)\n\n    @property\n    def dayofweek(self) -&gt; int:\n        \"\"\"Day of week (0=Saturday, 6=Friday).\"\"\"\n        return weekday_of_jalali(self._year, self._month, self._day)\n\n    @property\n    def weekday(self) -&gt; int:\n        \"\"\"Alias for dayofweek.\"\"\"\n        return self.dayofweek\n\n    @property\n    def dayofyear(self) -&gt; int:\n        \"\"\"Day of year (1-366).\"\"\"\n        from jalali_pandas.core.calendar import day_of_year\n\n        return day_of_year(self._year, self._month, self._day)\n\n    @property\n    def week(self) -&gt; int:\n        \"\"\"Week of year (1-53).\"\"\"\n        return week_of_year(self._year, self._month, self._day)\n\n    @property\n    def weekofyear(self) -&gt; int:\n        \"\"\"Alias for week.\"\"\"\n        return self.week\n\n    @property\n    def days_in_month(self) -&gt; int:\n        \"\"\"Number of days in the month.\"\"\"\n        return days_in_month(self._year, self._month)\n\n    @property\n    def daysinmonth(self) -&gt; int:\n        \"\"\"Alias for days_in_month.\"\"\"\n        return self.days_in_month\n\n    @property\n    def is_leap_year(self) -&gt; bool:\n        \"\"\"Whether the year is a leap year.\"\"\"\n        return is_leap_year(self._year)\n\n    @property\n    def is_month_start(self) -&gt; bool:\n        \"\"\"Whether the date is the first day of the month.\"\"\"\n        return self._day == 1\n\n    @property\n    def is_month_end(self) -&gt; bool:\n        \"\"\"Whether the date is the last day of the month.\"\"\"\n        return self._day == self.days_in_month\n\n    @property\n    def is_quarter_start(self) -&gt; bool:\n        \"\"\"Whether the date is the first day of a quarter.\"\"\"\n        return self._month in (1, 4, 7, 10) and self._day == 1\n\n    @property\n    def is_quarter_end(self) -&gt; bool:\n        \"\"\"Whether the date is the last day of a quarter.\"\"\"\n        return self._month in (3, 6, 9, 12) and self.is_month_end\n\n    @property\n    def is_year_start(self) -&gt; bool:\n        \"\"\"Whether the date is the first day of the year (Nowruz).\"\"\"\n        return self._month == 1 and self._day == 1\n\n    @property\n    def is_year_end(self) -&gt; bool:\n        \"\"\"Whether the date is the last day of the year.\"\"\"\n        return self._month == 12 and self.is_month_end\n\n    # -------------------------------------------------------------------------\n    # Conversion Methods\n    # -------------------------------------------------------------------------\n\n    def to_gregorian(self) -&gt; pd.Timestamp:\n        \"\"\"Convert to pandas Timestamp (Gregorian).\n\n        Returns:\n            Equivalent pandas Timestamp in Gregorian calendar.\n        \"\"\"\n        if self._gregorian_cache is not None:\n            return self._gregorian_cache\n\n        gregorian = jdatetime.datetime(\n            self._year,\n            self._month,\n            self._day,\n            self._hour,\n            self._minute,\n            self._second,\n            self._microsecond,\n        ).togregorian()\n        ts = pd.Timestamp(\n            year=gregorian.year,\n            month=gregorian.month,\n            day=gregorian.day,\n            hour=gregorian.hour,\n            minute=gregorian.minute,\n            second=gregorian.second,\n            microsecond=gregorian.microsecond,\n            nanosecond=self._nanosecond,\n            tz=self._tzinfo,\n        )\n\n        self._gregorian_cache = ts\n        return ts\n\n    def to_pydatetime(self) -&gt; datetime:\n        \"\"\"Convert to Python datetime (Gregorian).\n\n        Returns:\n            Equivalent Python datetime in Gregorian calendar.\n        \"\"\"\n        return self.to_gregorian().to_pydatetime()\n\n    def to_datetime64(self) -&gt; np.datetime64:\n        \"\"\"Convert to numpy datetime64.\n\n        Returns:\n            Equivalent numpy datetime64.\n        \"\"\"\n        return self.to_gregorian().to_datetime64()\n\n    @classmethod\n    def from_gregorian(\n        cls,\n        ts: pd.Timestamp | datetime | str,\n        tz: dt_tzinfo | str | None = None,\n    ) -&gt; JalaliTimestamp:\n        \"\"\"Create JalaliTimestamp from Gregorian datetime.\n\n        Args:\n            ts: Gregorian timestamp (pandas Timestamp, datetime, or string).\n            tz: Timezone to use. Defaults to None.\n\n        Returns:\n            Equivalent JalaliTimestamp.\n        \"\"\"\n        if (\n            isinstance(ts, str)\n            or isinstance(ts, datetime)\n            and not isinstance(ts, pd.Timestamp)\n        ):\n            ts = pd.Timestamp(ts)\n\n        if tz is not None:\n            ts = ts.tz_localize(tz) if ts.tzinfo is None else ts.tz_convert(tz)\n\n        jalali = jdatetime.datetime.fromgregorian(datetime=ts.to_pydatetime())\n\n        return cls(\n            year=jalali.year,\n            month=jalali.month,\n            day=jalali.day,\n            hour=jalali.hour,\n            minute=jalali.minute,\n            second=jalali.second,\n            microsecond=jalali.microsecond,\n            nanosecond=ts.nanosecond,\n            tzinfo=ts.tzinfo,\n        )\n\n    @classmethod\n    def now(cls, tz: dt_tzinfo | str | None = None) -&gt; JalaliTimestamp:\n        \"\"\"Get current JalaliTimestamp.\n\n        Args:\n            tz: Timezone. Defaults to None (local time).\n\n        Returns:\n            Current time as JalaliTimestamp.\n        \"\"\"\n        return cls.from_gregorian(pd.Timestamp.now(tz=tz))\n\n    @classmethod\n    def today(cls) -&gt; JalaliTimestamp:\n        \"\"\"Get today's date as JalaliTimestamp (midnight).\n\n        Returns:\n            Today's date as JalaliTimestamp.\n        \"\"\"\n        now = cls.now()\n        return cls(now.year, now.month, now.day)\n\n    # -------------------------------------------------------------------------\n    # String Methods\n    # -------------------------------------------------------------------------\n\n    def strftime(self, fmt: str) -&gt; str:\n        \"\"\"Format timestamp as string.\n\n        Supports standard strftime codes adapted for Jalali calendar.\n\n        Args:\n            fmt: Format string.\n\n        Returns:\n            Formatted string.\n        \"\"\"\n        replacements = {\n            \"%Y\": f\"{self._year:04d}\",\n            \"%y\": f\"{self._year % 100:02d}\",\n            \"%m\": f\"{self._month:02d}\",\n            \"%d\": f\"{self._day:02d}\",\n            \"%H\": f\"{self._hour:02d}\",\n            \"%M\": f\"{self._minute:02d}\",\n            \"%S\": f\"{self._second:02d}\",\n            \"%f\": f\"{self._microsecond:06d}\",\n            \"%j\": f\"{self.dayofyear:03d}\",\n            \"%W\": f\"{self.week:02d}\",\n            \"%w\": str(self.dayofweek),\n        }\n\n        result = fmt\n        for code, value in replacements.items():\n            result = result.replace(code, value)\n\n        return result\n\n    @classmethod\n    def strptime(cls, date_string: str, fmt: str) -&gt; JalaliTimestamp:\n        \"\"\"Parse string to JalaliTimestamp.\n\n        Args:\n            date_string: Date string to parse.\n            fmt: Format string.\n\n        Returns:\n            Parsed JalaliTimestamp.\n        \"\"\"\n        # Simple implementation for common formats\n        import re\n\n        # Build regex pattern from format string\n        pattern = fmt\n        groups: dict[str, str] = {}\n\n        replacements = [\n            (\"%Y\", r\"(?P&lt;year&gt;\\d{4})\", \"year\"),\n            (\"%y\", r\"(?P&lt;year2&gt;\\d{2})\", \"year2\"),\n            (\"%m\", r\"(?P&lt;month&gt;\\d{1,2})\", \"month\"),\n            (\"%d\", r\"(?P&lt;day&gt;\\d{1,2})\", \"day\"),\n            (\"%H\", r\"(?P&lt;hour&gt;\\d{1,2})\", \"hour\"),\n            (\"%M\", r\"(?P&lt;minute&gt;\\d{1,2})\", \"minute\"),\n            (\"%S\", r\"(?P&lt;second&gt;\\d{1,2})\", \"second\"),\n        ]\n\n        for code, regex, name in replacements:\n            if code in pattern:\n                pattern = pattern.replace(code, regex)\n                groups[name] = \"\"\n\n        match = re.match(pattern, date_string)\n        if not match:\n            raise ValueError(f\"Cannot parse '{date_string}' with format '{fmt}'\")\n\n        data = match.groupdict()\n\n        year = int(data.get(\"year\", 0) or data.get(\"year2\", 0))\n        if \"year2\" in data and data[\"year2\"]:\n            year = 1300 + year if year &lt; 100 else year\n\n        return cls(\n            year=year,\n            month=int(data.get(\"month\", 1)),\n            day=int(data.get(\"day\", 1)),\n            hour=int(data.get(\"hour\", 0)),\n            minute=int(data.get(\"minute\", 0)),\n            second=int(data.get(\"second\", 0)),\n        )\n\n    def isoformat(self, sep: str = \"T\") -&gt; str:\n        \"\"\"Return ISO 8601 formatted string.\n\n        Args:\n            sep: Separator between date and time. Defaults to 'T'.\n\n        Returns:\n            ISO formatted string.\n        \"\"\"\n        date_part = f\"{self._year:04d}-{self._month:02d}-{self._day:02d}\"\n        time_part = f\"{self._hour:02d}:{self._minute:02d}:{self._second:02d}\"\n\n        if self._microsecond or self._nanosecond:\n            time_part += f\".{self._microsecond:06d}\"\n\n        result = f\"{date_part}{sep}{time_part}\"\n\n        if self._tzinfo is not None:\n            # Get timezone offset\n            offset = self._tzinfo.utcoffset(None)\n            if offset is not None:\n                total_seconds = int(offset.total_seconds())\n                hours, remainder = divmod(abs(total_seconds), 3600)\n                minutes = remainder // 60\n                sign = \"+\" if total_seconds &gt;= 0 else \"-\"\n                result += f\"{sign}{hours:02d}:{minutes:02d}\"\n\n        return result\n\n    # -------------------------------------------------------------------------\n    # Arithmetic Operations\n    # -------------------------------------------------------------------------\n\n    def __add__(self, other: timedelta | pd.Timedelta) -&gt; JalaliTimestamp:\n        \"\"\"Add timedelta to timestamp.\"\"\"\n        if isinstance(other, (timedelta, pd.Timedelta)):\n            new_gregorian = self.to_gregorian() + other\n            return JalaliTimestamp.from_gregorian(new_gregorian)\n        return NotImplemented\n\n    def __radd__(self, other: timedelta | pd.Timedelta) -&gt; JalaliTimestamp:\n        \"\"\"Right add timedelta to timestamp.\"\"\"\n        return self.__add__(other)\n\n    def __sub__(\n        self, other: JalaliTimestamp | timedelta | pd.Timedelta\n    ) -&gt; JalaliTimestamp | pd.Timedelta:\n        \"\"\"Subtract timedelta or another timestamp.\"\"\"\n        if isinstance(other, JalaliTimestamp):\n            return self.to_gregorian() - other.to_gregorian()\n        if isinstance(other, (timedelta, pd.Timedelta)):\n            new_gregorian = self.to_gregorian() - other\n            return JalaliTimestamp.from_gregorian(new_gregorian)\n        return NotImplemented\n\n    # -------------------------------------------------------------------------\n    # Comparison Operations\n    # -------------------------------------------------------------------------\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality.\"\"\"\n        if isinstance(other, JalaliTimestamp):\n            return (\n                self._year == other._year\n                and self._month == other._month\n                and self._day == other._day\n                and self._hour == other._hour\n                and self._minute == other._minute\n                and self._second == other._second\n                and self._microsecond == other._microsecond\n                and self._nanosecond == other._nanosecond\n            )\n        return False\n\n    def __ne__(self, other: object) -&gt; bool:\n        \"\"\"Check inequality.\"\"\"\n        return not self.__eq__(other)\n\n    def __lt__(self, other: JalaliTimestamp) -&gt; bool:\n        \"\"\"Less than comparison.\"\"\"\n        if not isinstance(other, JalaliTimestamp):\n            return NotImplemented\n        return self.to_gregorian() &lt; other.to_gregorian()\n\n    def __le__(self, other: JalaliTimestamp) -&gt; bool:\n        \"\"\"Less than or equal comparison.\"\"\"\n        if not isinstance(other, JalaliTimestamp):\n            return NotImplemented\n        return self.to_gregorian() &lt;= other.to_gregorian()\n\n    def __gt__(self, other: JalaliTimestamp) -&gt; bool:\n        \"\"\"Greater than comparison.\"\"\"\n        if not isinstance(other, JalaliTimestamp):\n            return NotImplemented\n        return self.to_gregorian() &gt; other.to_gregorian()\n\n    def __ge__(self, other: JalaliTimestamp) -&gt; bool:\n        \"\"\"Greater than or equal comparison.\"\"\"\n        if not isinstance(other, JalaliTimestamp):\n            return NotImplemented\n        return self.to_gregorian() &gt;= other.to_gregorian()\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Hash for use in sets and dicts.\"\"\"\n        return hash(\n            (\n                self._year,\n                self._month,\n                self._day,\n                self._hour,\n                self._minute,\n                self._second,\n                self._microsecond,\n                self._nanosecond,\n            )\n        )\n\n    # -------------------------------------------------------------------------\n    # String Representations\n    # -------------------------------------------------------------------------\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Detailed string representation.\"\"\"\n        tz_str = f\", tz='{self._tzinfo}'\" if self._tzinfo else \"\"\n        return f\"JalaliTimestamp('{self.isoformat()}'{tz_str})\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Human-readable string representation.\"\"\"\n        return self.isoformat(sep=\" \")\n\n    # -------------------------------------------------------------------------\n    # Replacement Methods\n    # -------------------------------------------------------------------------\n\n    def replace(\n        self,\n        year: int | None = None,\n        month: int | None = None,\n        day: int | None = None,\n        hour: int | None = None,\n        minute: int | None = None,\n        second: int | None = None,\n        microsecond: int | None = None,\n        nanosecond: int | None = None,\n        tzinfo: dt_tzinfo | None | object = ...,\n    ) -&gt; JalaliTimestamp:\n        \"\"\"Return timestamp with replaced components.\n\n        Args:\n            year: New year (or None to keep current).\n            month: New month (or None to keep current).\n            day: New day (or None to keep current).\n            hour: New hour (or None to keep current).\n            minute: New minute (or None to keep current).\n            second: New second (or None to keep current).\n            microsecond: New microsecond (or None to keep current).\n            nanosecond: New nanosecond (or None to keep current).\n            tzinfo: New timezone (or ... to keep current).\n\n        Returns:\n            New JalaliTimestamp with replaced components.\n        \"\"\"\n        return JalaliTimestamp(\n            year=year if year is not None else self._year,\n            month=month if month is not None else self._month,\n            day=day if day is not None else self._day,\n            hour=hour if hour is not None else self._hour,\n            minute=minute if minute is not None else self._minute,\n            second=second if second is not None else self._second,\n            microsecond=microsecond if microsecond is not None else self._microsecond,\n            nanosecond=nanosecond if nanosecond is not None else self._nanosecond,\n            tzinfo=self._tzinfo if tzinfo is ... else cast(Optional[dt_tzinfo], tzinfo),\n        )\n\n    def normalize(self) -&gt; JalaliTimestamp:\n        \"\"\"Return timestamp with time set to midnight.\n\n        Returns:\n            New JalaliTimestamp at midnight.\n        \"\"\"\n        return self.replace(hour=0, minute=0, second=0, microsecond=0, nanosecond=0)\n\n    def date(self) -&gt; JalaliTimestamp:\n        \"\"\"Return date part only (time set to midnight).\n\n        Returns:\n            New JalaliTimestamp at midnight.\n        \"\"\"\n        return self.normalize()\n\n    def time(self) -&gt; time:\n        \"\"\"Return time part as Python time object.\n\n        Returns:\n            Python time object.\n        \"\"\"\n        return time(\n            hour=self._hour,\n            minute=self._minute,\n            second=self._second,\n            microsecond=self._microsecond,\n            tzinfo=self._tzinfo,\n        )\n\n    # -------------------------------------------------------------------------\n    # Timezone Methods\n    # -------------------------------------------------------------------------\n\n    def tz_localize(\n        self,\n        tz: dt_tzinfo | str | None,\n        ambiguous: str = \"raise\",\n        nonexistent: str = \"raise\",\n    ) -&gt; JalaliTimestamp:\n        \"\"\"Localize tz-naive timestamp to a timezone.\n\n        Args:\n            tz: Timezone to localize to. Can be a timezone object or string.\n            ambiguous: How to handle ambiguous times. Defaults to 'raise'.\n            nonexistent: How to handle nonexistent times. Defaults to 'raise'.\n\n        Returns:\n            New JalaliTimestamp with timezone.\n\n        Raises:\n            TypeError: If timestamp is already tz-aware.\n        \"\"\"\n        if self._tzinfo is not None:\n            raise TypeError(\n                \"Cannot localize tz-aware timestamp. \"\n                \"Use tz_convert() to convert between timezones.\"\n            )\n\n        # Convert to Gregorian, localize, then convert back\n        gregorian = self.to_gregorian()\n        localized = gregorian.tz_localize(\n            tz, ambiguous=ambiguous, nonexistent=nonexistent\n        )\n\n        # Create new JalaliTimestamp with the timezone\n        return JalaliTimestamp(\n            year=self._year,\n            month=self._month,\n            day=self._day,\n            hour=self._hour,\n            minute=self._minute,\n            second=self._second,\n            microsecond=self._microsecond,\n            nanosecond=self._nanosecond,\n            tzinfo=localized.tzinfo,\n        )\n\n    def tz_convert(self, tz: dt_tzinfo | str | None) -&gt; JalaliTimestamp:\n        \"\"\"Convert tz-aware timestamp to another timezone.\n\n        Args:\n            tz: Target timezone. Can be a timezone object or string.\n\n        Returns:\n            New JalaliTimestamp in the target timezone.\n\n        Raises:\n            TypeError: If timestamp is tz-naive.\n        \"\"\"\n        if self._tzinfo is None:\n            raise TypeError(\n                \"Cannot convert tz-naive timestamp. \"\n                \"Use tz_localize() first to add timezone.\"\n            )\n\n        # Convert to Gregorian, convert timezone, then convert back to Jalali\n        gregorian = self.to_gregorian()\n        converted = gregorian.tz_convert(tz)\n\n        # Convert the new Gregorian time back to Jalali\n        return JalaliTimestamp.from_gregorian(converted)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.day","title":"day  <code>property</code>","text":"<pre><code>day: int\n</code></pre> <p>Jalali day (1-31).</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.dayofweek","title":"dayofweek  <code>property</code>","text":"<pre><code>dayofweek: int\n</code></pre> <p>Day of week (0=Saturday, 6=Friday).</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.dayofyear","title":"dayofyear  <code>property</code>","text":"<pre><code>dayofyear: int\n</code></pre> <p>Day of year (1-366).</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.days_in_month","title":"days_in_month  <code>property</code>","text":"<pre><code>days_in_month: int\n</code></pre> <p>Number of days in the month.</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.daysinmonth","title":"daysinmonth  <code>property</code>","text":"<pre><code>daysinmonth: int\n</code></pre> <p>Alias for days_in_month.</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.hour","title":"hour  <code>property</code>","text":"<pre><code>hour: int\n</code></pre> <p>Hour (0-23).</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.is_leap_year","title":"is_leap_year  <code>property</code>","text":"<pre><code>is_leap_year: bool\n</code></pre> <p>Whether the year is a leap year.</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.is_month_end","title":"is_month_end  <code>property</code>","text":"<pre><code>is_month_end: bool\n</code></pre> <p>Whether the date is the last day of the month.</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.is_month_start","title":"is_month_start  <code>property</code>","text":"<pre><code>is_month_start: bool\n</code></pre> <p>Whether the date is the first day of the month.</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.is_quarter_end","title":"is_quarter_end  <code>property</code>","text":"<pre><code>is_quarter_end: bool\n</code></pre> <p>Whether the date is the last day of a quarter.</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.is_quarter_start","title":"is_quarter_start  <code>property</code>","text":"<pre><code>is_quarter_start: bool\n</code></pre> <p>Whether the date is the first day of a quarter.</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.is_year_end","title":"is_year_end  <code>property</code>","text":"<pre><code>is_year_end: bool\n</code></pre> <p>Whether the date is the last day of the year.</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.is_year_start","title":"is_year_start  <code>property</code>","text":"<pre><code>is_year_start: bool\n</code></pre> <p>Whether the date is the first day of the year (Nowruz).</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.microsecond","title":"microsecond  <code>property</code>","text":"<pre><code>microsecond: int\n</code></pre> <p>Microsecond (0-999999).</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.minute","title":"minute  <code>property</code>","text":"<pre><code>minute: int\n</code></pre> <p>Minute (0-59).</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.month","title":"month  <code>property</code>","text":"<pre><code>month: int\n</code></pre> <p>Jalali month (1-12).</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.nanosecond","title":"nanosecond  <code>property</code>","text":"<pre><code>nanosecond: int\n</code></pre> <p>Nanosecond (0-999).</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.quarter","title":"quarter  <code>property</code>","text":"<pre><code>quarter: int\n</code></pre> <p>Quarter of the year (1-4).</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.second","title":"second  <code>property</code>","text":"<pre><code>second: int\n</code></pre> <p>Second (0-59).</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.tz","title":"tz  <code>property</code>","text":"<pre><code>tz: tzinfo | None\n</code></pre> <p>Alias for tzinfo.</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.tzinfo","title":"tzinfo  <code>property</code>","text":"<pre><code>tzinfo: tzinfo | None\n</code></pre> <p>Timezone information.</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.week","title":"week  <code>property</code>","text":"<pre><code>week: int\n</code></pre> <p>Week of year (1-53).</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.weekday","title":"weekday  <code>property</code>","text":"<pre><code>weekday: int\n</code></pre> <p>Alias for dayofweek.</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.weekofyear","title":"weekofyear  <code>property</code>","text":"<pre><code>weekofyear: int\n</code></pre> <p>Alias for week.</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.year","title":"year  <code>property</code>","text":"<pre><code>year: int\n</code></pre> <p>Jalali year.</p>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.__add__","title":"__add__","text":"<pre><code>__add__(other: timedelta | Timedelta) -&gt; JalaliTimestamp\n</code></pre> <p>Add timedelta to timestamp.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def __add__(self, other: timedelta | pd.Timedelta) -&gt; JalaliTimestamp:\n    \"\"\"Add timedelta to timestamp.\"\"\"\n    if isinstance(other, (timedelta, pd.Timedelta)):\n        new_gregorian = self.to_gregorian() + other\n        return JalaliTimestamp.from_gregorian(new_gregorian)\n    return NotImplemented\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality.\"\"\"\n    if isinstance(other, JalaliTimestamp):\n        return (\n            self._year == other._year\n            and self._month == other._month\n            and self._day == other._day\n            and self._hour == other._hour\n            and self._minute == other._minute\n            and self._second == other._second\n            and self._microsecond == other._microsecond\n            and self._nanosecond == other._nanosecond\n        )\n    return False\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.__ge__","title":"__ge__","text":"<pre><code>__ge__(other: JalaliTimestamp) -&gt; bool\n</code></pre> <p>Greater than or equal comparison.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def __ge__(self, other: JalaliTimestamp) -&gt; bool:\n    \"\"\"Greater than or equal comparison.\"\"\"\n    if not isinstance(other, JalaliTimestamp):\n        return NotImplemented\n    return self.to_gregorian() &gt;= other.to_gregorian()\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.__gt__","title":"__gt__","text":"<pre><code>__gt__(other: JalaliTimestamp) -&gt; bool\n</code></pre> <p>Greater than comparison.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def __gt__(self, other: JalaliTimestamp) -&gt; bool:\n    \"\"\"Greater than comparison.\"\"\"\n    if not isinstance(other, JalaliTimestamp):\n        return NotImplemented\n    return self.to_gregorian() &gt; other.to_gregorian()\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Hash for use in sets and dicts.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Hash for use in sets and dicts.\"\"\"\n    return hash(\n        (\n            self._year,\n            self._month,\n            self._day,\n            self._hour,\n            self._minute,\n            self._second,\n            self._microsecond,\n            self._nanosecond,\n        )\n    )\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.__init__","title":"__init__","text":"<pre><code>__init__(year: int, month: int = 1, day: int = 1, hour: int = 0, minute: int = 0, second: int = 0, microsecond: int = 0, nanosecond: int = 0, tzinfo: tzinfo | None = None) -&gt; None\n</code></pre> <p>Initialize a JalaliTimestamp.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Jalali year.</p> required <code>month</code> <code>int</code> <p>Jalali month (1-12). Defaults to 1.</p> <code>1</code> <code>day</code> <code>int</code> <p>Jalali day. Defaults to 1.</p> <code>1</code> <code>hour</code> <code>int</code> <p>Hour (0-23). Defaults to 0.</p> <code>0</code> <code>minute</code> <code>int</code> <p>Minute (0-59). Defaults to 0.</p> <code>0</code> <code>second</code> <code>int</code> <p>Second (0-59). Defaults to 0.</p> <code>0</code> <code>microsecond</code> <code>int</code> <p>Microsecond (0-999999). Defaults to 0.</p> <code>0</code> <code>nanosecond</code> <code>int</code> <p>Nanosecond (0-999). Defaults to 0.</p> <code>0</code> <code>tzinfo</code> <code>tzinfo | None</code> <p>Timezone. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any component is out of valid range.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def __init__(\n    self,\n    year: int,\n    month: int = 1,\n    day: int = 1,\n    hour: int = 0,\n    minute: int = 0,\n    second: int = 0,\n    microsecond: int = 0,\n    nanosecond: int = 0,\n    tzinfo: dt_tzinfo | None = None,\n) -&gt; None:\n    \"\"\"Initialize a JalaliTimestamp.\n\n    Args:\n        year: Jalali year.\n        month: Jalali month (1-12). Defaults to 1.\n        day: Jalali day. Defaults to 1.\n        hour: Hour (0-23). Defaults to 0.\n        minute: Minute (0-59). Defaults to 0.\n        second: Second (0-59). Defaults to 0.\n        microsecond: Microsecond (0-999999). Defaults to 0.\n        nanosecond: Nanosecond (0-999). Defaults to 0.\n        tzinfo: Timezone. Defaults to None.\n\n    Raises:\n        ValueError: If any component is out of valid range.\n    \"\"\"\n    validate_jalali_date(year, month, day)\n\n    if not 0 &lt;= hour &lt;= 23:\n        raise ValueError(f\"Hour must be 0-23, got {hour}\")\n    if not 0 &lt;= minute &lt;= 59:\n        raise ValueError(f\"Minute must be 0-59, got {minute}\")\n    if not 0 &lt;= second &lt;= 59:\n        raise ValueError(f\"Second must be 0-59, got {second}\")\n    if not 0 &lt;= microsecond &lt;= 999999:\n        raise ValueError(f\"Microsecond must be 0-999999, got {microsecond}\")\n    if not 0 &lt;= nanosecond &lt;= 999:\n        raise ValueError(f\"Nanosecond must be 0-999, got {nanosecond}\")\n\n    self._year = year\n    self._month = month\n    self._day = day\n    self._hour = hour\n    self._minute = minute\n    self._second = second\n    self._microsecond = microsecond\n    self._nanosecond = nanosecond\n    self._tzinfo = tzinfo\n    self._gregorian_cache: pd.Timestamp | None = None\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.__le__","title":"__le__","text":"<pre><code>__le__(other: JalaliTimestamp) -&gt; bool\n</code></pre> <p>Less than or equal comparison.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def __le__(self, other: JalaliTimestamp) -&gt; bool:\n    \"\"\"Less than or equal comparison.\"\"\"\n    if not isinstance(other, JalaliTimestamp):\n        return NotImplemented\n    return self.to_gregorian() &lt;= other.to_gregorian()\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: JalaliTimestamp) -&gt; bool\n</code></pre> <p>Less than comparison.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def __lt__(self, other: JalaliTimestamp) -&gt; bool:\n    \"\"\"Less than comparison.\"\"\"\n    if not isinstance(other, JalaliTimestamp):\n        return NotImplemented\n    return self.to_gregorian() &lt; other.to_gregorian()\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.__ne__","title":"__ne__","text":"<pre><code>__ne__(other: object) -&gt; bool\n</code></pre> <p>Check inequality.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def __ne__(self, other: object) -&gt; bool:\n    \"\"\"Check inequality.\"\"\"\n    return not self.__eq__(other)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.__radd__","title":"__radd__","text":"<pre><code>__radd__(other: timedelta | Timedelta) -&gt; JalaliTimestamp\n</code></pre> <p>Right add timedelta to timestamp.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def __radd__(self, other: timedelta | pd.Timedelta) -&gt; JalaliTimestamp:\n    \"\"\"Right add timedelta to timestamp.\"\"\"\n    return self.__add__(other)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Detailed string representation.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Detailed string representation.\"\"\"\n    tz_str = f\", tz='{self._tzinfo}'\" if self._tzinfo else \"\"\n    return f\"JalaliTimestamp('{self.isoformat()}'{tz_str})\"\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Human-readable string representation.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Human-readable string representation.\"\"\"\n    return self.isoformat(sep=\" \")\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: JalaliTimestamp | timedelta | Timedelta) -&gt; JalaliTimestamp | pd.Timedelta\n</code></pre> <p>Subtract timedelta or another timestamp.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def __sub__(\n    self, other: JalaliTimestamp | timedelta | pd.Timedelta\n) -&gt; JalaliTimestamp | pd.Timedelta:\n    \"\"\"Subtract timedelta or another timestamp.\"\"\"\n    if isinstance(other, JalaliTimestamp):\n        return self.to_gregorian() - other.to_gregorian()\n    if isinstance(other, (timedelta, pd.Timedelta)):\n        new_gregorian = self.to_gregorian() - other\n        return JalaliTimestamp.from_gregorian(new_gregorian)\n    return NotImplemented\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.date","title":"date","text":"<pre><code>date() -&gt; JalaliTimestamp\n</code></pre> <p>Return date part only (time set to midnight).</p> <p>Returns:</p> Type Description <code>JalaliTimestamp</code> <p>New JalaliTimestamp at midnight.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def date(self) -&gt; JalaliTimestamp:\n    \"\"\"Return date part only (time set to midnight).\n\n    Returns:\n        New JalaliTimestamp at midnight.\n    \"\"\"\n    return self.normalize()\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.from_gregorian","title":"from_gregorian  <code>classmethod</code>","text":"<pre><code>from_gregorian(ts: Timestamp | datetime | str, tz: tzinfo | str | None = None) -&gt; JalaliTimestamp\n</code></pre> <p>Create JalaliTimestamp from Gregorian datetime.</p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>Timestamp | datetime | str</code> <p>Gregorian timestamp (pandas Timestamp, datetime, or string).</p> required <code>tz</code> <code>tzinfo | str | None</code> <p>Timezone to use. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>JalaliTimestamp</code> <p>Equivalent JalaliTimestamp.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>@classmethod\ndef from_gregorian(\n    cls,\n    ts: pd.Timestamp | datetime | str,\n    tz: dt_tzinfo | str | None = None,\n) -&gt; JalaliTimestamp:\n    \"\"\"Create JalaliTimestamp from Gregorian datetime.\n\n    Args:\n        ts: Gregorian timestamp (pandas Timestamp, datetime, or string).\n        tz: Timezone to use. Defaults to None.\n\n    Returns:\n        Equivalent JalaliTimestamp.\n    \"\"\"\n    if (\n        isinstance(ts, str)\n        or isinstance(ts, datetime)\n        and not isinstance(ts, pd.Timestamp)\n    ):\n        ts = pd.Timestamp(ts)\n\n    if tz is not None:\n        ts = ts.tz_localize(tz) if ts.tzinfo is None else ts.tz_convert(tz)\n\n    jalali = jdatetime.datetime.fromgregorian(datetime=ts.to_pydatetime())\n\n    return cls(\n        year=jalali.year,\n        month=jalali.month,\n        day=jalali.day,\n        hour=jalali.hour,\n        minute=jalali.minute,\n        second=jalali.second,\n        microsecond=jalali.microsecond,\n        nanosecond=ts.nanosecond,\n        tzinfo=ts.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.isoformat","title":"isoformat","text":"<pre><code>isoformat(sep: str = 'T') -&gt; str\n</code></pre> <p>Return ISO 8601 formatted string.</p> <p>Parameters:</p> Name Type Description Default <code>sep</code> <code>str</code> <p>Separator between date and time. Defaults to 'T'.</p> <code>'T'</code> <p>Returns:</p> Type Description <code>str</code> <p>ISO formatted string.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def isoformat(self, sep: str = \"T\") -&gt; str:\n    \"\"\"Return ISO 8601 formatted string.\n\n    Args:\n        sep: Separator between date and time. Defaults to 'T'.\n\n    Returns:\n        ISO formatted string.\n    \"\"\"\n    date_part = f\"{self._year:04d}-{self._month:02d}-{self._day:02d}\"\n    time_part = f\"{self._hour:02d}:{self._minute:02d}:{self._second:02d}\"\n\n    if self._microsecond or self._nanosecond:\n        time_part += f\".{self._microsecond:06d}\"\n\n    result = f\"{date_part}{sep}{time_part}\"\n\n    if self._tzinfo is not None:\n        # Get timezone offset\n        offset = self._tzinfo.utcoffset(None)\n        if offset is not None:\n            total_seconds = int(offset.total_seconds())\n            hours, remainder = divmod(abs(total_seconds), 3600)\n            minutes = remainder // 60\n            sign = \"+\" if total_seconds &gt;= 0 else \"-\"\n            result += f\"{sign}{hours:02d}:{minutes:02d}\"\n\n    return result\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.normalize","title":"normalize","text":"<pre><code>normalize() -&gt; JalaliTimestamp\n</code></pre> <p>Return timestamp with time set to midnight.</p> <p>Returns:</p> Type Description <code>JalaliTimestamp</code> <p>New JalaliTimestamp at midnight.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def normalize(self) -&gt; JalaliTimestamp:\n    \"\"\"Return timestamp with time set to midnight.\n\n    Returns:\n        New JalaliTimestamp at midnight.\n    \"\"\"\n    return self.replace(hour=0, minute=0, second=0, microsecond=0, nanosecond=0)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.now","title":"now  <code>classmethod</code>","text":"<pre><code>now(tz: tzinfo | str | None = None) -&gt; JalaliTimestamp\n</code></pre> <p>Get current JalaliTimestamp.</p> <p>Parameters:</p> Name Type Description Default <code>tz</code> <code>tzinfo | str | None</code> <p>Timezone. Defaults to None (local time).</p> <code>None</code> <p>Returns:</p> Type Description <code>JalaliTimestamp</code> <p>Current time as JalaliTimestamp.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>@classmethod\ndef now(cls, tz: dt_tzinfo | str | None = None) -&gt; JalaliTimestamp:\n    \"\"\"Get current JalaliTimestamp.\n\n    Args:\n        tz: Timezone. Defaults to None (local time).\n\n    Returns:\n        Current time as JalaliTimestamp.\n    \"\"\"\n    return cls.from_gregorian(pd.Timestamp.now(tz=tz))\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.replace","title":"replace","text":"<pre><code>replace(year: int | None = None, month: int | None = None, day: int | None = None, hour: int | None = None, minute: int | None = None, second: int | None = None, microsecond: int | None = None, nanosecond: int | None = None, tzinfo: tzinfo | None | object = ...) -&gt; JalaliTimestamp\n</code></pre> <p>Return timestamp with replaced components.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int | None</code> <p>New year (or None to keep current).</p> <code>None</code> <code>month</code> <code>int | None</code> <p>New month (or None to keep current).</p> <code>None</code> <code>day</code> <code>int | None</code> <p>New day (or None to keep current).</p> <code>None</code> <code>hour</code> <code>int | None</code> <p>New hour (or None to keep current).</p> <code>None</code> <code>minute</code> <code>int | None</code> <p>New minute (or None to keep current).</p> <code>None</code> <code>second</code> <code>int | None</code> <p>New second (or None to keep current).</p> <code>None</code> <code>microsecond</code> <code>int | None</code> <p>New microsecond (or None to keep current).</p> <code>None</code> <code>nanosecond</code> <code>int | None</code> <p>New nanosecond (or None to keep current).</p> <code>None</code> <code>tzinfo</code> <code>tzinfo | None | object</code> <p>New timezone (or ... to keep current).</p> <code>...</code> <p>Returns:</p> Type Description <code>JalaliTimestamp</code> <p>New JalaliTimestamp with replaced components.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def replace(\n    self,\n    year: int | None = None,\n    month: int | None = None,\n    day: int | None = None,\n    hour: int | None = None,\n    minute: int | None = None,\n    second: int | None = None,\n    microsecond: int | None = None,\n    nanosecond: int | None = None,\n    tzinfo: dt_tzinfo | None | object = ...,\n) -&gt; JalaliTimestamp:\n    \"\"\"Return timestamp with replaced components.\n\n    Args:\n        year: New year (or None to keep current).\n        month: New month (or None to keep current).\n        day: New day (or None to keep current).\n        hour: New hour (or None to keep current).\n        minute: New minute (or None to keep current).\n        second: New second (or None to keep current).\n        microsecond: New microsecond (or None to keep current).\n        nanosecond: New nanosecond (or None to keep current).\n        tzinfo: New timezone (or ... to keep current).\n\n    Returns:\n        New JalaliTimestamp with replaced components.\n    \"\"\"\n    return JalaliTimestamp(\n        year=year if year is not None else self._year,\n        month=month if month is not None else self._month,\n        day=day if day is not None else self._day,\n        hour=hour if hour is not None else self._hour,\n        minute=minute if minute is not None else self._minute,\n        second=second if second is not None else self._second,\n        microsecond=microsecond if microsecond is not None else self._microsecond,\n        nanosecond=nanosecond if nanosecond is not None else self._nanosecond,\n        tzinfo=self._tzinfo if tzinfo is ... else cast(Optional[dt_tzinfo], tzinfo),\n    )\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.strftime","title":"strftime","text":"<pre><code>strftime(fmt: str) -&gt; str\n</code></pre> <p>Format timestamp as string.</p> <p>Supports standard strftime codes adapted for Jalali calendar.</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>str</code> <p>Format string.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Formatted string.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def strftime(self, fmt: str) -&gt; str:\n    \"\"\"Format timestamp as string.\n\n    Supports standard strftime codes adapted for Jalali calendar.\n\n    Args:\n        fmt: Format string.\n\n    Returns:\n        Formatted string.\n    \"\"\"\n    replacements = {\n        \"%Y\": f\"{self._year:04d}\",\n        \"%y\": f\"{self._year % 100:02d}\",\n        \"%m\": f\"{self._month:02d}\",\n        \"%d\": f\"{self._day:02d}\",\n        \"%H\": f\"{self._hour:02d}\",\n        \"%M\": f\"{self._minute:02d}\",\n        \"%S\": f\"{self._second:02d}\",\n        \"%f\": f\"{self._microsecond:06d}\",\n        \"%j\": f\"{self.dayofyear:03d}\",\n        \"%W\": f\"{self.week:02d}\",\n        \"%w\": str(self.dayofweek),\n    }\n\n    result = fmt\n    for code, value in replacements.items():\n        result = result.replace(code, value)\n\n    return result\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.strptime","title":"strptime  <code>classmethod</code>","text":"<pre><code>strptime(date_string: str, fmt: str) -&gt; JalaliTimestamp\n</code></pre> <p>Parse string to JalaliTimestamp.</p> <p>Parameters:</p> Name Type Description Default <code>date_string</code> <code>str</code> <p>Date string to parse.</p> required <code>fmt</code> <code>str</code> <p>Format string.</p> required <p>Returns:</p> Type Description <code>JalaliTimestamp</code> <p>Parsed JalaliTimestamp.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>@classmethod\ndef strptime(cls, date_string: str, fmt: str) -&gt; JalaliTimestamp:\n    \"\"\"Parse string to JalaliTimestamp.\n\n    Args:\n        date_string: Date string to parse.\n        fmt: Format string.\n\n    Returns:\n        Parsed JalaliTimestamp.\n    \"\"\"\n    # Simple implementation for common formats\n    import re\n\n    # Build regex pattern from format string\n    pattern = fmt\n    groups: dict[str, str] = {}\n\n    replacements = [\n        (\"%Y\", r\"(?P&lt;year&gt;\\d{4})\", \"year\"),\n        (\"%y\", r\"(?P&lt;year2&gt;\\d{2})\", \"year2\"),\n        (\"%m\", r\"(?P&lt;month&gt;\\d{1,2})\", \"month\"),\n        (\"%d\", r\"(?P&lt;day&gt;\\d{1,2})\", \"day\"),\n        (\"%H\", r\"(?P&lt;hour&gt;\\d{1,2})\", \"hour\"),\n        (\"%M\", r\"(?P&lt;minute&gt;\\d{1,2})\", \"minute\"),\n        (\"%S\", r\"(?P&lt;second&gt;\\d{1,2})\", \"second\"),\n    ]\n\n    for code, regex, name in replacements:\n        if code in pattern:\n            pattern = pattern.replace(code, regex)\n            groups[name] = \"\"\n\n    match = re.match(pattern, date_string)\n    if not match:\n        raise ValueError(f\"Cannot parse '{date_string}' with format '{fmt}'\")\n\n    data = match.groupdict()\n\n    year = int(data.get(\"year\", 0) or data.get(\"year2\", 0))\n    if \"year2\" in data and data[\"year2\"]:\n        year = 1300 + year if year &lt; 100 else year\n\n    return cls(\n        year=year,\n        month=int(data.get(\"month\", 1)),\n        day=int(data.get(\"day\", 1)),\n        hour=int(data.get(\"hour\", 0)),\n        minute=int(data.get(\"minute\", 0)),\n        second=int(data.get(\"second\", 0)),\n    )\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.time","title":"time","text":"<pre><code>time() -&gt; time\n</code></pre> <p>Return time part as Python time object.</p> <p>Returns:</p> Type Description <code>time</code> <p>Python time object.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def time(self) -&gt; time:\n    \"\"\"Return time part as Python time object.\n\n    Returns:\n        Python time object.\n    \"\"\"\n    return time(\n        hour=self._hour,\n        minute=self._minute,\n        second=self._second,\n        microsecond=self._microsecond,\n        tzinfo=self._tzinfo,\n    )\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.to_datetime64","title":"to_datetime64","text":"<pre><code>to_datetime64() -&gt; np.datetime64\n</code></pre> <p>Convert to numpy datetime64.</p> <p>Returns:</p> Type Description <code>datetime64</code> <p>Equivalent numpy datetime64.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def to_datetime64(self) -&gt; np.datetime64:\n    \"\"\"Convert to numpy datetime64.\n\n    Returns:\n        Equivalent numpy datetime64.\n    \"\"\"\n    return self.to_gregorian().to_datetime64()\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.to_gregorian","title":"to_gregorian","text":"<pre><code>to_gregorian() -&gt; pd.Timestamp\n</code></pre> <p>Convert to pandas Timestamp (Gregorian).</p> <p>Returns:</p> Type Description <code>Timestamp</code> <p>Equivalent pandas Timestamp in Gregorian calendar.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def to_gregorian(self) -&gt; pd.Timestamp:\n    \"\"\"Convert to pandas Timestamp (Gregorian).\n\n    Returns:\n        Equivalent pandas Timestamp in Gregorian calendar.\n    \"\"\"\n    if self._gregorian_cache is not None:\n        return self._gregorian_cache\n\n    gregorian = jdatetime.datetime(\n        self._year,\n        self._month,\n        self._day,\n        self._hour,\n        self._minute,\n        self._second,\n        self._microsecond,\n    ).togregorian()\n    ts = pd.Timestamp(\n        year=gregorian.year,\n        month=gregorian.month,\n        day=gregorian.day,\n        hour=gregorian.hour,\n        minute=gregorian.minute,\n        second=gregorian.second,\n        microsecond=gregorian.microsecond,\n        nanosecond=self._nanosecond,\n        tz=self._tzinfo,\n    )\n\n    self._gregorian_cache = ts\n    return ts\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.to_pydatetime","title":"to_pydatetime","text":"<pre><code>to_pydatetime() -&gt; datetime\n</code></pre> <p>Convert to Python datetime (Gregorian).</p> <p>Returns:</p> Type Description <code>datetime</code> <p>Equivalent Python datetime in Gregorian calendar.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def to_pydatetime(self) -&gt; datetime:\n    \"\"\"Convert to Python datetime (Gregorian).\n\n    Returns:\n        Equivalent Python datetime in Gregorian calendar.\n    \"\"\"\n    return self.to_gregorian().to_pydatetime()\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.today","title":"today  <code>classmethod</code>","text":"<pre><code>today() -&gt; JalaliTimestamp\n</code></pre> <p>Get today's date as JalaliTimestamp (midnight).</p> <p>Returns:</p> Type Description <code>JalaliTimestamp</code> <p>Today's date as JalaliTimestamp.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>@classmethod\ndef today(cls) -&gt; JalaliTimestamp:\n    \"\"\"Get today's date as JalaliTimestamp (midnight).\n\n    Returns:\n        Today's date as JalaliTimestamp.\n    \"\"\"\n    now = cls.now()\n    return cls(now.year, now.month, now.day)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.tz_convert","title":"tz_convert","text":"<pre><code>tz_convert(tz: tzinfo | str | None) -&gt; JalaliTimestamp\n</code></pre> <p>Convert tz-aware timestamp to another timezone.</p> <p>Parameters:</p> Name Type Description Default <code>tz</code> <code>tzinfo | str | None</code> <p>Target timezone. Can be a timezone object or string.</p> required <p>Returns:</p> Type Description <code>JalaliTimestamp</code> <p>New JalaliTimestamp in the target timezone.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If timestamp is tz-naive.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def tz_convert(self, tz: dt_tzinfo | str | None) -&gt; JalaliTimestamp:\n    \"\"\"Convert tz-aware timestamp to another timezone.\n\n    Args:\n        tz: Target timezone. Can be a timezone object or string.\n\n    Returns:\n        New JalaliTimestamp in the target timezone.\n\n    Raises:\n        TypeError: If timestamp is tz-naive.\n    \"\"\"\n    if self._tzinfo is None:\n        raise TypeError(\n            \"Cannot convert tz-naive timestamp. \"\n            \"Use tz_localize() first to add timezone.\"\n        )\n\n    # Convert to Gregorian, convert timezone, then convert back to Jalali\n    gregorian = self.to_gregorian()\n    converted = gregorian.tz_convert(tz)\n\n    # Convert the new Gregorian time back to Jalali\n    return JalaliTimestamp.from_gregorian(converted)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.JalaliTimestamp.tz_localize","title":"tz_localize","text":"<pre><code>tz_localize(tz: tzinfo | str | None, ambiguous: str = 'raise', nonexistent: str = 'raise') -&gt; JalaliTimestamp\n</code></pre> <p>Localize tz-naive timestamp to a timezone.</p> <p>Parameters:</p> Name Type Description Default <code>tz</code> <code>tzinfo | str | None</code> <p>Timezone to localize to. Can be a timezone object or string.</p> required <code>ambiguous</code> <code>str</code> <p>How to handle ambiguous times. Defaults to 'raise'.</p> <code>'raise'</code> <code>nonexistent</code> <code>str</code> <p>How to handle nonexistent times. Defaults to 'raise'.</p> <code>'raise'</code> <p>Returns:</p> Type Description <code>JalaliTimestamp</code> <p>New JalaliTimestamp with timezone.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If timestamp is already tz-aware.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def tz_localize(\n    self,\n    tz: dt_tzinfo | str | None,\n    ambiguous: str = \"raise\",\n    nonexistent: str = \"raise\",\n) -&gt; JalaliTimestamp:\n    \"\"\"Localize tz-naive timestamp to a timezone.\n\n    Args:\n        tz: Timezone to localize to. Can be a timezone object or string.\n        ambiguous: How to handle ambiguous times. Defaults to 'raise'.\n        nonexistent: How to handle nonexistent times. Defaults to 'raise'.\n\n    Returns:\n        New JalaliTimestamp with timezone.\n\n    Raises:\n        TypeError: If timestamp is already tz-aware.\n    \"\"\"\n    if self._tzinfo is not None:\n        raise TypeError(\n            \"Cannot localize tz-aware timestamp. \"\n            \"Use tz_convert() to convert between timezones.\"\n        )\n\n    # Convert to Gregorian, localize, then convert back\n    gregorian = self.to_gregorian()\n    localized = gregorian.tz_localize(\n        tz, ambiguous=ambiguous, nonexistent=nonexistent\n    )\n\n    # Create new JalaliTimestamp with the timezone\n    return JalaliTimestamp(\n        year=self._year,\n        month=self._month,\n        day=self._day,\n        hour=self._hour,\n        minute=self._minute,\n        second=self._second,\n        microsecond=self._microsecond,\n        nanosecond=self._nanosecond,\n        tzinfo=localized.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.timestamp.isna_jalali","title":"isna_jalali","text":"<pre><code>isna_jalali(value: object) -&gt; bool\n</code></pre> <p>Check if a value is JalaliNaT or pandas NaT.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>object</code> <p>Value to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if value is NaT.</p> Source code in <code>jalali_pandas/core/timestamp.py</code> <pre><code>def isna_jalali(value: object) -&gt; bool:\n    \"\"\"Check if a value is JalaliNaT or pandas NaT.\n\n    Args:\n        value: Value to check.\n\n    Returns:\n        True if value is NaT.\n    \"\"\"\n    return isinstance(value, _JalaliNaTType) or value is pd.NaT or pd.isna(value)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.dtypes.JalaliDatetimeDtype","title":"JalaliDatetimeDtype","text":"<p>               Bases: <code>ExtensionDtype</code></p> <p>ExtensionDtype for Jalali datetime data.</p> <p>This dtype represents Jalali (Persian/Shamsi) calendar datetimes and integrates with pandas' ExtensionArray system.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>String identifier for the dtype.</p> <code>type</code> <p>The scalar type for the array.</p> <code>na_value</code> <p>The missing value sentinel.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dtype = JalaliDatetimeDtype()\n&gt;&gt;&gt; dtype.name\n'jalali_datetime'\n&gt;&gt;&gt; pd.array([...], dtype='jalali_datetime')\n</code></pre> Source code in <code>jalali_pandas/core/dtypes.py</code> <pre><code>@register_extension_dtype\nclass JalaliDatetimeDtype(ExtensionDtype):\n    \"\"\"ExtensionDtype for Jalali datetime data.\n\n    This dtype represents Jalali (Persian/Shamsi) calendar datetimes\n    and integrates with pandas' ExtensionArray system.\n\n    Attributes:\n        name: String identifier for the dtype.\n        type: The scalar type for the array.\n        na_value: The missing value sentinel.\n\n    Examples:\n        &gt;&gt;&gt; dtype = JalaliDatetimeDtype()\n        &gt;&gt;&gt; dtype.name\n        'jalali_datetime'\n        &gt;&gt;&gt; pd.array([...], dtype='jalali_datetime')\n    \"\"\"\n\n    name = \"jalali_datetime\"\n    type = object  # Will be JalaliTimestamp\n    na_value = pd.NaT\n    _metadata: tuple[str, ...] = (\"tz\",)\n\n    def __init__(self, tz: str | None = None) -&gt; None:\n        \"\"\"Initialize JalaliDatetimeDtype.\n\n        Args:\n            tz: Timezone string (e.g., 'Asia/Tehran'). Defaults to None.\n        \"\"\"\n        self._tz = tz\n\n    @property\n    def tz(self) -&gt; str | None:\n        \"\"\"Timezone for this dtype.\"\"\"\n        return self._tz\n\n    @classmethod\n    def construct_array_type(cls) -&gt; builtins.type[JalaliDatetimeArray]:\n        \"\"\"Return the array type associated with this dtype.\n\n        Returns:\n            JalaliDatetimeArray class.\n        \"\"\"\n        from jalali_pandas.core.arrays import JalaliDatetimeArray\n\n        return JalaliDatetimeArray\n\n    @classmethod\n    def construct_from_string(cls, string: str) -&gt; JalaliDatetimeDtype:\n        \"\"\"Construct dtype from a string.\n\n        Args:\n            string: String representation of the dtype.\n\n        Returns:\n            JalaliDatetimeDtype instance.\n\n        Raises:\n            TypeError: If string doesn't match expected format.\n        \"\"\"\n        if not isinstance(string, str):\n            raise TypeError(f\"Expected string, got {type(string)}\")\n\n        if string == cls.name:\n            return cls()\n\n        # Handle timezone specification: jalali_datetime[tz]\n        if string.startswith(f\"{cls.name}[\") and string.endswith(\"]\"):\n            tz = string[len(cls.name) + 1 : -1]\n            return cls(tz=tz if tz else None)\n\n        raise TypeError(f\"Cannot construct {cls.__name__} from '{string}'\")\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation.\"\"\"\n        if self._tz:\n            return f\"{self.name}[{self._tz}]\"\n        return self.name\n\n    def __str__(self) -&gt; str:\n        \"\"\"String representation.\"\"\"\n        return self.__repr__()\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Hash for use in sets and dicts.\"\"\"\n        return hash((self.name, self._tz))\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality with another dtype.\"\"\"\n        if isinstance(other, str):\n            try:\n                other = self.construct_from_string(other)\n            except TypeError:\n                return False\n\n        if isinstance(other, JalaliDatetimeDtype):\n            return self._tz == other._tz\n\n        return False\n\n    @property\n    def _is_numeric(self) -&gt; bool:\n        \"\"\"Whether this dtype is numeric.\"\"\"\n        return False\n\n    @property\n    def _is_boolean(self) -&gt; bool:\n        \"\"\"Whether this dtype is boolean.\"\"\"\n        return False\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.dtypes.JalaliDatetimeDtype.tz","title":"tz  <code>property</code>","text":"<pre><code>tz: str | None\n</code></pre> <p>Timezone for this dtype.</p>"},{"location":"en/api/core/#jalali_pandas.core.dtypes.JalaliDatetimeDtype.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality with another dtype.</p> Source code in <code>jalali_pandas/core/dtypes.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality with another dtype.\"\"\"\n    if isinstance(other, str):\n        try:\n            other = self.construct_from_string(other)\n        except TypeError:\n            return False\n\n    if isinstance(other, JalaliDatetimeDtype):\n        return self._tz == other._tz\n\n    return False\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.dtypes.JalaliDatetimeDtype.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Hash for use in sets and dicts.</p> Source code in <code>jalali_pandas/core/dtypes.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Hash for use in sets and dicts.\"\"\"\n    return hash((self.name, self._tz))\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.dtypes.JalaliDatetimeDtype.__init__","title":"__init__","text":"<pre><code>__init__(tz: str | None = None) -&gt; None\n</code></pre> <p>Initialize JalaliDatetimeDtype.</p> <p>Parameters:</p> Name Type Description Default <code>tz</code> <code>str | None</code> <p>Timezone string (e.g., 'Asia/Tehran'). Defaults to None.</p> <code>None</code> Source code in <code>jalali_pandas/core/dtypes.py</code> <pre><code>def __init__(self, tz: str | None = None) -&gt; None:\n    \"\"\"Initialize JalaliDatetimeDtype.\n\n    Args:\n        tz: Timezone string (e.g., 'Asia/Tehran'). Defaults to None.\n    \"\"\"\n    self._tz = tz\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.dtypes.JalaliDatetimeDtype.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>String representation.</p> Source code in <code>jalali_pandas/core/dtypes.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"String representation.\"\"\"\n    if self._tz:\n        return f\"{self.name}[{self._tz}]\"\n    return self.name\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.dtypes.JalaliDatetimeDtype.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>String representation.</p> Source code in <code>jalali_pandas/core/dtypes.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"String representation.\"\"\"\n    return self.__repr__()\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.dtypes.JalaliDatetimeDtype.construct_array_type","title":"construct_array_type  <code>classmethod</code>","text":"<pre><code>construct_array_type() -&gt; builtins.type[JalaliDatetimeArray]\n</code></pre> <p>Return the array type associated with this dtype.</p> <p>Returns:</p> Type Description <code>type[JalaliDatetimeArray]</code> <p>JalaliDatetimeArray class.</p> Source code in <code>jalali_pandas/core/dtypes.py</code> <pre><code>@classmethod\ndef construct_array_type(cls) -&gt; builtins.type[JalaliDatetimeArray]:\n    \"\"\"Return the array type associated with this dtype.\n\n    Returns:\n        JalaliDatetimeArray class.\n    \"\"\"\n    from jalali_pandas.core.arrays import JalaliDatetimeArray\n\n    return JalaliDatetimeArray\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.dtypes.JalaliDatetimeDtype.construct_from_string","title":"construct_from_string  <code>classmethod</code>","text":"<pre><code>construct_from_string(string: str) -&gt; JalaliDatetimeDtype\n</code></pre> <p>Construct dtype from a string.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>String representation of the dtype.</p> required <p>Returns:</p> Type Description <code>JalaliDatetimeDtype</code> <p>JalaliDatetimeDtype instance.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If string doesn't match expected format.</p> Source code in <code>jalali_pandas/core/dtypes.py</code> <pre><code>@classmethod\ndef construct_from_string(cls, string: str) -&gt; JalaliDatetimeDtype:\n    \"\"\"Construct dtype from a string.\n\n    Args:\n        string: String representation of the dtype.\n\n    Returns:\n        JalaliDatetimeDtype instance.\n\n    Raises:\n        TypeError: If string doesn't match expected format.\n    \"\"\"\n    if not isinstance(string, str):\n        raise TypeError(f\"Expected string, got {type(string)}\")\n\n    if string == cls.name:\n        return cls()\n\n    # Handle timezone specification: jalali_datetime[tz]\n    if string.startswith(f\"{cls.name}[\") and string.endswith(\"]\"):\n        tz = string[len(cls.name) + 1 : -1]\n        return cls(tz=tz if tz else None)\n\n    raise TypeError(f\"Cannot construct {cls.__name__} from '{string}'\")\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray","title":"JalaliDatetimeArray","text":"<p>               Bases: <code>ExtensionArray</code></p> <p>ExtensionArray for Jalali datetime data.</p> <p>This array stores Jalali timestamps and integrates with pandas' ExtensionArray system for seamless DataFrame/Series operations.</p> <p>Attributes:</p> Name Type Description <code>dtype</code> <code>JalaliDatetimeDtype</code> <p>The JalaliDatetimeDtype for this array.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; arr = JalaliDatetimeArray._from_sequence([\n...     JalaliTimestamp(1402, 1, 1),\n...     JalaliTimestamp(1402, 1, 2),\n... ])\n&gt;&gt;&gt; arr[0]\nJalaliTimestamp('1402-01-01T00:00:00')\n</code></pre> Source code in <code>jalali_pandas/core/arrays.py</code> <pre><code>class JalaliDatetimeArray(ExtensionArray):\n    \"\"\"ExtensionArray for Jalali datetime data.\n\n    This array stores Jalali timestamps and integrates with pandas'\n    ExtensionArray system for seamless DataFrame/Series operations.\n\n    Attributes:\n        dtype: The JalaliDatetimeDtype for this array.\n\n    Examples:\n        &gt;&gt;&gt; arr = JalaliDatetimeArray._from_sequence([\n        ...     JalaliTimestamp(1402, 1, 1),\n        ...     JalaliTimestamp(1402, 1, 2),\n        ... ])\n        &gt;&gt;&gt; arr[0]\n        JalaliTimestamp('1402-01-01T00:00:00')\n    \"\"\"\n\n    _dtype: JalaliDatetimeDtype\n    _data: npt.NDArray[np.object_]  # Object array of JalaliTimestamp or NaT\n\n    def __init__(\n        self,\n        data: np.ndarray,\n        dtype: JalaliDatetimeDtype | None = None,\n        copy: bool = False,\n    ) -&gt; None:\n        \"\"\"Initialize JalaliDatetimeArray.\n\n        Args:\n            data: Array of JalaliTimestamp objects.\n            dtype: JalaliDatetimeDtype instance. Defaults to None.\n            copy: Whether to copy the data. Defaults to False.\n        \"\"\"\n        if copy:\n            data = data.copy()\n\n        self._data = data\n        self._dtype = dtype if dtype is not None else JalaliDatetimeDtype()\n\n    @property\n    def dtype(self) -&gt; JalaliDatetimeDtype:\n        \"\"\"Return the dtype for this array.\"\"\"\n        return self._dtype\n\n    @property\n    def nbytes(self) -&gt; int:\n        \"\"\"Return the number of bytes in the array.\"\"\"\n        return int(self._data.nbytes)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the length of the array.\"\"\"\n        return len(self._data)\n\n    @overload\n    def __getitem__(self, key: int) -&gt; JalaliTimestamp | NaTType: ...\n\n    @overload\n    def __getitem__(\n        self, key: slice | Sequence[int] | npt.NDArray[np.bool_]\n    ) -&gt; JalaliDatetimeArray: ...\n\n    def __getitem__(self, key: Any) -&gt; Any:\n        \"\"\"Get item(s) from the array.\"\"\"\n        result = self._data[key]\n\n        if isinstance(result, np.ndarray):\n            return type(self)(cast(npt.NDArray[np.object_], result), dtype=self._dtype)\n\n        return result\n\n    def __setitem__(self, key: Any, value: Any) -&gt; None:\n        \"\"\"Set item(s) in the array.\"\"\"\n        if isinstance(value, JalaliTimestamp):\n            self._data[key] = value\n        elif isinstance(value, JalaliDatetimeArray):\n            self._data[key] = value._data\n        elif isinstance(value, (list, np.ndarray)):\n            values = self._from_sequence(cast(Sequence[Any], value), dtype=self._dtype)\n            self._data[key] = values._data\n        elif pd.isna(value):\n            self._data[key] = pd.NaT\n        else:\n            raise TypeError(f\"Cannot set {type(value)} in JalaliDatetimeArray\")\n\n    def __iter__(self) -&gt; Iterator[Any]:\n        \"\"\"Iterate over the array.\"\"\"\n        return iter(self._data)\n\n    def __eq__(self, other: Any) -&gt; Any:\n        \"\"\"Element-wise equality comparison.\"\"\"\n        if isinstance(other, JalaliDatetimeArray):\n            return cast(npt.NDArray[np.bool_], self._data == other._data)\n        if isinstance(other, JalaliTimestamp):\n            return cast(\n                npt.NDArray[np.bool_],\n                np.array([x == other for x in self._data], dtype=bool),\n            )\n        return NotImplemented\n\n    def __ne__(self, other: Any) -&gt; Any:\n        \"\"\"Element-wise inequality comparison.\"\"\"\n        result = self.__eq__(other)\n        if result is NotImplemented:\n            return result\n        return ~result\n\n    @classmethod\n    def _from_sequence(\n        cls,\n        scalars: Sequence[Any],\n        *,\n        dtype: JalaliDatetimeDtype | None = None,\n        copy: bool = False,\n    ) -&gt; JalaliDatetimeArray:\n        \"\"\"Create array from sequence of scalars.\n\n        Args:\n            scalars: Sequence of JalaliTimestamp, strings, or NaT values.\n            dtype: JalaliDatetimeDtype instance.\n            copy: Whether to copy the data.\n\n        Returns:\n            JalaliDatetimeArray instance.\n        \"\"\"\n        result: list[JalaliTimestamp | NaTType] = []\n        for scalar in scalars:\n            if isinstance(scalar, JalaliTimestamp):\n                result.append(scalar)\n            elif pd.isna(scalar):\n                result.append(pd.NaT)\n            elif isinstance(scalar, str):\n                # Try to parse string\n                try:\n                    result.append(JalaliTimestamp.strptime(scalar, \"%Y-%m-%d\"))\n                except ValueError:\n                    try:\n                        result.append(\n                            JalaliTimestamp.strptime(scalar, \"%Y-%m-%d %H:%M:%S\")\n                        )\n                    except ValueError:\n                        result.append(pd.NaT)\n            elif isinstance(scalar, pd.Timestamp):\n                result.append(JalaliTimestamp.from_gregorian(scalar))\n            else:\n                result.append(pd.NaT)\n\n        data = cast(npt.NDArray[np.object_], np.array(result, dtype=object))\n        return cls(data, dtype=dtype, copy=copy)\n\n    @classmethod\n    def _from_sequence_of_strings(\n        cls,\n        strings: Sequence[str],\n        *,\n        dtype: JalaliDatetimeDtype | None = None,\n        copy: bool = False,\n    ) -&gt; JalaliDatetimeArray:\n        \"\"\"Create array from sequence of strings.\n\n        Args:\n            strings: Sequence of date strings.\n            dtype: JalaliDatetimeDtype instance.\n            copy: Whether to copy the data.\n\n        Returns:\n            JalaliDatetimeArray instance.\n        \"\"\"\n        return cls._from_sequence(strings, dtype=dtype, copy=copy)\n\n    @classmethod\n    def _from_factorized(\n        cls, values: npt.NDArray[np.object_], original: JalaliDatetimeArray\n    ) -&gt; JalaliDatetimeArray:\n        \"\"\"Reconstruct array from factorized values.\n\n        Args:\n            values: Unique values array.\n            original: Original array for dtype.\n\n        Returns:\n            JalaliDatetimeArray instance.\n        \"\"\"\n        return cls(values, dtype=original.dtype)\n\n    def _values_for_factorize(self) -&gt; tuple[npt.NDArray[np.object_], NaTType]:\n        \"\"\"Return values and NA value for factorization.\"\"\"\n        return self._data, pd.NaT\n\n    def isna(self) -&gt; npt.NDArray[np.bool_]:\n        \"\"\"Return boolean array indicating NA values.\"\"\"\n        return cast(\n            npt.NDArray[np.bool_],\n            np.array([pd.isna(x) for x in self._data], dtype=bool),\n        )\n\n    def take(\n        self,\n        indices: Sequence[int],\n        *,\n        allow_fill: bool = False,\n        fill_value: Any = None,\n    ) -&gt; JalaliDatetimeArray:\n        \"\"\"Take elements from the array.\n\n        Args:\n            indices: Indices to take.\n            allow_fill: Whether to allow fill values for -1 indices.\n            fill_value: Value to use for -1 indices.\n\n        Returns:\n            JalaliDatetimeArray with taken elements.\n        \"\"\"\n        if allow_fill:\n            if fill_value is None:\n                fill_value = pd.NaT\n\n            result: list[object] = []\n            for i in indices:\n                if i == -1:\n                    result.append(fill_value)\n                else:\n                    result.append(self._data[i])\n            data = cast(npt.NDArray[np.object_], np.array(result, dtype=object))\n        else:\n            data = cast(npt.NDArray[np.object_], self._data[list(indices)])\n\n        return type(self)(data, dtype=self._dtype)\n\n    def copy(self) -&gt; JalaliDatetimeArray:\n        \"\"\"Return a copy of the array.\"\"\"\n        return type(self)(self._data.copy(), dtype=self._dtype)\n\n    @classmethod\n    def _concat_same_type(\n        cls, to_concat: Sequence[JalaliDatetimeArray]\n    ) -&gt; JalaliDatetimeArray:\n        \"\"\"Concatenate arrays of the same type.\n\n        Args:\n            to_concat: Sequence of arrays to concatenate.\n\n        Returns:\n            Concatenated JalaliDatetimeArray.\n        \"\"\"\n        data = cast(\n            npt.NDArray[np.object_], np.concatenate([arr._data for arr in to_concat])\n        )\n        return cls(data, dtype=to_concat[0].dtype)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation.\"\"\"\n        data_repr = \", \".join(repr(x) for x in self._data[:5])\n        if len(self._data) &gt; 5:\n            data_repr += \", ...\"\n        return f\"JalaliDatetimeArray([{data_repr}], dtype={self._dtype})\"\n\n    # -------------------------------------------------------------------------\n    # Jalali-specific methods\n    # -------------------------------------------------------------------------\n\n    @property\n    def year(self) -&gt; npt.NDArray[np.float64]:\n        \"\"\"Return array of years.\"\"\"\n        return cast(\n            npt.NDArray[np.float64],\n            np.array(\n                [x.year if not pd.isna(x) else np.nan for x in self._data],\n                dtype=float,\n            ),\n        )\n\n    @property\n    def month(self) -&gt; npt.NDArray[np.float64]:\n        \"\"\"Return array of months.\"\"\"\n        return cast(\n            npt.NDArray[np.float64],\n            np.array(\n                [x.month if not pd.isna(x) else np.nan for x in self._data],\n                dtype=float,\n            ),\n        )\n\n    @property\n    def day(self) -&gt; npt.NDArray[np.float64]:\n        \"\"\"Return array of days.\"\"\"\n        return cast(\n            npt.NDArray[np.float64],\n            np.array(\n                [x.day if not pd.isna(x) else np.nan for x in self._data],\n                dtype=float,\n            ),\n        )\n\n    @property\n    def hour(self) -&gt; npt.NDArray[np.float64]:\n        \"\"\"Return array of hours.\"\"\"\n        return cast(\n            npt.NDArray[np.float64],\n            np.array(\n                [x.hour if not pd.isna(x) else np.nan for x in self._data],\n                dtype=float,\n            ),\n        )\n\n    @property\n    def minute(self) -&gt; npt.NDArray[np.float64]:\n        \"\"\"Return array of minutes.\"\"\"\n        return cast(\n            npt.NDArray[np.float64],\n            np.array(\n                [x.minute if not pd.isna(x) else np.nan for x in self._data],\n                dtype=float,\n            ),\n        )\n\n    @property\n    def second(self) -&gt; npt.NDArray[np.float64]:\n        \"\"\"Return array of seconds.\"\"\"\n        return cast(\n            npt.NDArray[np.float64],\n            np.array(\n                [x.second if not pd.isna(x) else np.nan for x in self._data],\n                dtype=float,\n            ),\n        )\n\n    @property\n    def quarter(self) -&gt; npt.NDArray[np.float64]:\n        \"\"\"Return array of quarters.\"\"\"\n        return cast(\n            npt.NDArray[np.float64],\n            np.array(\n                [x.quarter if not pd.isna(x) else np.nan for x in self._data],\n                dtype=float,\n            ),\n        )\n\n    @property\n    def dayofweek(self) -&gt; npt.NDArray[np.float64]:\n        \"\"\"Return array of day of week values.\"\"\"\n        return cast(\n            npt.NDArray[np.float64],\n            np.array(\n                [x.dayofweek if not pd.isna(x) else np.nan for x in self._data],\n                dtype=float,\n            ),\n        )\n\n    @property\n    def dayofyear(self) -&gt; npt.NDArray[np.float64]:\n        \"\"\"Return array of day of year values.\"\"\"\n        return cast(\n            npt.NDArray[np.float64],\n            np.array(\n                [x.dayofyear if not pd.isna(x) else np.nan for x in self._data],\n                dtype=float,\n            ),\n        )\n\n    @property\n    def week(self) -&gt; npt.NDArray[np.float64]:\n        \"\"\"Return array of week numbers.\"\"\"\n        return cast(\n            npt.NDArray[np.float64],\n            np.array(\n                [x.week if not pd.isna(x) else np.nan for x in self._data],\n                dtype=float,\n            ),\n        )\n\n    def to_gregorian(self) -&gt; pd.DatetimeIndex:\n        \"\"\"Convert to pandas DatetimeIndex (Gregorian).\n\n        Returns:\n            DatetimeIndex with Gregorian timestamps.\n        \"\"\"\n        timestamps = [\n            x.to_gregorian() if not pd.isna(x) else pd.NaT for x in self._data\n        ]\n        return pd.DatetimeIndex(timestamps)\n\n    def strftime(self, fmt: str) -&gt; npt.NDArray[np.object_]:\n        \"\"\"Format timestamps as strings.\n\n        Args:\n            fmt: Format string.\n\n        Returns:\n            Array of formatted strings.\n        \"\"\"\n        return cast(\n            npt.NDArray[np.object_],\n            np.array(\n                [x.strftime(fmt) if not pd.isna(x) else None for x in self._data],\n                dtype=object,\n            ),\n        )\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.day","title":"day  <code>property</code>","text":"<pre><code>day: NDArray[float64]\n</code></pre> <p>Return array of days.</p>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.dayofweek","title":"dayofweek  <code>property</code>","text":"<pre><code>dayofweek: NDArray[float64]\n</code></pre> <p>Return array of day of week values.</p>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.dayofyear","title":"dayofyear  <code>property</code>","text":"<pre><code>dayofyear: NDArray[float64]\n</code></pre> <p>Return array of day of year values.</p>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: JalaliDatetimeDtype\n</code></pre> <p>Return the dtype for this array.</p>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.hour","title":"hour  <code>property</code>","text":"<pre><code>hour: NDArray[float64]\n</code></pre> <p>Return array of hours.</p>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.minute","title":"minute  <code>property</code>","text":"<pre><code>minute: NDArray[float64]\n</code></pre> <p>Return array of minutes.</p>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.month","title":"month  <code>property</code>","text":"<pre><code>month: NDArray[float64]\n</code></pre> <p>Return array of months.</p>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.nbytes","title":"nbytes  <code>property</code>","text":"<pre><code>nbytes: int\n</code></pre> <p>Return the number of bytes in the array.</p>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.quarter","title":"quarter  <code>property</code>","text":"<pre><code>quarter: NDArray[float64]\n</code></pre> <p>Return array of quarters.</p>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.second","title":"second  <code>property</code>","text":"<pre><code>second: NDArray[float64]\n</code></pre> <p>Return array of seconds.</p>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.week","title":"week  <code>property</code>","text":"<pre><code>week: NDArray[float64]\n</code></pre> <p>Return array of week numbers.</p>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.year","title":"year  <code>property</code>","text":"<pre><code>year: NDArray[float64]\n</code></pre> <p>Return array of years.</p>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; Any\n</code></pre> <p>Element-wise equality comparison.</p> Source code in <code>jalali_pandas/core/arrays.py</code> <pre><code>def __eq__(self, other: Any) -&gt; Any:\n    \"\"\"Element-wise equality comparison.\"\"\"\n    if isinstance(other, JalaliDatetimeArray):\n        return cast(npt.NDArray[np.bool_], self._data == other._data)\n    if isinstance(other, JalaliTimestamp):\n        return cast(\n            npt.NDArray[np.bool_],\n            np.array([x == other for x in self._data], dtype=bool),\n        )\n    return NotImplemented\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: int) -&gt; JalaliTimestamp | NaTType\n</code></pre><pre><code>__getitem__(key: slice | Sequence[int] | NDArray[bool_]) -&gt; JalaliDatetimeArray\n</code></pre> <pre><code>__getitem__(key: Any) -&gt; Any\n</code></pre> <p>Get item(s) from the array.</p> Source code in <code>jalali_pandas/core/arrays.py</code> <pre><code>def __getitem__(self, key: Any) -&gt; Any:\n    \"\"\"Get item(s) from the array.\"\"\"\n    result = self._data[key]\n\n    if isinstance(result, np.ndarray):\n        return type(self)(cast(npt.NDArray[np.object_], result), dtype=self._dtype)\n\n    return result\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.__init__","title":"__init__","text":"<pre><code>__init__(data: ndarray, dtype: JalaliDatetimeDtype | None = None, copy: bool = False) -&gt; None\n</code></pre> <p>Initialize JalaliDatetimeArray.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>Array of JalaliTimestamp objects.</p> required <code>dtype</code> <code>JalaliDatetimeDtype | None</code> <p>JalaliDatetimeDtype instance. Defaults to None.</p> <code>None</code> <code>copy</code> <code>bool</code> <p>Whether to copy the data. Defaults to False.</p> <code>False</code> Source code in <code>jalali_pandas/core/arrays.py</code> <pre><code>def __init__(\n    self,\n    data: np.ndarray,\n    dtype: JalaliDatetimeDtype | None = None,\n    copy: bool = False,\n) -&gt; None:\n    \"\"\"Initialize JalaliDatetimeArray.\n\n    Args:\n        data: Array of JalaliTimestamp objects.\n        dtype: JalaliDatetimeDtype instance. Defaults to None.\n        copy: Whether to copy the data. Defaults to False.\n    \"\"\"\n    if copy:\n        data = data.copy()\n\n    self._data = data\n    self._dtype = dtype if dtype is not None else JalaliDatetimeDtype()\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Iterator[Any]\n</code></pre> <p>Iterate over the array.</p> Source code in <code>jalali_pandas/core/arrays.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Any]:\n    \"\"\"Iterate over the array.\"\"\"\n    return iter(self._data)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the length of the array.</p> Source code in <code>jalali_pandas/core/arrays.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the length of the array.\"\"\"\n    return len(self._data)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.__ne__","title":"__ne__","text":"<pre><code>__ne__(other: Any) -&gt; Any\n</code></pre> <p>Element-wise inequality comparison.</p> Source code in <code>jalali_pandas/core/arrays.py</code> <pre><code>def __ne__(self, other: Any) -&gt; Any:\n    \"\"\"Element-wise inequality comparison.\"\"\"\n    result = self.__eq__(other)\n    if result is NotImplemented:\n        return result\n    return ~result\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>String representation.</p> Source code in <code>jalali_pandas/core/arrays.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"String representation.\"\"\"\n    data_repr = \", \".join(repr(x) for x in self._data[:5])\n    if len(self._data) &gt; 5:\n        data_repr += \", ...\"\n    return f\"JalaliDatetimeArray([{data_repr}], dtype={self._dtype})\"\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(key: Any, value: Any) -&gt; None\n</code></pre> <p>Set item(s) in the array.</p> Source code in <code>jalali_pandas/core/arrays.py</code> <pre><code>def __setitem__(self, key: Any, value: Any) -&gt; None:\n    \"\"\"Set item(s) in the array.\"\"\"\n    if isinstance(value, JalaliTimestamp):\n        self._data[key] = value\n    elif isinstance(value, JalaliDatetimeArray):\n        self._data[key] = value._data\n    elif isinstance(value, (list, np.ndarray)):\n        values = self._from_sequence(cast(Sequence[Any], value), dtype=self._dtype)\n        self._data[key] = values._data\n    elif pd.isna(value):\n        self._data[key] = pd.NaT\n    else:\n        raise TypeError(f\"Cannot set {type(value)} in JalaliDatetimeArray\")\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.copy","title":"copy","text":"<pre><code>copy() -&gt; JalaliDatetimeArray\n</code></pre> <p>Return a copy of the array.</p> Source code in <code>jalali_pandas/core/arrays.py</code> <pre><code>def copy(self) -&gt; JalaliDatetimeArray:\n    \"\"\"Return a copy of the array.\"\"\"\n    return type(self)(self._data.copy(), dtype=self._dtype)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.isna","title":"isna","text":"<pre><code>isna() -&gt; npt.NDArray[np.bool_]\n</code></pre> <p>Return boolean array indicating NA values.</p> Source code in <code>jalali_pandas/core/arrays.py</code> <pre><code>def isna(self) -&gt; npt.NDArray[np.bool_]:\n    \"\"\"Return boolean array indicating NA values.\"\"\"\n    return cast(\n        npt.NDArray[np.bool_],\n        np.array([pd.isna(x) for x in self._data], dtype=bool),\n    )\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.strftime","title":"strftime","text":"<pre><code>strftime(fmt: str) -&gt; npt.NDArray[np.object_]\n</code></pre> <p>Format timestamps as strings.</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>str</code> <p>Format string.</p> required <p>Returns:</p> Type Description <code>NDArray[object_]</code> <p>Array of formatted strings.</p> Source code in <code>jalali_pandas/core/arrays.py</code> <pre><code>def strftime(self, fmt: str) -&gt; npt.NDArray[np.object_]:\n    \"\"\"Format timestamps as strings.\n\n    Args:\n        fmt: Format string.\n\n    Returns:\n        Array of formatted strings.\n    \"\"\"\n    return cast(\n        npt.NDArray[np.object_],\n        np.array(\n            [x.strftime(fmt) if not pd.isna(x) else None for x in self._data],\n            dtype=object,\n        ),\n    )\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.take","title":"take","text":"<pre><code>take(indices: Sequence[int], *, allow_fill: bool = False, fill_value: Any = None) -&gt; JalaliDatetimeArray\n</code></pre> <p>Take elements from the array.</p> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>Sequence[int]</code> <p>Indices to take.</p> required <code>allow_fill</code> <code>bool</code> <p>Whether to allow fill values for -1 indices.</p> <code>False</code> <code>fill_value</code> <code>Any</code> <p>Value to use for -1 indices.</p> <code>None</code> <p>Returns:</p> Type Description <code>JalaliDatetimeArray</code> <p>JalaliDatetimeArray with taken elements.</p> Source code in <code>jalali_pandas/core/arrays.py</code> <pre><code>def take(\n    self,\n    indices: Sequence[int],\n    *,\n    allow_fill: bool = False,\n    fill_value: Any = None,\n) -&gt; JalaliDatetimeArray:\n    \"\"\"Take elements from the array.\n\n    Args:\n        indices: Indices to take.\n        allow_fill: Whether to allow fill values for -1 indices.\n        fill_value: Value to use for -1 indices.\n\n    Returns:\n        JalaliDatetimeArray with taken elements.\n    \"\"\"\n    if allow_fill:\n        if fill_value is None:\n            fill_value = pd.NaT\n\n        result: list[object] = []\n        for i in indices:\n            if i == -1:\n                result.append(fill_value)\n            else:\n                result.append(self._data[i])\n        data = cast(npt.NDArray[np.object_], np.array(result, dtype=object))\n    else:\n        data = cast(npt.NDArray[np.object_], self._data[list(indices)])\n\n    return type(self)(data, dtype=self._dtype)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.arrays.JalaliDatetimeArray.to_gregorian","title":"to_gregorian","text":"<pre><code>to_gregorian() -&gt; pd.DatetimeIndex\n</code></pre> <p>Convert to pandas DatetimeIndex (Gregorian).</p> <p>Returns:</p> Type Description <code>DatetimeIndex</code> <p>DatetimeIndex with Gregorian timestamps.</p> Source code in <code>jalali_pandas/core/arrays.py</code> <pre><code>def to_gregorian(self) -&gt; pd.DatetimeIndex:\n    \"\"\"Convert to pandas DatetimeIndex (Gregorian).\n\n    Returns:\n        DatetimeIndex with Gregorian timestamps.\n    \"\"\"\n    timestamps = [\n        x.to_gregorian() if not pd.isna(x) else pd.NaT for x in self._data\n    ]\n    return pd.DatetimeIndex(timestamps)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex","title":"JalaliDatetimeIndex","text":"<p>               Bases: <code>Index</code></p> <p>Index for Jalali datetime data.</p> <p>A JalaliDatetimeIndex is an immutable array of Jalali timestamps, suitable for use as an index in pandas DataFrames and Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; idx = JalaliDatetimeIndex([\"1402-01-01\", \"1402-01-02\", \"1402-01-03\"])\n&gt;&gt;&gt; idx\nJalaliDatetimeIndex(['1402-01-01', '1402-01-02', '1402-01-03'],\n                   dtype='jalali_datetime64[ns]', freq=None)\n</code></pre> <pre><code>&gt;&gt;&gt; idx.year\nIndex([1402, 1402, 1402], dtype='float64')\n</code></pre> Source code in <code>jalali_pandas/core/indexes.py</code> <pre><code>class JalaliDatetimeIndex(Index):\n    \"\"\"Index for Jalali datetime data.\n\n    A JalaliDatetimeIndex is an immutable array of Jalali timestamps,\n    suitable for use as an index in pandas DataFrames and Series.\n\n    Examples:\n        &gt;&gt;&gt; idx = JalaliDatetimeIndex([\"1402-01-01\", \"1402-01-02\", \"1402-01-03\"])\n        &gt;&gt;&gt; idx\n        JalaliDatetimeIndex(['1402-01-01', '1402-01-02', '1402-01-03'],\n                           dtype='jalali_datetime64[ns]', freq=None)\n\n        &gt;&gt;&gt; idx.year\n        Index([1402, 1402, 1402], dtype='float64')\n    \"\"\"\n\n    _typ = \"jalalidatetimeindex\"\n    _data: JalaliDatetimeArray\n    _freq: JalaliOffset | str | None\n    _name: Hashable\n    _cache: dict[str, Any]\n\n    # -------------------------------------------------------------------------\n    # Construction\n    # -------------------------------------------------------------------------\n\n    def __new__(\n        cls,\n        data: Sequence[Any] | JalaliDatetimeArray | JalaliDatetimeIndex | None = None,\n        freq: str | JalaliOffset | None = None,\n        tz: tzinfo | str | None = None,\n        dtype: JalaliDatetimeDtype | None = None,\n        copy: bool = False,\n        name: Hashable = None,\n    ) -&gt; JalaliDatetimeIndex:\n        \"\"\"Create a new JalaliDatetimeIndex.\"\"\"\n        if dtype is None:\n            # Convert tzinfo to string if needed\n            tz_str = str(tz) if tz is not None and not isinstance(tz, str) else tz\n            dtype = JalaliDatetimeDtype(tz=tz_str)\n\n        if data is None:\n            data = []\n\n        if isinstance(data, JalaliDatetimeIndex):\n            data = data._data.copy() if copy else data._data\n        elif isinstance(data, JalaliDatetimeArray):\n            if copy:\n                data = data.copy()\n        else:\n            data = JalaliDatetimeArray._from_sequence(\n                list(data), dtype=dtype, copy=copy\n            )\n\n        # Create the index\n        result = object.__new__(cls)\n        result._data = data\n        result._name = name\n        result._freq = freq\n        result._cache = {}\n\n        return result\n\n    @classmethod\n    def _simple_new(\n        cls,\n        values: JalaliDatetimeArray,\n        name: Hashable = None,\n        freq: str | JalaliOffset | None = None,\n        refs: Any = None,  # noqa: ARG003 - pandas compatibility\n    ) -&gt; JalaliDatetimeIndex:\n        \"\"\"Create a new JalaliDatetimeIndex from values without validation.\"\"\"\n        result = object.__new__(cls)\n        result._data = values\n        result._name = name\n        result._freq = freq\n        result._cache = {}\n        return result\n\n    # -------------------------------------------------------------------------\n    # Index Properties\n    # -------------------------------------------------------------------------\n\n    @property\n    def dtype(self) -&gt; JalaliDatetimeDtype:\n        \"\"\"Return the dtype of the index.\"\"\"\n        return self._data.dtype\n\n    @property\n    def freq(self) -&gt; JalaliOffset | str | None:\n        \"\"\"Return the frequency of the index.\"\"\"\n        return self._freq\n\n    @freq.setter\n    def freq(self, value: JalaliOffset | str | None) -&gt; None:\n        \"\"\"Set the frequency of the index.\"\"\"\n        self._freq = value\n\n    @property\n    def freqstr(self) -&gt; str | None:\n        \"\"\"Return the frequency as a string.\"\"\"\n        if self._freq is None:\n            return None\n        if isinstance(self._freq, str):\n            return self._freq\n        return str(self._freq)\n\n    @property\n    def inferred_freq(self) -&gt; str | None:\n        \"\"\"Try to infer the frequency from the data.\"\"\"\n        if len(self) &lt; 3:\n            return None\n\n        # Get differences between consecutive timestamps\n        diffs = []\n        for i in range(1, min(len(self), 10)):\n            diff = self[i].to_gregorian() - self[i - 1].to_gregorian()\n            diffs.append(diff)\n\n        # Check if all differences are the same\n        if len(set(diffs)) == 1:\n            diff = diffs[0]\n            if diff == pd.Timedelta(days=1):\n                return \"D\"\n            elif diff == pd.Timedelta(hours=1):\n                return \"h\"\n            elif diff == pd.Timedelta(minutes=1):\n                return \"min\"\n            elif diff == pd.Timedelta(seconds=1):\n                return \"s\"\n\n        return None\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the length of the index.\"\"\"\n        return len(self._data)\n\n    def __getitem__(self, key: Any) -&gt; Any:\n        \"\"\"Get item(s) from the index.\"\"\"\n        result = self._data[key]\n\n        if isinstance(result, JalaliDatetimeArray):\n            return type(self)._simple_new(result, name=self._name, freq=None)\n\n        return result\n\n    def __iter__(self) -&gt; Any:\n        \"\"\"Iterate over the index.\"\"\"\n        return iter(self._data)\n\n    def __contains__(self, key: Any) -&gt; bool:\n        \"\"\"Check if key is in the index.\"\"\"\n        try:\n            self.get_loc(key)\n            return True\n        except KeyError:\n            return False\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation.\"\"\"\n        data_repr = \", \".join(f\"'{x.strftime('%Y-%m-%d')}'\" for x in self._data[:5])\n        if len(self._data) &gt; 5:\n            data_repr += \", ...\"\n        freq_str = f\", freq='{self.freqstr}'\" if self.freqstr else \", freq=None\"\n        return (\n            f\"JalaliDatetimeIndex([{data_repr}], dtype='{self.dtype.name}'{freq_str})\"\n        )\n\n    # -------------------------------------------------------------------------\n    # Jalali Properties (vectorized)\n    # -------------------------------------------------------------------------\n\n    @property\n    def year(self) -&gt; Any:\n        \"\"\"Return array of years.\"\"\"\n        return pd.Index(self._data.year, name=self._name)\n\n    @property\n    def month(self) -&gt; Any:\n        \"\"\"Return array of months.\"\"\"\n        return pd.Index(self._data.month, name=self._name)\n\n    @property\n    def day(self) -&gt; Any:\n        \"\"\"Return array of days.\"\"\"\n        return pd.Index(self._data.day, name=self._name)\n\n    @property\n    def hour(self) -&gt; Any:\n        \"\"\"Return array of hours.\"\"\"\n        return pd.Index(self._data.hour, name=self._name)\n\n    @property\n    def minute(self) -&gt; Any:\n        \"\"\"Return array of minutes.\"\"\"\n        return pd.Index(self._data.minute, name=self._name)\n\n    @property\n    def second(self) -&gt; Any:\n        \"\"\"Return array of seconds.\"\"\"\n        return pd.Index(self._data.second, name=self._name)\n\n    @property\n    def quarter(self) -&gt; Any:\n        \"\"\"Return array of quarters.\"\"\"\n        return pd.Index(self._data.quarter, name=self._name)\n\n    @property\n    def dayofweek(self) -&gt; Any:\n        \"\"\"Return array of day of week values.\"\"\"\n        return pd.Index(self._data.dayofweek, name=self._name)\n\n    @property\n    def weekday(self) -&gt; Any:\n        \"\"\"Alias for dayofweek.\"\"\"\n        return self.dayofweek\n\n    @property\n    def dayofyear(self) -&gt; Any:\n        \"\"\"Return array of day of year values.\"\"\"\n        return pd.Index(self._data.dayofyear, name=self._name)\n\n    @property\n    def week(self) -&gt; Any:\n        \"\"\"Return array of week numbers.\"\"\"\n        return pd.Index(self._data.week, name=self._name)\n\n    @property\n    def weekofyear(self) -&gt; Any:\n        \"\"\"Alias for week.\"\"\"\n        return self.week\n\n    # -------------------------------------------------------------------------\n    # Conversion Methods\n    # -------------------------------------------------------------------------\n\n    def to_gregorian(self) -&gt; pd.DatetimeIndex:\n        \"\"\"Convert to pandas DatetimeIndex (Gregorian).\n\n        Returns:\n            DatetimeIndex with Gregorian timestamps.\n        \"\"\"\n        return self._data.to_gregorian()\n\n    def strftime(self, fmt: str) -&gt; Any:\n        \"\"\"Format timestamps as strings.\n\n        Args:\n            fmt: Format string.\n\n        Returns:\n            Index of formatted strings.\n        \"\"\"\n        return pd.Index(self._data.strftime(fmt), name=self._name)\n\n    # -------------------------------------------------------------------------\n    # Indexing Methods\n    # -------------------------------------------------------------------------\n\n    def get_loc(self, key: Any) -&gt; int | slice | npt.NDArray[np.bool_]:\n        \"\"\"Get integer location for requested label.\n\n        Supports:\n        - JalaliTimestamp: exact match\n        - String: \"1402-06-15\" for exact date\n        - Partial string: \"1402-06\" for month, \"1402\" for year\n\n        Args:\n            key: Label to look up.\n\n        Returns:\n            Integer location, slice, or boolean mask.\n\n        Raises:\n            KeyError: If key is not found.\n        \"\"\"\n        if isinstance(key, JalaliTimestamp):\n            # Exact match\n            for i, val in enumerate(self._data):\n                if val == key:\n                    return i\n            raise KeyError(key)\n\n        if isinstance(key, str):\n            return self._get_string_loc(key)\n\n        raise KeyError(key)\n\n    def _get_string_loc(self, key: str) -&gt; int | slice | npt.NDArray[np.bool_]:\n        \"\"\"Get location for string key with partial string indexing support.\"\"\"\n        # Try exact date match first\n        try:\n            ts = JalaliTimestamp.strptime(key, \"%Y-%m-%d\")\n            for i, val in enumerate(self._data):\n                if not pd.isna(val) and val == ts:\n                    return i\n        except ValueError:\n            pass\n\n        # Try partial string indexing\n        # Year only: \"1402\"\n        year_match = re.match(r\"^(\\d{4})$\", key)\n        if year_match:\n            year = int(year_match.group(1))\n            mask = cast(\n                npt.NDArray[np.bool_],\n                np.array(\n                    [not pd.isna(x) and x.year == year for x in self._data],\n                    dtype=bool,\n                ),\n            )\n            if mask.any():\n                return mask\n            raise KeyError(key)\n\n        # Year-month: \"1402-06\"\n        ym_match = re.match(r\"^(\\d{4})-(\\d{1,2})$\", key)\n        if ym_match:\n            year = int(ym_match.group(1))\n            month = int(ym_match.group(2))\n            mask = cast(\n                npt.NDArray[np.bool_],\n                np.array(\n                    [\n                        not pd.isna(x) and x.year == year and x.month == month\n                        for x in self._data\n                    ],\n                    dtype=bool,\n                ),\n            )\n            if mask.any():\n                return mask\n            raise KeyError(key)\n\n        raise KeyError(key)\n\n    def slice_locs(\n        self,\n        start: str | JalaliTimestamp | None = None,\n        end: str | JalaliTimestamp | None = None,\n        step: int | None = None,  # noqa: ARG002\n    ) -&gt; tuple[int, int]:\n        \"\"\"Compute slice locations for input labels.\n\n        Args:\n            start: Start label.\n            end: End label.\n            step: Step size.\n\n        Returns:\n            Tuple of (start, end) integer locations.\n        \"\"\"\n        start_loc = 0\n        end_loc = len(self)\n\n        if start is not None:\n            start_ts = self._parse_to_timestamp(start)\n            for i, val in enumerate(self._data):\n                if not pd.isna(val) and val &gt;= start_ts:\n                    start_loc = i\n                    break\n\n        if end is not None:\n            end_ts = self._parse_to_timestamp(end)\n            for i in range(len(self._data) - 1, -1, -1):\n                val = self._data[i]\n                if not pd.isna(val) and val &lt;= end_ts:\n                    end_loc = i + 1\n                    break\n\n        return start_loc, end_loc\n\n    def _parse_to_timestamp(self, key: str | JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Parse a key to JalaliTimestamp.\"\"\"\n        if isinstance(key, JalaliTimestamp):\n            return key\n        if isinstance(key, str):\n            try:\n                return JalaliTimestamp.strptime(key, \"%Y-%m-%d\")\n            except ValueError:\n                try:\n                    return JalaliTimestamp.strptime(key, \"%Y-%m-%d %H:%M:%S\")\n                except ValueError:\n                    pass\n            # Try partial string - use start of period\n            year_match = re.match(r\"^(\\d{4})$\", key)\n            if year_match:\n                return JalaliTimestamp(int(year_match.group(1)), 1, 1)\n            ym_match = re.match(r\"^(\\d{4})-(\\d{1,2})$\", key)\n            if ym_match:\n                return JalaliTimestamp(\n                    int(ym_match.group(1)), int(ym_match.group(2)), 1\n                )\n        raise ValueError(f\"Cannot parse '{key}' to JalaliTimestamp\")\n\n    # -------------------------------------------------------------------------\n    # Shift and Snap Methods\n    # -------------------------------------------------------------------------\n\n    def shift(\n        self,\n        periods: int = 1,\n        freq: str | JalaliOffset | pd.Timedelta | None = None,\n    ) -&gt; JalaliDatetimeIndex:\n        \"\"\"Shift index by desired number of time frequency increments.\n\n        Args:\n            periods: Number of periods to shift.\n            freq: Frequency to shift by. If None, uses the index's freq.\n\n        Returns:\n            Shifted JalaliDatetimeIndex.\n        \"\"\"\n        if freq is None:\n            freq = self._freq\n\n        if freq is None:\n            raise ValueError(\"freq must be specified if index has no frequency\")\n\n        # Parse string frequency\n        if isinstance(freq, str):\n            # Check if it's a Jalali frequency\n            from jalali_pandas.offsets.aliases import get_jalali_offset\n\n            offset_class = get_jalali_offset(freq.upper())\n            if offset_class is not None:\n                freq = offset_class(n=periods)\n                periods = 1\n            else:\n                # Use pandas Timedelta for standard frequencies\n                freq = pd.Timedelta(freq)\n\n        # Apply the shift\n        new_data: list[Any] = []\n        for val in self._data:\n            if pd.isna(val):\n                new_data.append(pd.NaT)\n            else:\n                if isinstance(freq, pd.Timedelta):\n                    new_val = val + freq * periods\n                else:\n                    # JalaliOffset\n                    new_val = val\n                    for _ in range(abs(periods)):\n                        new_val = freq + new_val if periods &gt; 0 else new_val - freq\n                new_data.append(new_val)\n\n        new_array = JalaliDatetimeArray._from_sequence(new_data, dtype=self.dtype)\n        return type(self)._simple_new(new_array, name=self._name, freq=self._freq)\n\n    def snap(self, freq: str = \"s\") -&gt; JalaliDatetimeIndex:\n        \"\"\"Snap time stamps to nearest occurring frequency.\n\n        Args:\n            freq: Frequency to snap to (e.g., 's' for second, 'min' for minute).\n\n        Returns:\n            Snapped JalaliDatetimeIndex.\n        \"\"\"\n        # Convert to Gregorian, snap, convert back\n        gregorian = self.to_gregorian()\n        snapped = gregorian.snap(freq)\n\n        new_data = [\n            JalaliTimestamp.from_gregorian(ts) if not pd.isna(ts) else pd.NaT\n            for ts in snapped\n        ]\n        new_array = JalaliDatetimeArray._from_sequence(new_data, dtype=self.dtype)\n        return type(self)._simple_new(new_array, name=self._name, freq=self._freq)\n\n    # -------------------------------------------------------------------------\n    # Set Operations\n    # -------------------------------------------------------------------------\n\n    def union(  # type: ignore[override]\n        self, other: JalaliDatetimeIndex, sort: bool | None = None\n    ) -&gt; JalaliDatetimeIndex:\n        \"\"\"Form the union of two JalaliDatetimeIndex objects.\n\n        Args:\n            other: Another JalaliDatetimeIndex.\n            sort: Whether to sort the result.\n\n        Returns:\n            Union of the two indexes.\n        \"\"\"\n        if not isinstance(other, JalaliDatetimeIndex):\n            raise TypeError(\"other must be a JalaliDatetimeIndex\")\n\n        # Combine and deduplicate\n        combined = list(self._data) + list(other._data)\n        seen: set[JalaliTimestamp] = set()\n        unique: list[Any] = []\n        for val in combined:\n            if pd.isna(val):\n                if pd.NaT not in seen:\n                    unique.append(pd.NaT)\n                    seen.add(pd.NaT)  # type: ignore\n            elif val not in seen:\n                unique.append(val)\n                seen.add(val)\n\n        if sort is True or (sort is None and len(unique) &gt; 0):\n            # Sort by Gregorian equivalent\n            unique = sorted(\n                unique,\n                key=lambda x: x.to_gregorian() if not pd.isna(x) else pd.Timestamp.min,\n            )\n\n        new_array = JalaliDatetimeArray._from_sequence(unique, dtype=self.dtype)\n        return type(self)._simple_new(new_array, name=self._name)\n\n    def intersection(  # type: ignore[override]\n        self, other: JalaliDatetimeIndex, sort: bool = False\n    ) -&gt; JalaliDatetimeIndex:\n        \"\"\"Form the intersection of two JalaliDatetimeIndex objects.\n\n        Args:\n            other: Another JalaliDatetimeIndex.\n            sort: Whether to sort the result.\n\n        Returns:\n            Intersection of the two indexes.\n        \"\"\"\n        if not isinstance(other, JalaliDatetimeIndex):\n            raise TypeError(\"other must be a JalaliDatetimeIndex\")\n\n        other_set = set(other._data)\n        common: list[Any] = []\n        for val in self._data:\n            if pd.isna(val):\n                if any(pd.isna(x) for x in other._data):\n                    common.append(pd.NaT)\n            elif val in other_set:\n                common.append(val)\n\n        if sort:\n            common = sorted(\n                common,\n                key=lambda x: x.to_gregorian() if not pd.isna(x) else pd.Timestamp.min,\n            )\n\n        new_array = JalaliDatetimeArray._from_sequence(common, dtype=self.dtype)\n        return type(self)._simple_new(new_array, name=self._name)\n\n    def difference(  # type: ignore[override]\n        self, other: JalaliDatetimeIndex, sort: bool | None = True\n    ) -&gt; JalaliDatetimeIndex:\n        \"\"\"Return a new JalaliDatetimeIndex with elements not in other.\n\n        Args:\n            other: Another JalaliDatetimeIndex.\n            sort: Whether to sort the result.\n\n        Returns:\n            Difference of the two indexes.\n        \"\"\"\n        if not isinstance(other, JalaliDatetimeIndex):\n            raise TypeError(\"other must be a JalaliDatetimeIndex\")\n\n        other_set = set(other._data)\n        diff: list[Any] = []\n        for val in self._data:\n            if pd.isna(val):\n                if not any(pd.isna(x) for x in other._data):\n                    diff.append(pd.NaT)\n            elif val not in other_set:\n                diff.append(val)\n\n        if sort:\n            diff = sorted(\n                diff,\n                key=lambda x: x.to_gregorian() if not pd.isna(x) else pd.Timestamp.min,\n            )\n\n        new_array = JalaliDatetimeArray._from_sequence(diff, dtype=self.dtype)\n        return type(self)._simple_new(new_array, name=self._name)\n\n    # -------------------------------------------------------------------------\n    # Required Index Methods\n    # -------------------------------------------------------------------------\n\n    def copy(self, name: Hashable = None, deep: bool = True) -&gt; JalaliDatetimeIndex:\n        \"\"\"Make a copy of this object.\n\n        Args:\n            name: Name for the new index.\n            deep: Whether to make a deep copy.\n\n        Returns:\n            Copy of the index.\n        \"\"\"\n        new_data = self._data.copy() if deep else self._data\n        return type(self)._simple_new(\n            new_data,\n            name=name if name is not None else self._name,\n            freq=self._freq,\n        )\n\n    def _shallow_copy(\n        self, values: JalaliDatetimeArray | None = None\n    ) -&gt; JalaliDatetimeIndex:\n        \"\"\"Create a shallow copy with optional new values.\"\"\"\n        if values is None:\n            values = self._data\n        return type(self)._simple_new(values, name=self._name, freq=self._freq)\n\n    @property\n    def _constructor(self) -&gt; type[JalaliDatetimeIndex]:\n        \"\"\"Return the constructor for this type.\"\"\"\n        return type(self)\n\n    def equals(self, other: object) -&gt; bool:\n        \"\"\"Determine if two Index objects are equal.\"\"\"\n        if not isinstance(other, JalaliDatetimeIndex):\n            return False\n        if len(self) != len(other):\n            return False\n        return all(\n            (pd.isna(a) and pd.isna(b)) or a == b\n            for a, b in zip(self._data, other._data)\n        )\n\n    def __eq__(self, other: Any) -&gt; Any:\n        \"\"\"Element-wise equality comparison.\"\"\"\n        if isinstance(other, JalaliDatetimeIndex):\n            return cast(npt.NDArray[np.bool_], self._data == other._data)\n        if isinstance(other, JalaliTimestamp):\n            return cast(\n                npt.NDArray[np.bool_],\n                np.array([x == other for x in self._data], dtype=bool),\n            )\n        return NotImplemented\n\n    def __ne__(self, other: Any) -&gt; Any:\n        \"\"\"Element-wise inequality comparison.\"\"\"\n        result = self.__eq__(other)\n        if result is NotImplemented:\n            return result\n        return ~result\n\n    def _isna(self) -&gt; npt.NDArray[np.bool_]:\n        \"\"\"Return boolean array indicating NA values.\"\"\"\n        return self._data.isna()\n\n    def _notna(self) -&gt; npt.NDArray[np.bool_]:\n        \"\"\"Return boolean array indicating non-NA values.\"\"\"\n        return ~self._isna()\n\n    @property\n    def values(self) -&gt; JalaliDatetimeArray:\n        \"\"\"Return the underlying data as a JalaliDatetimeArray.\"\"\"\n        return self._data\n\n    def to_numpy(  # type: ignore[override]\n        self,\n        dtype: Any = None,\n        copy: bool = False,\n        na_value: Any = None,  # noqa: ARG002\n    ) -&gt; npt.NDArray[Any]:\n        \"\"\"Convert to numpy array.\"\"\"\n        if dtype is None:\n            return self._data._data.copy() if copy else self._data._data\n        return np.array(self._data._data, dtype=dtype, copy=copy)\n\n    def to_list(self) -&gt; list[JalaliTimestamp]:\n        \"\"\"Return a list of the values.\"\"\"\n        return list(self._data)\n\n    def tolist(self) -&gt; list[JalaliTimestamp]:\n        \"\"\"Return a list of the values.\"\"\"\n        return self.to_list()\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.day","title":"day  <code>property</code>","text":"<pre><code>day: Any\n</code></pre> <p>Return array of days.</p>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.dayofweek","title":"dayofweek  <code>property</code>","text":"<pre><code>dayofweek: Any\n</code></pre> <p>Return array of day of week values.</p>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.dayofyear","title":"dayofyear  <code>property</code>","text":"<pre><code>dayofyear: Any\n</code></pre> <p>Return array of day of year values.</p>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: JalaliDatetimeDtype\n</code></pre> <p>Return the dtype of the index.</p>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.freq","title":"freq  <code>property</code> <code>writable</code>","text":"<pre><code>freq: JalaliOffset | str | None\n</code></pre> <p>Return the frequency of the index.</p>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.freqstr","title":"freqstr  <code>property</code>","text":"<pre><code>freqstr: str | None\n</code></pre> <p>Return the frequency as a string.</p>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.hour","title":"hour  <code>property</code>","text":"<pre><code>hour: Any\n</code></pre> <p>Return array of hours.</p>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.inferred_freq","title":"inferred_freq  <code>property</code>","text":"<pre><code>inferred_freq: str | None\n</code></pre> <p>Try to infer the frequency from the data.</p>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.minute","title":"minute  <code>property</code>","text":"<pre><code>minute: Any\n</code></pre> <p>Return array of minutes.</p>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.month","title":"month  <code>property</code>","text":"<pre><code>month: Any\n</code></pre> <p>Return array of months.</p>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.quarter","title":"quarter  <code>property</code>","text":"<pre><code>quarter: Any\n</code></pre> <p>Return array of quarters.</p>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.second","title":"second  <code>property</code>","text":"<pre><code>second: Any\n</code></pre> <p>Return array of seconds.</p>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.values","title":"values  <code>property</code>","text":"<pre><code>values: JalaliDatetimeArray\n</code></pre> <p>Return the underlying data as a JalaliDatetimeArray.</p>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.week","title":"week  <code>property</code>","text":"<pre><code>week: Any\n</code></pre> <p>Return array of week numbers.</p>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.weekday","title":"weekday  <code>property</code>","text":"<pre><code>weekday: Any\n</code></pre> <p>Alias for dayofweek.</p>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.weekofyear","title":"weekofyear  <code>property</code>","text":"<pre><code>weekofyear: Any\n</code></pre> <p>Alias for week.</p>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.year","title":"year  <code>property</code>","text":"<pre><code>year: Any\n</code></pre> <p>Return array of years.</p>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.__contains__","title":"__contains__","text":"<pre><code>__contains__(key: Any) -&gt; bool\n</code></pre> <p>Check if key is in the index.</p> Source code in <code>jalali_pandas/core/indexes.py</code> <pre><code>def __contains__(self, key: Any) -&gt; bool:\n    \"\"\"Check if key is in the index.\"\"\"\n    try:\n        self.get_loc(key)\n        return True\n    except KeyError:\n        return False\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: Any) -&gt; Any\n</code></pre> <p>Element-wise equality comparison.</p> Source code in <code>jalali_pandas/core/indexes.py</code> <pre><code>def __eq__(self, other: Any) -&gt; Any:\n    \"\"\"Element-wise equality comparison.\"\"\"\n    if isinstance(other, JalaliDatetimeIndex):\n        return cast(npt.NDArray[np.bool_], self._data == other._data)\n    if isinstance(other, JalaliTimestamp):\n        return cast(\n            npt.NDArray[np.bool_],\n            np.array([x == other for x in self._data], dtype=bool),\n        )\n    return NotImplemented\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: Any) -&gt; Any\n</code></pre> <p>Get item(s) from the index.</p> Source code in <code>jalali_pandas/core/indexes.py</code> <pre><code>def __getitem__(self, key: Any) -&gt; Any:\n    \"\"\"Get item(s) from the index.\"\"\"\n    result = self._data[key]\n\n    if isinstance(result, JalaliDatetimeArray):\n        return type(self)._simple_new(result, name=self._name, freq=None)\n\n    return result\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.__iter__","title":"__iter__","text":"<pre><code>__iter__() -&gt; Any\n</code></pre> <p>Iterate over the index.</p> Source code in <code>jalali_pandas/core/indexes.py</code> <pre><code>def __iter__(self) -&gt; Any:\n    \"\"\"Iterate over the index.\"\"\"\n    return iter(self._data)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the length of the index.</p> Source code in <code>jalali_pandas/core/indexes.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the length of the index.\"\"\"\n    return len(self._data)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.__ne__","title":"__ne__","text":"<pre><code>__ne__(other: Any) -&gt; Any\n</code></pre> <p>Element-wise inequality comparison.</p> Source code in <code>jalali_pandas/core/indexes.py</code> <pre><code>def __ne__(self, other: Any) -&gt; Any:\n    \"\"\"Element-wise inequality comparison.\"\"\"\n    result = self.__eq__(other)\n    if result is NotImplemented:\n        return result\n    return ~result\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.__new__","title":"__new__","text":"<pre><code>__new__(data: Sequence[Any] | JalaliDatetimeArray | JalaliDatetimeIndex | None = None, freq: str | JalaliOffset | None = None, tz: tzinfo | str | None = None, dtype: JalaliDatetimeDtype | None = None, copy: bool = False, name: Hashable = None) -&gt; JalaliDatetimeIndex\n</code></pre> <p>Create a new JalaliDatetimeIndex.</p> Source code in <code>jalali_pandas/core/indexes.py</code> <pre><code>def __new__(\n    cls,\n    data: Sequence[Any] | JalaliDatetimeArray | JalaliDatetimeIndex | None = None,\n    freq: str | JalaliOffset | None = None,\n    tz: tzinfo | str | None = None,\n    dtype: JalaliDatetimeDtype | None = None,\n    copy: bool = False,\n    name: Hashable = None,\n) -&gt; JalaliDatetimeIndex:\n    \"\"\"Create a new JalaliDatetimeIndex.\"\"\"\n    if dtype is None:\n        # Convert tzinfo to string if needed\n        tz_str = str(tz) if tz is not None and not isinstance(tz, str) else tz\n        dtype = JalaliDatetimeDtype(tz=tz_str)\n\n    if data is None:\n        data = []\n\n    if isinstance(data, JalaliDatetimeIndex):\n        data = data._data.copy() if copy else data._data\n    elif isinstance(data, JalaliDatetimeArray):\n        if copy:\n            data = data.copy()\n    else:\n        data = JalaliDatetimeArray._from_sequence(\n            list(data), dtype=dtype, copy=copy\n        )\n\n    # Create the index\n    result = object.__new__(cls)\n    result._data = data\n    result._name = name\n    result._freq = freq\n    result._cache = {}\n\n    return result\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>String representation.</p> Source code in <code>jalali_pandas/core/indexes.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"String representation.\"\"\"\n    data_repr = \", \".join(f\"'{x.strftime('%Y-%m-%d')}'\" for x in self._data[:5])\n    if len(self._data) &gt; 5:\n        data_repr += \", ...\"\n    freq_str = f\", freq='{self.freqstr}'\" if self.freqstr else \", freq=None\"\n    return (\n        f\"JalaliDatetimeIndex([{data_repr}], dtype='{self.dtype.name}'{freq_str})\"\n    )\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.copy","title":"copy","text":"<pre><code>copy(name: Hashable = None, deep: bool = True) -&gt; JalaliDatetimeIndex\n</code></pre> <p>Make a copy of this object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Hashable</code> <p>Name for the new index.</p> <code>None</code> <code>deep</code> <code>bool</code> <p>Whether to make a deep copy.</p> <code>True</code> <p>Returns:</p> Type Description <code>JalaliDatetimeIndex</code> <p>Copy of the index.</p> Source code in <code>jalali_pandas/core/indexes.py</code> <pre><code>def copy(self, name: Hashable = None, deep: bool = True) -&gt; JalaliDatetimeIndex:\n    \"\"\"Make a copy of this object.\n\n    Args:\n        name: Name for the new index.\n        deep: Whether to make a deep copy.\n\n    Returns:\n        Copy of the index.\n    \"\"\"\n    new_data = self._data.copy() if deep else self._data\n    return type(self)._simple_new(\n        new_data,\n        name=name if name is not None else self._name,\n        freq=self._freq,\n    )\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.difference","title":"difference","text":"<pre><code>difference(other: JalaliDatetimeIndex, sort: bool | None = True) -&gt; JalaliDatetimeIndex\n</code></pre> <p>Return a new JalaliDatetimeIndex with elements not in other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>JalaliDatetimeIndex</code> <p>Another JalaliDatetimeIndex.</p> required <code>sort</code> <code>bool | None</code> <p>Whether to sort the result.</p> <code>True</code> <p>Returns:</p> Type Description <code>JalaliDatetimeIndex</code> <p>Difference of the two indexes.</p> Source code in <code>jalali_pandas/core/indexes.py</code> <pre><code>def difference(  # type: ignore[override]\n    self, other: JalaliDatetimeIndex, sort: bool | None = True\n) -&gt; JalaliDatetimeIndex:\n    \"\"\"Return a new JalaliDatetimeIndex with elements not in other.\n\n    Args:\n        other: Another JalaliDatetimeIndex.\n        sort: Whether to sort the result.\n\n    Returns:\n        Difference of the two indexes.\n    \"\"\"\n    if not isinstance(other, JalaliDatetimeIndex):\n        raise TypeError(\"other must be a JalaliDatetimeIndex\")\n\n    other_set = set(other._data)\n    diff: list[Any] = []\n    for val in self._data:\n        if pd.isna(val):\n            if not any(pd.isna(x) for x in other._data):\n                diff.append(pd.NaT)\n        elif val not in other_set:\n            diff.append(val)\n\n    if sort:\n        diff = sorted(\n            diff,\n            key=lambda x: x.to_gregorian() if not pd.isna(x) else pd.Timestamp.min,\n        )\n\n    new_array = JalaliDatetimeArray._from_sequence(diff, dtype=self.dtype)\n    return type(self)._simple_new(new_array, name=self._name)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.equals","title":"equals","text":"<pre><code>equals(other: object) -&gt; bool\n</code></pre> <p>Determine if two Index objects are equal.</p> Source code in <code>jalali_pandas/core/indexes.py</code> <pre><code>def equals(self, other: object) -&gt; bool:\n    \"\"\"Determine if two Index objects are equal.\"\"\"\n    if not isinstance(other, JalaliDatetimeIndex):\n        return False\n    if len(self) != len(other):\n        return False\n    return all(\n        (pd.isna(a) and pd.isna(b)) or a == b\n        for a, b in zip(self._data, other._data)\n    )\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.get_loc","title":"get_loc","text":"<pre><code>get_loc(key: Any) -&gt; int | slice | npt.NDArray[np.bool_]\n</code></pre> <p>Get integer location for requested label.</p> <p>Supports: - JalaliTimestamp: exact match - String: \"1402-06-15\" for exact date - Partial string: \"1402-06\" for month, \"1402\" for year</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Any</code> <p>Label to look up.</p> required <p>Returns:</p> Type Description <code>int | slice | NDArray[bool_]</code> <p>Integer location, slice, or boolean mask.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If key is not found.</p> Source code in <code>jalali_pandas/core/indexes.py</code> <pre><code>def get_loc(self, key: Any) -&gt; int | slice | npt.NDArray[np.bool_]:\n    \"\"\"Get integer location for requested label.\n\n    Supports:\n    - JalaliTimestamp: exact match\n    - String: \"1402-06-15\" for exact date\n    - Partial string: \"1402-06\" for month, \"1402\" for year\n\n    Args:\n        key: Label to look up.\n\n    Returns:\n        Integer location, slice, or boolean mask.\n\n    Raises:\n        KeyError: If key is not found.\n    \"\"\"\n    if isinstance(key, JalaliTimestamp):\n        # Exact match\n        for i, val in enumerate(self._data):\n            if val == key:\n                return i\n        raise KeyError(key)\n\n    if isinstance(key, str):\n        return self._get_string_loc(key)\n\n    raise KeyError(key)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.intersection","title":"intersection","text":"<pre><code>intersection(other: JalaliDatetimeIndex, sort: bool = False) -&gt; JalaliDatetimeIndex\n</code></pre> <p>Form the intersection of two JalaliDatetimeIndex objects.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>JalaliDatetimeIndex</code> <p>Another JalaliDatetimeIndex.</p> required <code>sort</code> <code>bool</code> <p>Whether to sort the result.</p> <code>False</code> <p>Returns:</p> Type Description <code>JalaliDatetimeIndex</code> <p>Intersection of the two indexes.</p> Source code in <code>jalali_pandas/core/indexes.py</code> <pre><code>def intersection(  # type: ignore[override]\n    self, other: JalaliDatetimeIndex, sort: bool = False\n) -&gt; JalaliDatetimeIndex:\n    \"\"\"Form the intersection of two JalaliDatetimeIndex objects.\n\n    Args:\n        other: Another JalaliDatetimeIndex.\n        sort: Whether to sort the result.\n\n    Returns:\n        Intersection of the two indexes.\n    \"\"\"\n    if not isinstance(other, JalaliDatetimeIndex):\n        raise TypeError(\"other must be a JalaliDatetimeIndex\")\n\n    other_set = set(other._data)\n    common: list[Any] = []\n    for val in self._data:\n        if pd.isna(val):\n            if any(pd.isna(x) for x in other._data):\n                common.append(pd.NaT)\n        elif val in other_set:\n            common.append(val)\n\n    if sort:\n        common = sorted(\n            common,\n            key=lambda x: x.to_gregorian() if not pd.isna(x) else pd.Timestamp.min,\n        )\n\n    new_array = JalaliDatetimeArray._from_sequence(common, dtype=self.dtype)\n    return type(self)._simple_new(new_array, name=self._name)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.shift","title":"shift","text":"<pre><code>shift(periods: int = 1, freq: str | JalaliOffset | Timedelta | None = None) -&gt; JalaliDatetimeIndex\n</code></pre> <p>Shift index by desired number of time frequency increments.</p> <p>Parameters:</p> Name Type Description Default <code>periods</code> <code>int</code> <p>Number of periods to shift.</p> <code>1</code> <code>freq</code> <code>str | JalaliOffset | Timedelta | None</code> <p>Frequency to shift by. If None, uses the index's freq.</p> <code>None</code> <p>Returns:</p> Type Description <code>JalaliDatetimeIndex</code> <p>Shifted JalaliDatetimeIndex.</p> Source code in <code>jalali_pandas/core/indexes.py</code> <pre><code>def shift(\n    self,\n    periods: int = 1,\n    freq: str | JalaliOffset | pd.Timedelta | None = None,\n) -&gt; JalaliDatetimeIndex:\n    \"\"\"Shift index by desired number of time frequency increments.\n\n    Args:\n        periods: Number of periods to shift.\n        freq: Frequency to shift by. If None, uses the index's freq.\n\n    Returns:\n        Shifted JalaliDatetimeIndex.\n    \"\"\"\n    if freq is None:\n        freq = self._freq\n\n    if freq is None:\n        raise ValueError(\"freq must be specified if index has no frequency\")\n\n    # Parse string frequency\n    if isinstance(freq, str):\n        # Check if it's a Jalali frequency\n        from jalali_pandas.offsets.aliases import get_jalali_offset\n\n        offset_class = get_jalali_offset(freq.upper())\n        if offset_class is not None:\n            freq = offset_class(n=periods)\n            periods = 1\n        else:\n            # Use pandas Timedelta for standard frequencies\n            freq = pd.Timedelta(freq)\n\n    # Apply the shift\n    new_data: list[Any] = []\n    for val in self._data:\n        if pd.isna(val):\n            new_data.append(pd.NaT)\n        else:\n            if isinstance(freq, pd.Timedelta):\n                new_val = val + freq * periods\n            else:\n                # JalaliOffset\n                new_val = val\n                for _ in range(abs(periods)):\n                    new_val = freq + new_val if periods &gt; 0 else new_val - freq\n            new_data.append(new_val)\n\n    new_array = JalaliDatetimeArray._from_sequence(new_data, dtype=self.dtype)\n    return type(self)._simple_new(new_array, name=self._name, freq=self._freq)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.slice_locs","title":"slice_locs","text":"<pre><code>slice_locs(start: str | JalaliTimestamp | None = None, end: str | JalaliTimestamp | None = None, step: int | None = None) -&gt; tuple[int, int]\n</code></pre> <p>Compute slice locations for input labels.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>str | JalaliTimestamp | None</code> <p>Start label.</p> <code>None</code> <code>end</code> <code>str | JalaliTimestamp | None</code> <p>End label.</p> <code>None</code> <code>step</code> <code>int | None</code> <p>Step size.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>Tuple of (start, end) integer locations.</p> Source code in <code>jalali_pandas/core/indexes.py</code> <pre><code>def slice_locs(\n    self,\n    start: str | JalaliTimestamp | None = None,\n    end: str | JalaliTimestamp | None = None,\n    step: int | None = None,  # noqa: ARG002\n) -&gt; tuple[int, int]:\n    \"\"\"Compute slice locations for input labels.\n\n    Args:\n        start: Start label.\n        end: End label.\n        step: Step size.\n\n    Returns:\n        Tuple of (start, end) integer locations.\n    \"\"\"\n    start_loc = 0\n    end_loc = len(self)\n\n    if start is not None:\n        start_ts = self._parse_to_timestamp(start)\n        for i, val in enumerate(self._data):\n            if not pd.isna(val) and val &gt;= start_ts:\n                start_loc = i\n                break\n\n    if end is not None:\n        end_ts = self._parse_to_timestamp(end)\n        for i in range(len(self._data) - 1, -1, -1):\n            val = self._data[i]\n            if not pd.isna(val) and val &lt;= end_ts:\n                end_loc = i + 1\n                break\n\n    return start_loc, end_loc\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.snap","title":"snap","text":"<pre><code>snap(freq: str = 's') -&gt; JalaliDatetimeIndex\n</code></pre> <p>Snap time stamps to nearest occurring frequency.</p> <p>Parameters:</p> Name Type Description Default <code>freq</code> <code>str</code> <p>Frequency to snap to (e.g., 's' for second, 'min' for minute).</p> <code>'s'</code> <p>Returns:</p> Type Description <code>JalaliDatetimeIndex</code> <p>Snapped JalaliDatetimeIndex.</p> Source code in <code>jalali_pandas/core/indexes.py</code> <pre><code>def snap(self, freq: str = \"s\") -&gt; JalaliDatetimeIndex:\n    \"\"\"Snap time stamps to nearest occurring frequency.\n\n    Args:\n        freq: Frequency to snap to (e.g., 's' for second, 'min' for minute).\n\n    Returns:\n        Snapped JalaliDatetimeIndex.\n    \"\"\"\n    # Convert to Gregorian, snap, convert back\n    gregorian = self.to_gregorian()\n    snapped = gregorian.snap(freq)\n\n    new_data = [\n        JalaliTimestamp.from_gregorian(ts) if not pd.isna(ts) else pd.NaT\n        for ts in snapped\n    ]\n    new_array = JalaliDatetimeArray._from_sequence(new_data, dtype=self.dtype)\n    return type(self)._simple_new(new_array, name=self._name, freq=self._freq)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.strftime","title":"strftime","text":"<pre><code>strftime(fmt: str) -&gt; Any\n</code></pre> <p>Format timestamps as strings.</p> <p>Parameters:</p> Name Type Description Default <code>fmt</code> <code>str</code> <p>Format string.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Index of formatted strings.</p> Source code in <code>jalali_pandas/core/indexes.py</code> <pre><code>def strftime(self, fmt: str) -&gt; Any:\n    \"\"\"Format timestamps as strings.\n\n    Args:\n        fmt: Format string.\n\n    Returns:\n        Index of formatted strings.\n    \"\"\"\n    return pd.Index(self._data.strftime(fmt), name=self._name)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.to_gregorian","title":"to_gregorian","text":"<pre><code>to_gregorian() -&gt; pd.DatetimeIndex\n</code></pre> <p>Convert to pandas DatetimeIndex (Gregorian).</p> <p>Returns:</p> Type Description <code>DatetimeIndex</code> <p>DatetimeIndex with Gregorian timestamps.</p> Source code in <code>jalali_pandas/core/indexes.py</code> <pre><code>def to_gregorian(self) -&gt; pd.DatetimeIndex:\n    \"\"\"Convert to pandas DatetimeIndex (Gregorian).\n\n    Returns:\n        DatetimeIndex with Gregorian timestamps.\n    \"\"\"\n    return self._data.to_gregorian()\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.to_list","title":"to_list","text":"<pre><code>to_list() -&gt; list[JalaliTimestamp]\n</code></pre> <p>Return a list of the values.</p> Source code in <code>jalali_pandas/core/indexes.py</code> <pre><code>def to_list(self) -&gt; list[JalaliTimestamp]:\n    \"\"\"Return a list of the values.\"\"\"\n    return list(self._data)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.to_numpy","title":"to_numpy","text":"<pre><code>to_numpy(dtype: Any = None, copy: bool = False, na_value: Any = None) -&gt; npt.NDArray[Any]\n</code></pre> <p>Convert to numpy array.</p> Source code in <code>jalali_pandas/core/indexes.py</code> <pre><code>def to_numpy(  # type: ignore[override]\n    self,\n    dtype: Any = None,\n    copy: bool = False,\n    na_value: Any = None,  # noqa: ARG002\n) -&gt; npt.NDArray[Any]:\n    \"\"\"Convert to numpy array.\"\"\"\n    if dtype is None:\n        return self._data._data.copy() if copy else self._data._data\n    return np.array(self._data._data, dtype=dtype, copy=copy)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.tolist","title":"tolist","text":"<pre><code>tolist() -&gt; list[JalaliTimestamp]\n</code></pre> <p>Return a list of the values.</p> Source code in <code>jalali_pandas/core/indexes.py</code> <pre><code>def tolist(self) -&gt; list[JalaliTimestamp]:\n    \"\"\"Return a list of the values.\"\"\"\n    return self.to_list()\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.indexes.JalaliDatetimeIndex.union","title":"union","text":"<pre><code>union(other: JalaliDatetimeIndex, sort: bool | None = None) -&gt; JalaliDatetimeIndex\n</code></pre> <p>Form the union of two JalaliDatetimeIndex objects.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>JalaliDatetimeIndex</code> <p>Another JalaliDatetimeIndex.</p> required <code>sort</code> <code>bool | None</code> <p>Whether to sort the result.</p> <code>None</code> <p>Returns:</p> Type Description <code>JalaliDatetimeIndex</code> <p>Union of the two indexes.</p> Source code in <code>jalali_pandas/core/indexes.py</code> <pre><code>def union(  # type: ignore[override]\n    self, other: JalaliDatetimeIndex, sort: bool | None = None\n) -&gt; JalaliDatetimeIndex:\n    \"\"\"Form the union of two JalaliDatetimeIndex objects.\n\n    Args:\n        other: Another JalaliDatetimeIndex.\n        sort: Whether to sort the result.\n\n    Returns:\n        Union of the two indexes.\n    \"\"\"\n    if not isinstance(other, JalaliDatetimeIndex):\n        raise TypeError(\"other must be a JalaliDatetimeIndex\")\n\n    # Combine and deduplicate\n    combined = list(self._data) + list(other._data)\n    seen: set[JalaliTimestamp] = set()\n    unique: list[Any] = []\n    for val in combined:\n        if pd.isna(val):\n            if pd.NaT not in seen:\n                unique.append(pd.NaT)\n                seen.add(pd.NaT)  # type: ignore\n        elif val not in seen:\n            unique.append(val)\n            seen.add(val)\n\n    if sort is True or (sort is None and len(unique) &gt; 0):\n        # Sort by Gregorian equivalent\n        unique = sorted(\n            unique,\n            key=lambda x: x.to_gregorian() if not pd.isna(x) else pd.Timestamp.min,\n        )\n\n    new_array = JalaliDatetimeArray._from_sequence(unique, dtype=self.dtype)\n    return type(self)._simple_new(new_array, name=self._name)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.calendar.day_of_year","title":"day_of_year","text":"<pre><code>day_of_year(year: int, month: int, day: int) -&gt; int\n</code></pre> <p>Get the day of year (1-366).</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Jalali year.</p> required <code>month</code> <code>int</code> <p>Jalali month (1-12).</p> required <code>day</code> <code>int</code> <p>Jalali day.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Day of year (1-366).</p> Source code in <code>jalali_pandas/core/calendar.py</code> <pre><code>def day_of_year(year: int, month: int, day: int) -&gt; int:\n    \"\"\"Get the day of year (1-366).\n\n    Args:\n        year: Jalali year.\n        month: Jalali month (1-12).\n        day: Jalali day.\n\n    Returns:\n        Day of year (1-366).\n    \"\"\"\n    max_day = days_in_month(year, month)\n    if not 1 &lt;= day &lt;= max_day:\n        raise ValueError(f\"Day must be 1-{max_day} for month {month}, got {day}\")\n    return MONTH_STARTS[month - 1] + day\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.calendar.days_in_month","title":"days_in_month","text":"<pre><code>days_in_month(year: int, month: int) -&gt; int\n</code></pre> <p>Get the number of days in a Jalali month.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Jalali year.</p> required <code>month</code> <code>int</code> <p>Jalali month (1-12).</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of days in the month.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If month is not in range 1-12.</p> Source code in <code>jalali_pandas/core/calendar.py</code> <pre><code>def days_in_month(year: int, month: int) -&gt; int:\n    \"\"\"Get the number of days in a Jalali month.\n\n    Args:\n        year: Jalali year.\n        month: Jalali month (1-12).\n\n    Returns:\n        Number of days in the month.\n\n    Raises:\n        ValueError: If month is not in range 1-12.\n    \"\"\"\n    if not 1 &lt;= month &lt;= 12:\n        raise ValueError(f\"Month must be 1-12, got {month}\")\n\n    if month == 12:\n        return 30 if is_leap_year(year) else 29\n    return MONTH_LENGTHS[month - 1]\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.calendar.days_in_month_vectorized","title":"days_in_month_vectorized","text":"<pre><code>days_in_month_vectorized(years: NDArray[int64], months: NDArray[int64]) -&gt; npt.NDArray[np.int64]\n</code></pre> <p>Vectorized calculation of days in month.</p> <p>Parameters:</p> Name Type Description Default <code>years</code> <code>NDArray[int64]</code> <p>Array of Jalali years.</p> required <code>months</code> <code>NDArray[int64]</code> <p>Array of Jalali months (1-12).</p> required <p>Returns:</p> Type Description <code>NDArray[int64]</code> <p>Array of days in each month.</p> Source code in <code>jalali_pandas/core/calendar.py</code> <pre><code>def days_in_month_vectorized(\n    years: npt.NDArray[np.int64], months: npt.NDArray[np.int64]\n) -&gt; npt.NDArray[np.int64]:\n    \"\"\"Vectorized calculation of days in month.\n\n    Args:\n        years: Array of Jalali years.\n        months: Array of Jalali months (1-12).\n\n    Returns:\n        Array of days in each month.\n    \"\"\"\n    # Base month lengths (non-leap)\n    month_lengths = np.array(MONTH_LENGTHS, dtype=np.int64)\n    result = month_lengths[months - 1]\n\n    # Adjust Esfand for leap years\n    is_esfand = months == 12\n    is_leap = is_leap_year_vectorized(years)\n    result = np.where(is_esfand &amp; is_leap, 30, result)\n\n    return result\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.calendar.days_in_year","title":"days_in_year","text":"<pre><code>days_in_year(year: int) -&gt; int\n</code></pre> <p>Get the number of days in a Jalali year.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Jalali year.</p> required <p>Returns:</p> Type Description <code>int</code> <p>365 for normal years, 366 for leap years.</p> Source code in <code>jalali_pandas/core/calendar.py</code> <pre><code>def days_in_year(year: int) -&gt; int:\n    \"\"\"Get the number of days in a Jalali year.\n\n    Args:\n        year: Jalali year.\n\n    Returns:\n        365 for normal years, 366 for leap years.\n    \"\"\"\n    return 366 if is_leap_year(year) else 365\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.calendar.is_leap_year","title":"is_leap_year","text":"<pre><code>is_leap_year(year: int) -&gt; bool\n</code></pre> <p>Check if a Jalali year is a leap year.</p> <p>Uses the 33-year cycle algorithm used by jdatetime.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Jalali year.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the year is a leap year, False otherwise.</p> Source code in <code>jalali_pandas/core/calendar.py</code> <pre><code>def is_leap_year(year: int) -&gt; bool:\n    \"\"\"Check if a Jalali year is a leap year.\n\n    Uses the 33-year cycle algorithm used by jdatetime.\n\n    Args:\n        year: Jalali year.\n\n    Returns:\n        True if the year is a leap year, False otherwise.\n    \"\"\"\n    return year % 33 in LEAP_YEAR_REMAINDERS\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.calendar.is_leap_year_vectorized","title":"is_leap_year_vectorized","text":"<pre><code>is_leap_year_vectorized(years: NDArray[int64]) -&gt; npt.NDArray[np.bool_]\n</code></pre> <p>Vectorized check for leap years.</p> <p>Parameters:</p> Name Type Description Default <code>years</code> <code>NDArray[int64]</code> <p>Array of Jalali years.</p> required <p>Returns:</p> Type Description <code>NDArray[bool_]</code> <p>Boolean array indicating leap years.</p> Source code in <code>jalali_pandas/core/calendar.py</code> <pre><code>def is_leap_year_vectorized(years: npt.NDArray[np.int64]) -&gt; npt.NDArray[np.bool_]:\n    \"\"\"Vectorized check for leap years.\n\n    Args:\n        years: Array of Jalali years.\n\n    Returns:\n        Boolean array indicating leap years.\n    \"\"\"\n    remainders = years % 33\n    return np.isin(remainders, LEAP_YEAR_REMAINDERS)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.calendar.jalali_to_jdn","title":"jalali_to_jdn","text":"<pre><code>jalali_to_jdn(year: int, month: int, day: int) -&gt; int\n</code></pre> <p>Convert Jalali date to Julian Day Number.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Jalali year.</p> required <code>month</code> <code>int</code> <p>Jalali month (1-12).</p> required <code>day</code> <code>int</code> <p>Jalali day.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Julian Day Number.</p> Source code in <code>jalali_pandas/core/calendar.py</code> <pre><code>def jalali_to_jdn(year: int, month: int, day: int) -&gt; int:\n    \"\"\"Convert Jalali date to Julian Day Number.\n\n    Args:\n        year: Jalali year.\n        month: Jalali month (1-12).\n        day: Jalali day.\n\n    Returns:\n        Julian Day Number.\n    \"\"\"\n    # Algorithm based on the 2820-year cycle\n    a = year - 474 if year &gt; 0 else year - 473\n    b = a % 2820\n\n    jdn = (\n        day\n        + (month - 1) * 30\n        + min(6, month - 1)\n        + ((b * 682 - 110) // 2816)\n        + (b - 1) * 365\n        + (a // 2820) * 1029983\n        + 2121445\n    )\n    return jdn\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.calendar.jdn_to_jalali","title":"jdn_to_jalali","text":"<pre><code>jdn_to_jalali(jdn: int) -&gt; tuple[int, int, int]\n</code></pre> <p>Convert Julian Day Number to Jalali date.</p> <p>Parameters:</p> Name Type Description Default <code>jdn</code> <code>int</code> <p>Julian Day Number.</p> required <p>Returns:</p> Type Description <code>tuple[int, int, int]</code> <p>Tuple of (year, month, day).</p> Source code in <code>jalali_pandas/core/calendar.py</code> <pre><code>def jdn_to_jalali(jdn: int) -&gt; tuple[int, int, int]:\n    \"\"\"Convert Julian Day Number to Jalali date.\n\n    Args:\n        jdn: Julian Day Number.\n\n    Returns:\n        Tuple of (year, month, day).\n    \"\"\"\n    # Use the inverse of jalali_to_jdn algorithm\n    # Based on the 2820-year cycle\n    jdn_offset = jdn - 2121445  # Epoch matching jalali_to_jdn\n\n    cycle_2820 = jdn_offset // 1029983\n    day_in_cycle = jdn_offset % 1029983\n\n    if day_in_cycle &lt; 0:\n        cycle_2820 -= 1\n        day_in_cycle += 1029983\n\n    # Find year within cycle using binary search approach\n    # For year b within cycle, start of year (day=1, month=1) has offset:\n    # 1 + ((b*682-110)//2816) + (b-1)*365\n    def days_to_year_start(b: int) -&gt; int:\n        return 1 + ((b * 682 - 110) // 2816) + (b - 1) * 365\n\n    # Binary search for the year\n    lo, hi = 0, 2820\n    while lo &lt; hi:\n        mid = (lo + hi + 1) // 2\n        if days_to_year_start(mid) &lt;= day_in_cycle:\n            lo = mid\n        else:\n            hi = mid - 1\n\n    year_in_cycle = lo\n    remaining_days = day_in_cycle - days_to_year_start(year_in_cycle)\n\n    year = cycle_2820 * 2820 + year_in_cycle + 474\n\n    # Find month and day from remaining_days (0-indexed day within year)\n    if remaining_days &lt; 186:  # First 6 months (31 days each)\n        month = remaining_days // 31 + 1\n        day = remaining_days % 31 + 1\n    else:\n        remaining_days -= 186\n        if remaining_days &lt; 150:  # Months 7-11 (30 days each)\n            month = remaining_days // 30 + 7\n            day = remaining_days % 30 + 1\n        else:\n            remaining_days -= 150\n            month = 12\n            day = remaining_days + 1\n\n    return (year, month, day)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.calendar.quarter_of_month","title":"quarter_of_month","text":"<pre><code>quarter_of_month(month: int) -&gt; int\n</code></pre> <p>Get the quarter for a given month.</p> <p>Parameters:</p> Name Type Description Default <code>month</code> <code>int</code> <p>Jalali month (1-12).</p> required <p>Returns:</p> Type Description <code>int</code> <p>Quarter number (1-4).</p> Source code in <code>jalali_pandas/core/calendar.py</code> <pre><code>def quarter_of_month(month: int) -&gt; int:\n    \"\"\"Get the quarter for a given month.\n\n    Args:\n        month: Jalali month (1-12).\n\n    Returns:\n        Quarter number (1-4).\n    \"\"\"\n    return (month - 1) // 3 + 1\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.calendar.validate_jalali_date","title":"validate_jalali_date","text":"<pre><code>validate_jalali_date(year: int, month: int, day: int) -&gt; bool\n</code></pre> <p>Validate a Jalali date.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Jalali year.</p> required <code>month</code> <code>int</code> <p>Jalali month (1-12).</p> required <code>day</code> <code>int</code> <p>Jalali day.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the date is valid.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the date is invalid.</p> Source code in <code>jalali_pandas/core/calendar.py</code> <pre><code>def validate_jalali_date(year: int, month: int, day: int) -&gt; bool:\n    \"\"\"Validate a Jalali date.\n\n    Args:\n        year: Jalali year.\n        month: Jalali month (1-12).\n        day: Jalali day.\n\n    Returns:\n        True if the date is valid.\n\n    Raises:\n        ValueError: If the date is invalid.\n    \"\"\"\n    if not 1 &lt;= month &lt;= 12:\n        raise ValueError(f\"Month must be 1-12, got {month}\")\n\n    max_day = days_in_month(year, month)\n    if not 1 &lt;= day &lt;= max_day:\n        raise ValueError(f\"Day must be 1-{max_day} for month {month}, got {day}\")\n\n    return True\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.calendar.week_of_year","title":"week_of_year","text":"<pre><code>week_of_year(year: int, month: int, day: int) -&gt; int\n</code></pre> <p>Get the week number of the year.</p> <p>Week 1 is the first week containing at least 4 days. Weeks start on Saturday (Jalali calendar convention).</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Jalali year.</p> required <code>month</code> <code>int</code> <p>Jalali month (1-12).</p> required <code>day</code> <code>int</code> <p>Jalali day.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Week number (1-53).</p> Source code in <code>jalali_pandas/core/calendar.py</code> <pre><code>def week_of_year(year: int, month: int, day: int) -&gt; int:\n    \"\"\"Get the week number of the year.\n\n    Week 1 is the first week containing at least 4 days.\n    Weeks start on Saturday (Jalali calendar convention).\n\n    Args:\n        year: Jalali year.\n        month: Jalali month (1-12).\n        day: Jalali day.\n\n    Returns:\n        Week number (1-53).\n    \"\"\"\n    # Calculate day of year\n    doy = day_of_year(year, month, day)\n\n    # Calculate weekday of first day of year (0=Saturday)\n    first_day_weekday = weekday_of_jalali(year, 1, 1)\n\n    # ISO-like week calculation adapted for Saturday start\n    # Week 1 is the week containing the first Thursday (day 5 in 0-indexed Sat start)\n    week = (doy + first_day_weekday - 1) // 7 + 1\n\n    return week\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.calendar.weekday_of_jalali","title":"weekday_of_jalali","text":"<pre><code>weekday_of_jalali(year: int, month: int, day: int) -&gt; int\n</code></pre> <p>Get the weekday of a Jalali date.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Jalali year.</p> required <code>month</code> <code>int</code> <p>Jalali month (1-12).</p> required <code>day</code> <code>int</code> <p>Jalali day.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Weekday (0=Saturday, 6=Friday).</p> Source code in <code>jalali_pandas/core/calendar.py</code> <pre><code>def weekday_of_jalali(year: int, month: int, day: int) -&gt; int:\n    \"\"\"Get the weekday of a Jalali date.\n\n    Args:\n        year: Jalali year.\n        month: Jalali month (1-12).\n        day: Jalali day.\n\n    Returns:\n        Weekday (0=Saturday, 6=Friday).\n    \"\"\"\n    # Convert to Julian Day Number and calculate weekday\n    jdn = jalali_to_jdn(year, month, day)\n    # Adjust for Jalali weekday convention (0=Saturday, 6=Friday)\n    return (jdn + 2) % 7\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.conversion.datetime64_to_jalali","title":"datetime64_to_jalali","text":"<pre><code>datetime64_to_jalali(dt: NDArray[datetime64]) -&gt; tuple[NDArray[np.int64], NDArray[np.int64], NDArray[np.int64]]\n</code></pre> <p>Convert numpy datetime64 array to Jalali date components.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>NDArray[datetime64]</code> <p>Array of numpy datetime64 values.</p> required <p>Returns:</p> Type Description <code>tuple[NDArray[int64], NDArray[int64], NDArray[int64]]</code> <p>Tuple of (jalali_year, jalali_month, jalali_day) arrays.</p> Source code in <code>jalali_pandas/core/conversion.py</code> <pre><code>def datetime64_to_jalali(\n    dt: NDArray[np.datetime64],\n) -&gt; tuple[NDArray[np.int64], NDArray[np.int64], NDArray[np.int64]]:\n    \"\"\"Convert numpy datetime64 array to Jalali date components.\n\n    Args:\n        dt: Array of numpy datetime64 values.\n\n    Returns:\n        Tuple of (jalali_year, jalali_month, jalali_day) arrays.\n    \"\"\"\n    # Convert to pandas DatetimeIndex for easy component extraction\n    dti = pd.DatetimeIndex(dt)\n    year = dti.year.to_numpy().astype(np.int64)\n    month = dti.month.to_numpy().astype(np.int64)\n    day = dti.day.to_numpy().astype(np.int64)\n\n    return gregorian_to_jalali_vectorized(year, month, day, use_lookup=True)\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.conversion.gregorian_to_jalali_scalar","title":"gregorian_to_jalali_scalar  <code>cached</code>","text":"<pre><code>gregorian_to_jalali_scalar(year: int, month: int, day: int) -&gt; tuple[int, int, int]\n</code></pre> <p>Convert a single Gregorian date to Jalali.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Gregorian year.</p> required <code>month</code> <code>int</code> <p>Gregorian month (1-12).</p> required <code>day</code> <code>int</code> <p>Gregorian day.</p> required <p>Returns:</p> Type Description <code>tuple[int, int, int]</code> <p>Tuple of (jalali_year, jalali_month, jalali_day).</p> Source code in <code>jalali_pandas/core/conversion.py</code> <pre><code>@lru_cache(maxsize=16384)\ndef gregorian_to_jalali_scalar(year: int, month: int, day: int) -&gt; tuple[int, int, int]:\n    \"\"\"Convert a single Gregorian date to Jalali.\n\n    Args:\n        year: Gregorian year.\n        month: Gregorian month (1-12).\n        day: Gregorian day.\n\n    Returns:\n        Tuple of (jalali_year, jalali_month, jalali_day).\n    \"\"\"\n    if _LOOKUP_READY:\n        cached = _GREGORIAN_TO_JALALI_LOOKUP.get((year, month, day))\n        if cached is not None:\n            return cached\n\n    gdate = date(year, month, day)\n    jdate = jdatetime.date.fromgregorian(date=gdate)\n    return jdate.year, jdate.month, jdate.day\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.conversion.gregorian_to_jalali_vectorized","title":"gregorian_to_jalali_vectorized","text":"<pre><code>gregorian_to_jalali_vectorized(year: NDArray[int64], month: NDArray[int64], day: NDArray[int64], *, use_lookup: bool = True) -&gt; tuple[NDArray[np.int64], NDArray[np.int64], NDArray[np.int64]]\n</code></pre> <p>Convert arrays of Gregorian dates to Jalali.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>NDArray[int64]</code> <p>Array of Gregorian years.</p> required <code>month</code> <code>NDArray[int64]</code> <p>Array of Gregorian months (1-12).</p> required <code>day</code> <code>NDArray[int64]</code> <p>Array of Gregorian days.</p> required <p>Returns:</p> Type Description <code>tuple[NDArray[int64], NDArray[int64], NDArray[int64]]</code> <p>Tuple of (jalali_year, jalali_month, jalali_day) arrays.</p> Source code in <code>jalali_pandas/core/conversion.py</code> <pre><code>def gregorian_to_jalali_vectorized(\n    year: NDArray[np.int64],\n    month: NDArray[np.int64],\n    day: NDArray[np.int64],\n    *,\n    use_lookup: bool = True,\n) -&gt; tuple[NDArray[np.int64], NDArray[np.int64], NDArray[np.int64]]:\n    \"\"\"Convert arrays of Gregorian dates to Jalali.\n\n    Args:\n        year: Array of Gregorian years.\n        month: Array of Gregorian months (1-12).\n        day: Array of Gregorian days.\n\n    Returns:\n        Tuple of (jalali_year, jalali_month, jalali_day) arrays.\n    \"\"\"\n    n = len(year)\n    if use_lookup and n &gt;= _LOOKUP_MIN_SIZE:\n        _ensure_lookup_tables()\n\n    lookup = _GREGORIAN_TO_JALALI_LOOKUP if _LOOKUP_READY else None\n    j_year: NDArray[np.int64] = np.empty(n, dtype=np.int64)\n    j_month: NDArray[np.int64] = np.empty(n, dtype=np.int64)\n    j_day: NDArray[np.int64] = np.empty(n, dtype=np.int64)\n\n    for i in range(n):\n        key = (int(year[i]), int(month[i]), int(day[i]))\n        if lookup is not None:\n            cached = lookup.get(key)\n            if cached is not None:\n                jy, jm, jd = cached\n            else:\n                jy, jm, jd = gregorian_to_jalali_scalar(*key)\n        else:\n            jy, jm, jd = gregorian_to_jalali_scalar(*key)\n        j_year[i] = jy\n        j_month[i] = jm\n        j_day[i] = jd\n\n    return j_year, j_month, j_day\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.conversion.jalali_to_datetime64","title":"jalali_to_datetime64","text":"<pre><code>jalali_to_datetime64(year: NDArray[int64], month: NDArray[int64], day: NDArray[int64], hour: NDArray[int64] | None = None, minute: NDArray[int64] | None = None, second: NDArray[int64] | None = None, microsecond: NDArray[int64] | None = None, nanosecond: NDArray[int64] | None = None) -&gt; NDArray[np.datetime64]\n</code></pre> <p>Convert Jalali date components to numpy datetime64 array.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>NDArray[int64]</code> <p>Array of Jalali years.</p> required <code>month</code> <code>NDArray[int64]</code> <p>Array of Jalali months (1-12).</p> required <code>day</code> <code>NDArray[int64]</code> <p>Array of Jalali days.</p> required <code>hour</code> <code>NDArray[int64] | None</code> <p>Optional array of hours.</p> <code>None</code> <code>minute</code> <code>NDArray[int64] | None</code> <p>Optional array of minutes.</p> <code>None</code> <code>second</code> <code>NDArray[int64] | None</code> <p>Optional array of seconds.</p> <code>None</code> <code>microsecond</code> <code>NDArray[int64] | None</code> <p>Optional array of microseconds.</p> <code>None</code> <code>nanosecond</code> <code>NDArray[int64] | None</code> <p>Optional array of nanoseconds.</p> <code>None</code> <p>Returns:</p> Type Description <code>NDArray[datetime64]</code> <p>Array of numpy datetime64 values.</p> Source code in <code>jalali_pandas/core/conversion.py</code> <pre><code>def jalali_to_datetime64(\n    year: NDArray[np.int64],\n    month: NDArray[np.int64],\n    day: NDArray[np.int64],\n    hour: NDArray[np.int64] | None = None,\n    minute: NDArray[np.int64] | None = None,\n    second: NDArray[np.int64] | None = None,\n    microsecond: NDArray[np.int64] | None = None,\n    nanosecond: NDArray[np.int64] | None = None,\n) -&gt; NDArray[np.datetime64]:\n    \"\"\"Convert Jalali date components to numpy datetime64 array.\n\n    Args:\n        year: Array of Jalali years.\n        month: Array of Jalali months (1-12).\n        day: Array of Jalali days.\n        hour: Optional array of hours.\n        minute: Optional array of minutes.\n        second: Optional array of seconds.\n        microsecond: Optional array of microseconds.\n        nanosecond: Optional array of nanoseconds.\n\n    Returns:\n        Array of numpy datetime64 values.\n    \"\"\"\n    g_year, g_month, g_day = jalali_to_gregorian_vectorized(\n        year, month, day, use_lookup=True\n    )\n\n    # Build datetime strings\n    n = len(year)\n    if hour is None:\n        hour = np.zeros(n, dtype=np.int64)\n    if minute is None:\n        minute = np.zeros(n, dtype=np.int64)\n    if second is None:\n        second = np.zeros(n, dtype=np.int64)\n    if microsecond is None:\n        microsecond = np.zeros(n, dtype=np.int64)\n    if nanosecond is None:\n        nanosecond = np.zeros(n, dtype=np.int64)\n\n    # Create datetime64 array\n    # Convert to nanoseconds since epoch\n    dates = pd.to_datetime(\n        {\n            \"year\": g_year,\n            \"month\": g_month,\n            \"day\": g_day,\n            \"hour\": hour,\n            \"minute\": minute,\n            \"second\": second,\n        }\n    )\n\n    # Add microseconds and nanoseconds\n    result = (\n        dates\n        + pd.to_timedelta(microsecond, unit=\"us\")\n        + pd.to_timedelta(nanosecond, unit=\"ns\")\n    )\n\n    return result.to_numpy()\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.conversion.jalali_to_gregorian_scalar","title":"jalali_to_gregorian_scalar  <code>cached</code>","text":"<pre><code>jalali_to_gregorian_scalar(year: int, month: int, day: int) -&gt; tuple[int, int, int]\n</code></pre> <p>Convert a single Jalali date to Gregorian.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Jalali year.</p> required <code>month</code> <code>int</code> <p>Jalali month (1-12).</p> required <code>day</code> <code>int</code> <p>Jalali day.</p> required <p>Returns:</p> Type Description <code>tuple[int, int, int]</code> <p>Tuple of (gregorian_year, gregorian_month, gregorian_day).</p> Source code in <code>jalali_pandas/core/conversion.py</code> <pre><code>@lru_cache(maxsize=16384)\ndef jalali_to_gregorian_scalar(year: int, month: int, day: int) -&gt; tuple[int, int, int]:\n    \"\"\"Convert a single Jalali date to Gregorian.\n\n    Args:\n        year: Jalali year.\n        month: Jalali month (1-12).\n        day: Jalali day.\n\n    Returns:\n        Tuple of (gregorian_year, gregorian_month, gregorian_day).\n    \"\"\"\n    if _LOOKUP_READY:\n        cached = _JALALI_TO_GREGORIAN_LOOKUP.get((year, month, day))\n        if cached is not None:\n            return cached\n\n    jdate = jdatetime.date(year, month, day)\n    gdate = jdate.togregorian()\n    return gdate.year, gdate.month, gdate.day\n</code></pre>"},{"location":"en/api/core/#jalali_pandas.core.conversion.jalali_to_gregorian_vectorized","title":"jalali_to_gregorian_vectorized","text":"<pre><code>jalali_to_gregorian_vectorized(year: NDArray[int64], month: NDArray[int64], day: NDArray[int64], *, use_lookup: bool = True) -&gt; tuple[NDArray[np.int64], NDArray[np.int64], NDArray[np.int64]]\n</code></pre> <p>Convert arrays of Jalali dates to Gregorian.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>NDArray[int64]</code> <p>Array of Jalali years.</p> required <code>month</code> <code>NDArray[int64]</code> <p>Array of Jalali months (1-12).</p> required <code>day</code> <code>NDArray[int64]</code> <p>Array of Jalali days.</p> required <p>Returns:</p> Type Description <code>tuple[NDArray[int64], NDArray[int64], NDArray[int64]]</code> <p>Tuple of (gregorian_year, gregorian_month, gregorian_day) arrays.</p> Source code in <code>jalali_pandas/core/conversion.py</code> <pre><code>def jalali_to_gregorian_vectorized(\n    year: NDArray[np.int64],\n    month: NDArray[np.int64],\n    day: NDArray[np.int64],\n    *,\n    use_lookup: bool = True,\n) -&gt; tuple[NDArray[np.int64], NDArray[np.int64], NDArray[np.int64]]:\n    \"\"\"Convert arrays of Jalali dates to Gregorian.\n\n    Args:\n        year: Array of Jalali years.\n        month: Array of Jalali months (1-12).\n        day: Array of Jalali days.\n\n    Returns:\n        Tuple of (gregorian_year, gregorian_month, gregorian_day) arrays.\n    \"\"\"\n    n = len(year)\n    if use_lookup and n &gt;= _LOOKUP_MIN_SIZE:\n        _ensure_lookup_tables()\n\n    lookup = _JALALI_TO_GREGORIAN_LOOKUP if _LOOKUP_READY else None\n    g_year: NDArray[np.int64] = np.empty(n, dtype=np.int64)\n    g_month: NDArray[np.int64] = np.empty(n, dtype=np.int64)\n    g_day: NDArray[np.int64] = np.empty(n, dtype=np.int64)\n\n    for i in range(n):\n        key = (int(year[i]), int(month[i]), int(day[i]))\n        if lookup is not None:\n            cached = lookup.get(key)\n            if cached is not None:\n                gy, gm, gd = cached\n            else:\n                gy, gm, gd = jalali_to_gregorian_scalar(*key)\n        else:\n            gy, gm, gd = jalali_to_gregorian_scalar(*key)\n        g_year[i] = gy\n        g_month[i] = gm\n        g_day[i] = gd\n\n    return g_year, g_month, g_day\n</code></pre>"},{"location":"en/api/offsets/","title":"Offsets","text":"<p>Jalali calendar frequency offsets.</p> <p>Frequency alias registration for Jalali offsets.</p> <p>This module provides frequency alias registration and parsing for Jalali calendar offsets, enabling string-based frequency specifications like \"JME\", \"2JQE\", etc.</p> <p>Base class for Jalali calendar offsets.</p> <p>Jalali month offsets.</p> <p>Jalali quarter offsets.</p> <p>Jalali year offsets.</p> <p>Jalali week offset.</p>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliMonthBegin","title":"JalaliMonthBegin","text":"<p>               Bases: <code>JalaliOffset</code></p> <p>Offset to the beginning of a Jalali month.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>class JalaliMonthBegin(JalaliOffset):\n    \"\"\"Offset to the beginning of a Jalali month.\"\"\"\n\n    _prefix = \"JMS\"\n\n    def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Add months to timestamp, landing on month start.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if not isinstance(other, JalaliTimestamp):\n            return NotImplemented\n\n        # Calculate target month\n        total_months = other.year * 12 + other.month - 1 + self._n\n        new_year = total_months // 12\n        new_month = total_months % 12 + 1\n\n        return JalaliTimestamp(\n            year=new_year,\n            month=new_month,\n            day=1,\n            hour=other.hour if not self._normalize else 0,\n            minute=other.minute if not self._normalize else 0,\n            second=other.second if not self._normalize else 0,\n            microsecond=other.microsecond if not self._normalize else 0,\n            nanosecond=other.nanosecond if not self._normalize else 0,\n            tzinfo=other.tzinfo,\n        )\n\n    def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Subtract months from timestamp.\"\"\"\n        return self.__neg__().__add__(other)\n\n    def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll forward to next month start if not already on one.\"\"\"\n        if self.is_on_offset(dt):\n            return dt\n        return self.__add__(dt)\n\n    def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll back to previous month start.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if self.is_on_offset(dt):\n            return dt\n        return JalaliTimestamp(\n            year=dt.year,\n            month=dt.month,\n            day=1,\n            hour=dt.hour if not self._normalize else 0,\n            minute=dt.minute if not self._normalize else 0,\n            second=dt.second if not self._normalize else 0,\n            tzinfo=dt.tzinfo,\n        )\n\n    def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n        \"\"\"Check if date is on month start.\"\"\"\n        return dt.day == 1\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliMonthBegin.__add__","title":"__add__","text":"<pre><code>__add__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Add months to timestamp, landing on month start.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Add months to timestamp, landing on month start.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if not isinstance(other, JalaliTimestamp):\n        return NotImplemented\n\n    # Calculate target month\n    total_months = other.year * 12 + other.month - 1 + self._n\n    new_year = total_months // 12\n    new_month = total_months % 12 + 1\n\n    return JalaliTimestamp(\n        year=new_year,\n        month=new_month,\n        day=1,\n        hour=other.hour if not self._normalize else 0,\n        minute=other.minute if not self._normalize else 0,\n        second=other.second if not self._normalize else 0,\n        microsecond=other.microsecond if not self._normalize else 0,\n        nanosecond=other.nanosecond if not self._normalize else 0,\n        tzinfo=other.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliMonthBegin.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Subtract months from timestamp.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Subtract months from timestamp.\"\"\"\n    return self.__neg__().__add__(other)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliMonthBegin.is_on_offset","title":"is_on_offset","text":"<pre><code>is_on_offset(dt: JalaliTimestamp) -&gt; bool\n</code></pre> <p>Check if date is on month start.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n    \"\"\"Check if date is on month start.\"\"\"\n    return dt.day == 1\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliMonthBegin.rollback","title":"rollback","text":"<pre><code>rollback(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll back to previous month start.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll back to previous month start.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if self.is_on_offset(dt):\n        return dt\n    return JalaliTimestamp(\n        year=dt.year,\n        month=dt.month,\n        day=1,\n        hour=dt.hour if not self._normalize else 0,\n        minute=dt.minute if not self._normalize else 0,\n        second=dt.second if not self._normalize else 0,\n        tzinfo=dt.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliMonthBegin.rollforward","title":"rollforward","text":"<pre><code>rollforward(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll forward to next month start if not already on one.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll forward to next month start if not already on one.\"\"\"\n    if self.is_on_offset(dt):\n        return dt\n    return self.__add__(dt)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliMonthEnd","title":"JalaliMonthEnd","text":"<p>               Bases: <code>JalaliOffset</code></p> <p>Offset to the end of a Jalali month.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>class JalaliMonthEnd(JalaliOffset):\n    \"\"\"Offset to the end of a Jalali month.\"\"\"\n\n    _prefix = \"JME\"\n\n    def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Add months to timestamp, landing on month end.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if not isinstance(other, JalaliTimestamp):\n            return NotImplemented\n\n        # Calculate target month\n        total_months = other.year * 12 + other.month - 1 + self._n\n        new_year = total_months // 12\n        new_month = total_months % 12 + 1\n        new_day = days_in_month(new_year, new_month)\n\n        return JalaliTimestamp(\n            year=new_year,\n            month=new_month,\n            day=new_day,\n            hour=other.hour if not self._normalize else 0,\n            minute=other.minute if not self._normalize else 0,\n            second=other.second if not self._normalize else 0,\n            microsecond=other.microsecond if not self._normalize else 0,\n            nanosecond=other.nanosecond if not self._normalize else 0,\n            tzinfo=other.tzinfo,\n        )\n\n    def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Subtract months from timestamp.\"\"\"\n        return self.__neg__().__add__(other)\n\n    def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll forward to next month end if not already on one.\"\"\"\n        if self.is_on_offset(dt):\n            return dt\n        return self._get_month_end(dt)\n\n    def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll back to previous month end.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if self.is_on_offset(dt):\n            return dt\n\n        # Go to previous month's end\n        if dt.month == 1:\n            new_year = dt.year - 1\n            new_month = 12\n        else:\n            new_year = dt.year\n            new_month = dt.month - 1\n\n        new_day = days_in_month(new_year, new_month)\n        return JalaliTimestamp(\n            year=new_year,\n            month=new_month,\n            day=new_day,\n            hour=dt.hour if not self._normalize else 0,\n            minute=dt.minute if not self._normalize else 0,\n            second=dt.second if not self._normalize else 0,\n            tzinfo=dt.tzinfo,\n        )\n\n    def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n        \"\"\"Check if date is on month end.\"\"\"\n        return dt.day == days_in_month(dt.year, dt.month)\n\n    def _get_month_end(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Get the end of the current month.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        return JalaliTimestamp(\n            year=dt.year,\n            month=dt.month,\n            day=days_in_month(dt.year, dt.month),\n            hour=dt.hour if not self._normalize else 0,\n            minute=dt.minute if not self._normalize else 0,\n            second=dt.second if not self._normalize else 0,\n            tzinfo=dt.tzinfo,\n        )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliMonthEnd.__add__","title":"__add__","text":"<pre><code>__add__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Add months to timestamp, landing on month end.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Add months to timestamp, landing on month end.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if not isinstance(other, JalaliTimestamp):\n        return NotImplemented\n\n    # Calculate target month\n    total_months = other.year * 12 + other.month - 1 + self._n\n    new_year = total_months // 12\n    new_month = total_months % 12 + 1\n    new_day = days_in_month(new_year, new_month)\n\n    return JalaliTimestamp(\n        year=new_year,\n        month=new_month,\n        day=new_day,\n        hour=other.hour if not self._normalize else 0,\n        minute=other.minute if not self._normalize else 0,\n        second=other.second if not self._normalize else 0,\n        microsecond=other.microsecond if not self._normalize else 0,\n        nanosecond=other.nanosecond if not self._normalize else 0,\n        tzinfo=other.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliMonthEnd.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Subtract months from timestamp.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Subtract months from timestamp.\"\"\"\n    return self.__neg__().__add__(other)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliMonthEnd.is_on_offset","title":"is_on_offset","text":"<pre><code>is_on_offset(dt: JalaliTimestamp) -&gt; bool\n</code></pre> <p>Check if date is on month end.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n    \"\"\"Check if date is on month end.\"\"\"\n    return dt.day == days_in_month(dt.year, dt.month)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliMonthEnd.rollback","title":"rollback","text":"<pre><code>rollback(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll back to previous month end.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll back to previous month end.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if self.is_on_offset(dt):\n        return dt\n\n    # Go to previous month's end\n    if dt.month == 1:\n        new_year = dt.year - 1\n        new_month = 12\n    else:\n        new_year = dt.year\n        new_month = dt.month - 1\n\n    new_day = days_in_month(new_year, new_month)\n    return JalaliTimestamp(\n        year=new_year,\n        month=new_month,\n        day=new_day,\n        hour=dt.hour if not self._normalize else 0,\n        minute=dt.minute if not self._normalize else 0,\n        second=dt.second if not self._normalize else 0,\n        tzinfo=dt.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliMonthEnd.rollforward","title":"rollforward","text":"<pre><code>rollforward(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll forward to next month end if not already on one.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll forward to next month end if not already on one.\"\"\"\n    if self.is_on_offset(dt):\n        return dt\n    return self._get_month_end(dt)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliOffset","title":"JalaliOffset","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for Jalali calendar-aware offsets.</p> <p>This class provides the foundation for implementing calendar-aware date offsets that respect Jalali calendar rules.</p> <p>Attributes:</p> Name Type Description <code>n</code> <code>int</code> <p>Number of periods.</p> <code>normalize</code> <code>bool</code> <p>Whether to normalize to midnight.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>class JalaliOffset(ABC):\n    \"\"\"Abstract base class for Jalali calendar-aware offsets.\n\n    This class provides the foundation for implementing calendar-aware\n    date offsets that respect Jalali calendar rules.\n\n    Attributes:\n        n: Number of periods.\n        normalize: Whether to normalize to midnight.\n    \"\"\"\n\n    _prefix: str = \"J\"\n    _attributes: tuple[str, ...] = (\"n\", \"normalize\")\n\n    def __init__(self, n: int = 1, normalize: bool = False) -&gt; None:\n        \"\"\"Initialize JalaliOffset.\n\n        Args:\n            n: Number of periods. Defaults to 1.\n            normalize: Whether to normalize to midnight. Defaults to False.\n        \"\"\"\n        self._n = n\n        self._normalize = normalize\n\n    @property\n    def n(self) -&gt; int:\n        \"\"\"Number of periods.\"\"\"\n        return self._n\n\n    @property\n    def normalize(self) -&gt; bool:\n        \"\"\"Whether to normalize to midnight.\"\"\"\n        return self._normalize\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Return the name of the offset.\"\"\"\n        return f\"{self._prefix}{abs(self._n)}\"\n\n    @property\n    def freqstr(self) -&gt; str:\n        \"\"\"Return the frequency string.\"\"\"\n        return self.name\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation.\"\"\"\n        return f\"&lt;{self.__class__.__name__}: n={self._n}&gt;\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality.\"\"\"\n        if isinstance(other, JalaliOffset):\n            return type(self) is type(other) and self._n == other._n\n        return False\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Hash for use in sets and dicts.\"\"\"\n        return hash((type(self).__name__, self._n))\n\n    def __neg__(self) -&gt; JalaliOffset:\n        \"\"\"Return negated offset.\"\"\"\n        return type(self)(n=-self._n, normalize=self._normalize)\n\n    def __mul__(self, other: int) -&gt; JalaliOffset:\n        \"\"\"Multiply offset by integer.\"\"\"\n        if isinstance(other, int):\n            return type(self)(n=self._n * other, normalize=self._normalize)\n        return NotImplemented\n\n    def __rmul__(self, other: int) -&gt; JalaliOffset:\n        \"\"\"Right multiply offset by integer.\"\"\"\n        return self.__mul__(other)\n\n    @abstractmethod\n    def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Add offset to a JalaliTimestamp.\"\"\"\n        ...\n\n    def __radd__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Right add offset to a JalaliTimestamp.\"\"\"\n        return self.__add__(other)\n\n    @abstractmethod\n    def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Subtract offset from a JalaliTimestamp.\"\"\"\n        ...\n\n    @abstractmethod\n    def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll forward to next valid date.\n\n        Args:\n            dt: JalaliTimestamp to roll forward.\n\n        Returns:\n            Rolled forward JalaliTimestamp.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll back to previous valid date.\n\n        Args:\n            dt: JalaliTimestamp to roll back.\n\n        Returns:\n            Rolled back JalaliTimestamp.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n        \"\"\"Check if date is on offset boundary.\n\n        Args:\n            dt: JalaliTimestamp to check.\n\n        Returns:\n            True if on offset boundary.\n        \"\"\"\n        ...\n\n    def _apply(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Apply offset to timestamp.\n\n        Args:\n            other: JalaliTimestamp to apply offset to.\n\n        Returns:\n            New JalaliTimestamp with offset applied.\n        \"\"\"\n        result = self.__add__(other)\n        if self._normalize:\n            result = result.normalize()\n        return result\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliOffset.freqstr","title":"freqstr  <code>property</code>","text":"<pre><code>freqstr: str\n</code></pre> <p>Return the frequency string.</p>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliOffset.n","title":"n  <code>property</code>","text":"<pre><code>n: int\n</code></pre> <p>Number of periods.</p>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliOffset.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Return the name of the offset.</p>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliOffset.normalize","title":"normalize  <code>property</code>","text":"<pre><code>normalize: bool\n</code></pre> <p>Whether to normalize to midnight.</p>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliOffset.__add__","title":"__add__  <code>abstractmethod</code>","text":"<pre><code>__add__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Add offset to a JalaliTimestamp.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>@abstractmethod\ndef __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Add offset to a JalaliTimestamp.\"\"\"\n    ...\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliOffset.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality.\"\"\"\n    if isinstance(other, JalaliOffset):\n        return type(self) is type(other) and self._n == other._n\n    return False\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliOffset.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Hash for use in sets and dicts.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Hash for use in sets and dicts.\"\"\"\n    return hash((type(self).__name__, self._n))\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliOffset.__init__","title":"__init__","text":"<pre><code>__init__(n: int = 1, normalize: bool = False) -&gt; None\n</code></pre> <p>Initialize JalaliOffset.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of periods. Defaults to 1.</p> <code>1</code> <code>normalize</code> <code>bool</code> <p>Whether to normalize to midnight. Defaults to False.</p> <code>False</code> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>def __init__(self, n: int = 1, normalize: bool = False) -&gt; None:\n    \"\"\"Initialize JalaliOffset.\n\n    Args:\n        n: Number of periods. Defaults to 1.\n        normalize: Whether to normalize to midnight. Defaults to False.\n    \"\"\"\n    self._n = n\n    self._normalize = normalize\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliOffset.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: int) -&gt; JalaliOffset\n</code></pre> <p>Multiply offset by integer.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>def __mul__(self, other: int) -&gt; JalaliOffset:\n    \"\"\"Multiply offset by integer.\"\"\"\n    if isinstance(other, int):\n        return type(self)(n=self._n * other, normalize=self._normalize)\n    return NotImplemented\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliOffset.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; JalaliOffset\n</code></pre> <p>Return negated offset.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>def __neg__(self) -&gt; JalaliOffset:\n    \"\"\"Return negated offset.\"\"\"\n    return type(self)(n=-self._n, normalize=self._normalize)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliOffset.__radd__","title":"__radd__","text":"<pre><code>__radd__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Right add offset to a JalaliTimestamp.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>def __radd__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Right add offset to a JalaliTimestamp.\"\"\"\n    return self.__add__(other)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliOffset.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>String representation.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"String representation.\"\"\"\n    return f\"&lt;{self.__class__.__name__}: n={self._n}&gt;\"\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliOffset.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other: int) -&gt; JalaliOffset\n</code></pre> <p>Right multiply offset by integer.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>def __rmul__(self, other: int) -&gt; JalaliOffset:\n    \"\"\"Right multiply offset by integer.\"\"\"\n    return self.__mul__(other)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliOffset.__sub__","title":"__sub__  <code>abstractmethod</code>","text":"<pre><code>__sub__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Subtract offset from a JalaliTimestamp.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>@abstractmethod\ndef __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Subtract offset from a JalaliTimestamp.\"\"\"\n    ...\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliOffset.is_on_offset","title":"is_on_offset  <code>abstractmethod</code>","text":"<pre><code>is_on_offset(dt: JalaliTimestamp) -&gt; bool\n</code></pre> <p>Check if date is on offset boundary.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>JalaliTimestamp</code> <p>JalaliTimestamp to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if on offset boundary.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>@abstractmethod\ndef is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n    \"\"\"Check if date is on offset boundary.\n\n    Args:\n        dt: JalaliTimestamp to check.\n\n    Returns:\n        True if on offset boundary.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliOffset.rollback","title":"rollback  <code>abstractmethod</code>","text":"<pre><code>rollback(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll back to previous valid date.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>JalaliTimestamp</code> <p>JalaliTimestamp to roll back.</p> required <p>Returns:</p> Type Description <code>JalaliTimestamp</code> <p>Rolled back JalaliTimestamp.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>@abstractmethod\ndef rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll back to previous valid date.\n\n    Args:\n        dt: JalaliTimestamp to roll back.\n\n    Returns:\n        Rolled back JalaliTimestamp.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliOffset.rollforward","title":"rollforward  <code>abstractmethod</code>","text":"<pre><code>rollforward(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll forward to next valid date.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>JalaliTimestamp</code> <p>JalaliTimestamp to roll forward.</p> required <p>Returns:</p> Type Description <code>JalaliTimestamp</code> <p>Rolled forward JalaliTimestamp.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>@abstractmethod\ndef rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll forward to next valid date.\n\n    Args:\n        dt: JalaliTimestamp to roll forward.\n\n    Returns:\n        Rolled forward JalaliTimestamp.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliQuarterBegin","title":"JalaliQuarterBegin","text":"<p>               Bases: <code>JalaliOffset</code></p> <p>Offset to the beginning of a Jalali quarter.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>class JalaliQuarterBegin(JalaliOffset):\n    \"\"\"Offset to the beginning of a Jalali quarter.\"\"\"\n\n    _prefix = \"JQS\"\n\n    def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Add quarters to timestamp, landing on quarter start.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if not isinstance(other, JalaliTimestamp):\n            return NotImplemented\n\n        # Calculate current quarter (0-indexed)\n        current_quarter = (other.month - 1) // 3\n\n        # Calculate target quarter\n        total_quarters = other.year * 4 + current_quarter + self._n\n        new_year = total_quarters // 4\n        new_quarter = total_quarters % 4\n        new_month = new_quarter * 3 + 1\n\n        return JalaliTimestamp(\n            year=new_year,\n            month=new_month,\n            day=1,\n            hour=other.hour if not self._normalize else 0,\n            minute=other.minute if not self._normalize else 0,\n            second=other.second if not self._normalize else 0,\n            microsecond=other.microsecond if not self._normalize else 0,\n            nanosecond=other.nanosecond if not self._normalize else 0,\n            tzinfo=other.tzinfo,\n        )\n\n    def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Subtract quarters from timestamp.\"\"\"\n        return self.__neg__().__add__(other)\n\n    def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll forward to next quarter start if not already on one.\"\"\"\n        if self.is_on_offset(dt):\n            return dt\n        return self.__add__(dt)\n\n    def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll back to current quarter start.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if self.is_on_offset(dt):\n            return dt\n\n        quarter_start_month = ((dt.month - 1) // 3) * 3 + 1\n        return JalaliTimestamp(\n            year=dt.year,\n            month=quarter_start_month,\n            day=1,\n            hour=dt.hour if not self._normalize else 0,\n            minute=dt.minute if not self._normalize else 0,\n            second=dt.second if not self._normalize else 0,\n            tzinfo=dt.tzinfo,\n        )\n\n    def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n        \"\"\"Check if date is on quarter start.\"\"\"\n        return dt.month in QUARTER_START_MONTHS and dt.day == 1\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliQuarterBegin.__add__","title":"__add__","text":"<pre><code>__add__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Add quarters to timestamp, landing on quarter start.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Add quarters to timestamp, landing on quarter start.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if not isinstance(other, JalaliTimestamp):\n        return NotImplemented\n\n    # Calculate current quarter (0-indexed)\n    current_quarter = (other.month - 1) // 3\n\n    # Calculate target quarter\n    total_quarters = other.year * 4 + current_quarter + self._n\n    new_year = total_quarters // 4\n    new_quarter = total_quarters % 4\n    new_month = new_quarter * 3 + 1\n\n    return JalaliTimestamp(\n        year=new_year,\n        month=new_month,\n        day=1,\n        hour=other.hour if not self._normalize else 0,\n        minute=other.minute if not self._normalize else 0,\n        second=other.second if not self._normalize else 0,\n        microsecond=other.microsecond if not self._normalize else 0,\n        nanosecond=other.nanosecond if not self._normalize else 0,\n        tzinfo=other.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliQuarterBegin.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Subtract quarters from timestamp.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Subtract quarters from timestamp.\"\"\"\n    return self.__neg__().__add__(other)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliQuarterBegin.is_on_offset","title":"is_on_offset","text":"<pre><code>is_on_offset(dt: JalaliTimestamp) -&gt; bool\n</code></pre> <p>Check if date is on quarter start.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n    \"\"\"Check if date is on quarter start.\"\"\"\n    return dt.month in QUARTER_START_MONTHS and dt.day == 1\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliQuarterBegin.rollback","title":"rollback","text":"<pre><code>rollback(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll back to current quarter start.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll back to current quarter start.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if self.is_on_offset(dt):\n        return dt\n\n    quarter_start_month = ((dt.month - 1) // 3) * 3 + 1\n    return JalaliTimestamp(\n        year=dt.year,\n        month=quarter_start_month,\n        day=1,\n        hour=dt.hour if not self._normalize else 0,\n        minute=dt.minute if not self._normalize else 0,\n        second=dt.second if not self._normalize else 0,\n        tzinfo=dt.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliQuarterBegin.rollforward","title":"rollforward","text":"<pre><code>rollforward(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll forward to next quarter start if not already on one.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll forward to next quarter start if not already on one.\"\"\"\n    if self.is_on_offset(dt):\n        return dt\n    return self.__add__(dt)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliQuarterEnd","title":"JalaliQuarterEnd","text":"<p>               Bases: <code>JalaliOffset</code></p> <p>Offset to the end of a Jalali quarter.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>class JalaliQuarterEnd(JalaliOffset):\n    \"\"\"Offset to the end of a Jalali quarter.\"\"\"\n\n    _prefix = \"JQE\"\n\n    def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Add quarters to timestamp, landing on quarter end.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if not isinstance(other, JalaliTimestamp):\n            return NotImplemented\n\n        # Calculate current quarter (0-indexed)\n        current_quarter = (other.month - 1) // 3\n\n        # Calculate target quarter\n        total_quarters = other.year * 4 + current_quarter + self._n\n        new_year = total_quarters // 4\n        new_quarter = total_quarters % 4\n        new_month = (new_quarter + 1) * 3  # End month of quarter\n        new_day = days_in_month(new_year, new_month)\n\n        return JalaliTimestamp(\n            year=new_year,\n            month=new_month,\n            day=new_day,\n            hour=other.hour if not self._normalize else 0,\n            minute=other.minute if not self._normalize else 0,\n            second=other.second if not self._normalize else 0,\n            microsecond=other.microsecond if not self._normalize else 0,\n            nanosecond=other.nanosecond if not self._normalize else 0,\n            tzinfo=other.tzinfo,\n        )\n\n    def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Subtract quarters from timestamp.\"\"\"\n        return self.__neg__().__add__(other)\n\n    def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll forward to next quarter end if not already on one.\"\"\"\n        if self.is_on_offset(dt):\n            return dt\n        return self._get_quarter_end(dt)\n\n    def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll back to previous quarter end.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if self.is_on_offset(dt):\n            return dt\n\n        # Go to previous quarter's end\n        current_quarter = (dt.month - 1) // 3\n        if current_quarter == 0:\n            new_year = dt.year - 1\n            new_month = 12\n        else:\n            new_year = dt.year\n            new_month = current_quarter * 3\n\n        new_day = days_in_month(new_year, new_month)\n        return JalaliTimestamp(\n            year=new_year,\n            month=new_month,\n            day=new_day,\n            hour=dt.hour if not self._normalize else 0,\n            minute=dt.minute if not self._normalize else 0,\n            second=dt.second if not self._normalize else 0,\n            tzinfo=dt.tzinfo,\n        )\n\n    def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n        \"\"\"Check if date is on quarter end.\"\"\"\n        if dt.month not in QUARTER_END_MONTHS:\n            return False\n        return dt.day == days_in_month(dt.year, dt.month)\n\n    def _get_quarter_end(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Get the end of the current quarter.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        quarter_end_month = ((dt.month - 1) // 3 + 1) * 3\n        return JalaliTimestamp(\n            year=dt.year,\n            month=quarter_end_month,\n            day=days_in_month(dt.year, quarter_end_month),\n            hour=dt.hour if not self._normalize else 0,\n            minute=dt.minute if not self._normalize else 0,\n            second=dt.second if not self._normalize else 0,\n            tzinfo=dt.tzinfo,\n        )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliQuarterEnd.__add__","title":"__add__","text":"<pre><code>__add__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Add quarters to timestamp, landing on quarter end.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Add quarters to timestamp, landing on quarter end.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if not isinstance(other, JalaliTimestamp):\n        return NotImplemented\n\n    # Calculate current quarter (0-indexed)\n    current_quarter = (other.month - 1) // 3\n\n    # Calculate target quarter\n    total_quarters = other.year * 4 + current_quarter + self._n\n    new_year = total_quarters // 4\n    new_quarter = total_quarters % 4\n    new_month = (new_quarter + 1) * 3  # End month of quarter\n    new_day = days_in_month(new_year, new_month)\n\n    return JalaliTimestamp(\n        year=new_year,\n        month=new_month,\n        day=new_day,\n        hour=other.hour if not self._normalize else 0,\n        minute=other.minute if not self._normalize else 0,\n        second=other.second if not self._normalize else 0,\n        microsecond=other.microsecond if not self._normalize else 0,\n        nanosecond=other.nanosecond if not self._normalize else 0,\n        tzinfo=other.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliQuarterEnd.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Subtract quarters from timestamp.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Subtract quarters from timestamp.\"\"\"\n    return self.__neg__().__add__(other)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliQuarterEnd.is_on_offset","title":"is_on_offset","text":"<pre><code>is_on_offset(dt: JalaliTimestamp) -&gt; bool\n</code></pre> <p>Check if date is on quarter end.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n    \"\"\"Check if date is on quarter end.\"\"\"\n    if dt.month not in QUARTER_END_MONTHS:\n        return False\n    return dt.day == days_in_month(dt.year, dt.month)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliQuarterEnd.rollback","title":"rollback","text":"<pre><code>rollback(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll back to previous quarter end.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll back to previous quarter end.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if self.is_on_offset(dt):\n        return dt\n\n    # Go to previous quarter's end\n    current_quarter = (dt.month - 1) // 3\n    if current_quarter == 0:\n        new_year = dt.year - 1\n        new_month = 12\n    else:\n        new_year = dt.year\n        new_month = current_quarter * 3\n\n    new_day = days_in_month(new_year, new_month)\n    return JalaliTimestamp(\n        year=new_year,\n        month=new_month,\n        day=new_day,\n        hour=dt.hour if not self._normalize else 0,\n        minute=dt.minute if not self._normalize else 0,\n        second=dt.second if not self._normalize else 0,\n        tzinfo=dt.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliQuarterEnd.rollforward","title":"rollforward","text":"<pre><code>rollforward(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll forward to next quarter end if not already on one.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll forward to next quarter end if not already on one.\"\"\"\n    if self.is_on_offset(dt):\n        return dt\n    return self._get_quarter_end(dt)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliWeek","title":"JalaliWeek","text":"<p>               Bases: <code>JalaliOffset</code></p> <p>Offset to a specific day of the Jalali week.</p> <p>The Jalali week starts on Saturday (weekday=0) and ends on Friday (weekday=6).</p> <p>Attributes:</p> Name Type Description <code>weekday</code> <code>int</code> <p>The target weekday (0=Saturday, 6=Friday). Defaults to 0 (Saturday).</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>class JalaliWeek(JalaliOffset):\n    \"\"\"Offset to a specific day of the Jalali week.\n\n    The Jalali week starts on Saturday (weekday=0) and ends on Friday (weekday=6).\n\n    Attributes:\n        weekday: The target weekday (0=Saturday, 6=Friday). Defaults to 0 (Saturday).\n    \"\"\"\n\n    _prefix = \"JW\"\n    _attributes = (\"n\", \"normalize\", \"weekday\")\n\n    def __init__(\n        self,\n        n: int = 1,\n        normalize: bool = False,\n        weekday: int = SATURDAY,\n    ) -&gt; None:\n        \"\"\"Initialize JalaliWeek offset.\n\n        Args:\n            n: Number of weeks. Defaults to 1.\n            normalize: Whether to normalize to midnight. Defaults to False.\n            weekday: Target weekday (0=Saturday, 6=Friday). Defaults to 0 (Saturday).\n\n        Raises:\n            ValueError: If weekday is not in range 0-6.\n        \"\"\"\n        super().__init__(n=n, normalize=normalize)\n        if not 0 &lt;= weekday &lt;= 6:\n            raise ValueError(f\"weekday must be 0-6, got {weekday}\")\n        self._weekday = weekday\n\n    @property\n    def weekday(self) -&gt; int:\n        \"\"\"Target weekday (0=Saturday, 6=Friday).\"\"\"\n        return self._weekday\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation.\"\"\"\n        return f\"&lt;{self.__class__.__name__}: n={self._n}, weekday={self._weekday}&gt;\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality.\"\"\"\n        if isinstance(other, JalaliWeek):\n            return (\n                type(self) is type(other)\n                and self._n == other._n\n                and self._weekday == other._weekday\n            )\n        return False\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Hash for use in sets and dicts.\"\"\"\n        return hash((type(self).__name__, self._n, self._weekday))\n\n    def __neg__(self) -&gt; JalaliWeek:\n        \"\"\"Return negated offset.\"\"\"\n        return JalaliWeek(n=-self._n, normalize=self._normalize, weekday=self._weekday)\n\n    def __mul__(self, other: int) -&gt; JalaliWeek:\n        \"\"\"Multiply offset by integer.\"\"\"\n        if isinstance(other, int):\n            return JalaliWeek(\n                n=self._n * other, normalize=self._normalize, weekday=self._weekday\n            )\n        return NotImplemented\n\n    def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Add weeks to timestamp, landing on target weekday.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if not isinstance(other, JalaliTimestamp):\n            return NotImplemented\n\n        # Get current weekday (0=Saturday, 6=Friday)\n        current_weekday = other.dayofweek\n\n        # Calculate days to target weekday\n        days_to_target = (self._weekday - current_weekday) % 7\n\n        # If we're already on the target weekday and n &gt; 0, we need to go forward\n        # If n &lt; 0, we need to go backward\n        if self._n &gt; 0:\n            # Move forward n weeks, landing on target weekday\n            if days_to_target == 0:\n                # Already on target, move n full weeks\n                total_days = self._n * 7\n            else:\n                # Move to next target weekday, then (n-1) more weeks\n                total_days = days_to_target + (self._n - 1) * 7\n        elif self._n &lt; 0:\n            # Move backward |n| weeks, landing on target weekday\n            if days_to_target == 0:\n                # Already on target, move |n| full weeks back\n                total_days = self._n * 7\n            else:\n                # Move to previous target weekday, then (|n|-1) more weeks back\n                days_to_prev_target = days_to_target - 7  # Negative\n                total_days = days_to_prev_target + (self._n + 1) * 7\n        else:\n            # n == 0, just move to nearest target weekday (forward)\n            total_days = days_to_target\n\n        # Apply the offset using timedelta\n        new_gregorian = other.to_gregorian() + timedelta(days=total_days)\n        result = JalaliTimestamp.from_gregorian(new_gregorian)\n\n        if self._normalize:\n            result = result.normalize()\n\n        return result\n\n    def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Subtract weeks from timestamp.\"\"\"\n        return self.__neg__().__add__(other)\n\n    def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll forward to next target weekday if not already on one.\"\"\"\n        if self.is_on_offset(dt):\n            return dt\n\n        # Calculate days to next target weekday\n        current_weekday = dt.dayofweek\n        days_forward = (self._weekday - current_weekday) % 7\n        if days_forward == 0:\n            days_forward = 7  # Move to next week if already on target\n\n        new_gregorian = dt.to_gregorian() + timedelta(days=days_forward)\n        result = type(dt).from_gregorian(new_gregorian)\n\n        if self._normalize:\n            result = result.normalize()\n\n        return result\n\n    def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll back to previous target weekday.\"\"\"\n        if self.is_on_offset(dt):\n            return dt\n\n        # Calculate days to previous target weekday\n        current_weekday = dt.dayofweek\n        days_back = (current_weekday - self._weekday) % 7\n        if days_back == 0:\n            days_back = 7  # Move to previous week if already on target\n\n        new_gregorian = dt.to_gregorian() - timedelta(days=days_back)\n        result = type(dt).from_gregorian(new_gregorian)\n\n        if self._normalize:\n            result = result.normalize()\n\n        return result\n\n    def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n        \"\"\"Check if date is on target weekday.\"\"\"\n        return dt.dayofweek == self._weekday\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliWeek.weekday","title":"weekday  <code>property</code>","text":"<pre><code>weekday: int\n</code></pre> <p>Target weekday (0=Saturday, 6=Friday).</p>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliWeek.__add__","title":"__add__","text":"<pre><code>__add__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Add weeks to timestamp, landing on target weekday.</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Add weeks to timestamp, landing on target weekday.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if not isinstance(other, JalaliTimestamp):\n        return NotImplemented\n\n    # Get current weekday (0=Saturday, 6=Friday)\n    current_weekday = other.dayofweek\n\n    # Calculate days to target weekday\n    days_to_target = (self._weekday - current_weekday) % 7\n\n    # If we're already on the target weekday and n &gt; 0, we need to go forward\n    # If n &lt; 0, we need to go backward\n    if self._n &gt; 0:\n        # Move forward n weeks, landing on target weekday\n        if days_to_target == 0:\n            # Already on target, move n full weeks\n            total_days = self._n * 7\n        else:\n            # Move to next target weekday, then (n-1) more weeks\n            total_days = days_to_target + (self._n - 1) * 7\n    elif self._n &lt; 0:\n        # Move backward |n| weeks, landing on target weekday\n        if days_to_target == 0:\n            # Already on target, move |n| full weeks back\n            total_days = self._n * 7\n        else:\n            # Move to previous target weekday, then (|n|-1) more weeks back\n            days_to_prev_target = days_to_target - 7  # Negative\n            total_days = days_to_prev_target + (self._n + 1) * 7\n    else:\n        # n == 0, just move to nearest target weekday (forward)\n        total_days = days_to_target\n\n    # Apply the offset using timedelta\n    new_gregorian = other.to_gregorian() + timedelta(days=total_days)\n    result = JalaliTimestamp.from_gregorian(new_gregorian)\n\n    if self._normalize:\n        result = result.normalize()\n\n    return result\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliWeek.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality.</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality.\"\"\"\n    if isinstance(other, JalaliWeek):\n        return (\n            type(self) is type(other)\n            and self._n == other._n\n            and self._weekday == other._weekday\n        )\n    return False\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliWeek.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Hash for use in sets and dicts.</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Hash for use in sets and dicts.\"\"\"\n    return hash((type(self).__name__, self._n, self._weekday))\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliWeek.__init__","title":"__init__","text":"<pre><code>__init__(n: int = 1, normalize: bool = False, weekday: int = SATURDAY) -&gt; None\n</code></pre> <p>Initialize JalaliWeek offset.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of weeks. Defaults to 1.</p> <code>1</code> <code>normalize</code> <code>bool</code> <p>Whether to normalize to midnight. Defaults to False.</p> <code>False</code> <code>weekday</code> <code>int</code> <p>Target weekday (0=Saturday, 6=Friday). Defaults to 0 (Saturday).</p> <code>SATURDAY</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If weekday is not in range 0-6.</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>def __init__(\n    self,\n    n: int = 1,\n    normalize: bool = False,\n    weekday: int = SATURDAY,\n) -&gt; None:\n    \"\"\"Initialize JalaliWeek offset.\n\n    Args:\n        n: Number of weeks. Defaults to 1.\n        normalize: Whether to normalize to midnight. Defaults to False.\n        weekday: Target weekday (0=Saturday, 6=Friday). Defaults to 0 (Saturday).\n\n    Raises:\n        ValueError: If weekday is not in range 0-6.\n    \"\"\"\n    super().__init__(n=n, normalize=normalize)\n    if not 0 &lt;= weekday &lt;= 6:\n        raise ValueError(f\"weekday must be 0-6, got {weekday}\")\n    self._weekday = weekday\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliWeek.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: int) -&gt; JalaliWeek\n</code></pre> <p>Multiply offset by integer.</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>def __mul__(self, other: int) -&gt; JalaliWeek:\n    \"\"\"Multiply offset by integer.\"\"\"\n    if isinstance(other, int):\n        return JalaliWeek(\n            n=self._n * other, normalize=self._normalize, weekday=self._weekday\n        )\n    return NotImplemented\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliWeek.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; JalaliWeek\n</code></pre> <p>Return negated offset.</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>def __neg__(self) -&gt; JalaliWeek:\n    \"\"\"Return negated offset.\"\"\"\n    return JalaliWeek(n=-self._n, normalize=self._normalize, weekday=self._weekday)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliWeek.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>String representation.</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"String representation.\"\"\"\n    return f\"&lt;{self.__class__.__name__}: n={self._n}, weekday={self._weekday}&gt;\"\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliWeek.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Subtract weeks from timestamp.</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Subtract weeks from timestamp.\"\"\"\n    return self.__neg__().__add__(other)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliWeek.is_on_offset","title":"is_on_offset","text":"<pre><code>is_on_offset(dt: JalaliTimestamp) -&gt; bool\n</code></pre> <p>Check if date is on target weekday.</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n    \"\"\"Check if date is on target weekday.\"\"\"\n    return dt.dayofweek == self._weekday\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliWeek.rollback","title":"rollback","text":"<pre><code>rollback(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll back to previous target weekday.</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll back to previous target weekday.\"\"\"\n    if self.is_on_offset(dt):\n        return dt\n\n    # Calculate days to previous target weekday\n    current_weekday = dt.dayofweek\n    days_back = (current_weekday - self._weekday) % 7\n    if days_back == 0:\n        days_back = 7  # Move to previous week if already on target\n\n    new_gregorian = dt.to_gregorian() - timedelta(days=days_back)\n    result = type(dt).from_gregorian(new_gregorian)\n\n    if self._normalize:\n        result = result.normalize()\n\n    return result\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliWeek.rollforward","title":"rollforward","text":"<pre><code>rollforward(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll forward to next target weekday if not already on one.</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll forward to next target weekday if not already on one.\"\"\"\n    if self.is_on_offset(dt):\n        return dt\n\n    # Calculate days to next target weekday\n    current_weekday = dt.dayofweek\n    days_forward = (self._weekday - current_weekday) % 7\n    if days_forward == 0:\n        days_forward = 7  # Move to next week if already on target\n\n    new_gregorian = dt.to_gregorian() + timedelta(days=days_forward)\n    result = type(dt).from_gregorian(new_gregorian)\n\n    if self._normalize:\n        result = result.normalize()\n\n    return result\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliYearBegin","title":"JalaliYearBegin","text":"<p>               Bases: <code>JalaliOffset</code></p> <p>Offset to the beginning of a Jalali year (Nowruz).</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>class JalaliYearBegin(JalaliOffset):\n    \"\"\"Offset to the beginning of a Jalali year (Nowruz).\"\"\"\n\n    _prefix = \"JYS\"\n\n    def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Add years to timestamp, landing on year start (Nowruz).\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if not isinstance(other, JalaliTimestamp):\n            return NotImplemented\n\n        new_year = other.year + self._n\n\n        return JalaliTimestamp(\n            year=new_year,\n            month=1,\n            day=1,\n            hour=other.hour if not self._normalize else 0,\n            minute=other.minute if not self._normalize else 0,\n            second=other.second if not self._normalize else 0,\n            microsecond=other.microsecond if not self._normalize else 0,\n            nanosecond=other.nanosecond if not self._normalize else 0,\n            tzinfo=other.tzinfo,\n        )\n\n    def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Subtract years from timestamp.\"\"\"\n        return self.__neg__().__add__(other)\n\n    def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll forward to next year start if not already on one.\"\"\"\n        if self.is_on_offset(dt):\n            return dt\n        return self.__add__(dt)\n\n    def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll back to current year start.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if self.is_on_offset(dt):\n            return dt\n\n        return JalaliTimestamp(\n            year=dt.year,\n            month=1,\n            day=1,\n            hour=dt.hour if not self._normalize else 0,\n            minute=dt.minute if not self._normalize else 0,\n            second=dt.second if not self._normalize else 0,\n            tzinfo=dt.tzinfo,\n        )\n\n    def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n        \"\"\"Check if date is on year start (Nowruz - 1 Farvardin).\"\"\"\n        return dt.month == 1 and dt.day == 1\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliYearBegin.__add__","title":"__add__","text":"<pre><code>__add__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Add years to timestamp, landing on year start (Nowruz).</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Add years to timestamp, landing on year start (Nowruz).\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if not isinstance(other, JalaliTimestamp):\n        return NotImplemented\n\n    new_year = other.year + self._n\n\n    return JalaliTimestamp(\n        year=new_year,\n        month=1,\n        day=1,\n        hour=other.hour if not self._normalize else 0,\n        minute=other.minute if not self._normalize else 0,\n        second=other.second if not self._normalize else 0,\n        microsecond=other.microsecond if not self._normalize else 0,\n        nanosecond=other.nanosecond if not self._normalize else 0,\n        tzinfo=other.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliYearBegin.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Subtract years from timestamp.</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Subtract years from timestamp.\"\"\"\n    return self.__neg__().__add__(other)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliYearBegin.is_on_offset","title":"is_on_offset","text":"<pre><code>is_on_offset(dt: JalaliTimestamp) -&gt; bool\n</code></pre> <p>Check if date is on year start (Nowruz - 1 Farvardin).</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n    \"\"\"Check if date is on year start (Nowruz - 1 Farvardin).\"\"\"\n    return dt.month == 1 and dt.day == 1\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliYearBegin.rollback","title":"rollback","text":"<pre><code>rollback(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll back to current year start.</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll back to current year start.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if self.is_on_offset(dt):\n        return dt\n\n    return JalaliTimestamp(\n        year=dt.year,\n        month=1,\n        day=1,\n        hour=dt.hour if not self._normalize else 0,\n        minute=dt.minute if not self._normalize else 0,\n        second=dt.second if not self._normalize else 0,\n        tzinfo=dt.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliYearBegin.rollforward","title":"rollforward","text":"<pre><code>rollforward(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll forward to next year start if not already on one.</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll forward to next year start if not already on one.\"\"\"\n    if self.is_on_offset(dt):\n        return dt\n    return self.__add__(dt)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliYearEnd","title":"JalaliYearEnd","text":"<p>               Bases: <code>JalaliOffset</code></p> <p>Offset to the end of a Jalali year.</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>class JalaliYearEnd(JalaliOffset):\n    \"\"\"Offset to the end of a Jalali year.\"\"\"\n\n    _prefix = \"JYE\"\n\n    def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Add years to timestamp, landing on year end.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if not isinstance(other, JalaliTimestamp):\n            return NotImplemented\n\n        new_year = other.year + self._n\n        # Last day of Esfand (29 or 30 depending on leap year)\n        new_day = 30 if is_leap_year(new_year) else 29\n\n        return JalaliTimestamp(\n            year=new_year,\n            month=12,\n            day=new_day,\n            hour=other.hour if not self._normalize else 0,\n            minute=other.minute if not self._normalize else 0,\n            second=other.second if not self._normalize else 0,\n            microsecond=other.microsecond if not self._normalize else 0,\n            nanosecond=other.nanosecond if not self._normalize else 0,\n            tzinfo=other.tzinfo,\n        )\n\n    def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Subtract years from timestamp.\"\"\"\n        return self.__neg__().__add__(other)\n\n    def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll forward to next year end if not already on one.\"\"\"\n        if self.is_on_offset(dt):\n            return dt\n        return self._get_year_end(dt)\n\n    def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll back to previous year end.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if self.is_on_offset(dt):\n            return dt\n\n        # Go to previous year's end\n        new_year = dt.year - 1\n        new_day = 30 if is_leap_year(new_year) else 29\n\n        return JalaliTimestamp(\n            year=new_year,\n            month=12,\n            day=new_day,\n            hour=dt.hour if not self._normalize else 0,\n            minute=dt.minute if not self._normalize else 0,\n            second=dt.second if not self._normalize else 0,\n            tzinfo=dt.tzinfo,\n        )\n\n    def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n        \"\"\"Check if date is on year end (last day of Esfand).\"\"\"\n        if dt.month != 12:\n            return False\n        return dt.day == days_in_month(dt.year, 12)\n\n    def _get_year_end(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Get the end of the current year.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        return JalaliTimestamp(\n            year=dt.year,\n            month=12,\n            day=days_in_month(dt.year, 12),\n            hour=dt.hour if not self._normalize else 0,\n            minute=dt.minute if not self._normalize else 0,\n            second=dt.second if not self._normalize else 0,\n            tzinfo=dt.tzinfo,\n        )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliYearEnd.__add__","title":"__add__","text":"<pre><code>__add__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Add years to timestamp, landing on year end.</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Add years to timestamp, landing on year end.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if not isinstance(other, JalaliTimestamp):\n        return NotImplemented\n\n    new_year = other.year + self._n\n    # Last day of Esfand (29 or 30 depending on leap year)\n    new_day = 30 if is_leap_year(new_year) else 29\n\n    return JalaliTimestamp(\n        year=new_year,\n        month=12,\n        day=new_day,\n        hour=other.hour if not self._normalize else 0,\n        minute=other.minute if not self._normalize else 0,\n        second=other.second if not self._normalize else 0,\n        microsecond=other.microsecond if not self._normalize else 0,\n        nanosecond=other.nanosecond if not self._normalize else 0,\n        tzinfo=other.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliYearEnd.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Subtract years from timestamp.</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Subtract years from timestamp.\"\"\"\n    return self.__neg__().__add__(other)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliYearEnd.is_on_offset","title":"is_on_offset","text":"<pre><code>is_on_offset(dt: JalaliTimestamp) -&gt; bool\n</code></pre> <p>Check if date is on year end (last day of Esfand).</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n    \"\"\"Check if date is on year end (last day of Esfand).\"\"\"\n    if dt.month != 12:\n        return False\n    return dt.day == days_in_month(dt.year, 12)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliYearEnd.rollback","title":"rollback","text":"<pre><code>rollback(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll back to previous year end.</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll back to previous year end.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if self.is_on_offset(dt):\n        return dt\n\n    # Go to previous year's end\n    new_year = dt.year - 1\n    new_day = 30 if is_leap_year(new_year) else 29\n\n    return JalaliTimestamp(\n        year=new_year,\n        month=12,\n        day=new_day,\n        hour=dt.hour if not self._normalize else 0,\n        minute=dt.minute if not self._normalize else 0,\n        second=dt.second if not self._normalize else 0,\n        tzinfo=dt.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.JalaliYearEnd.rollforward","title":"rollforward","text":"<pre><code>rollforward(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll forward to next year end if not already on one.</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll forward to next year end if not already on one.\"\"\"\n    if self.is_on_offset(dt):\n        return dt\n    return self._get_year_end(dt)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.get_jalali_alias","title":"get_jalali_alias","text":"<pre><code>get_jalali_alias(offset_class: type[JalaliOffset]) -&gt; str | None\n</code></pre> <p>Get the frequency alias for an offset class.</p> <p>Parameters:</p> Name Type Description Default <code>offset_class</code> <code>type[JalaliOffset]</code> <p>The offset class.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>The frequency alias, or None if not registered.</p> Source code in <code>jalali_pandas/offsets/aliases.py</code> <pre><code>def get_jalali_alias(offset_class: type[JalaliOffset]) -&gt; str | None:\n    \"\"\"Get the frequency alias for an offset class.\n\n    Args:\n        offset_class: The offset class.\n\n    Returns:\n        The frequency alias, or None if not registered.\n    \"\"\"\n    return _JALALI_OFFSET_TO_ALIAS.get(offset_class)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.get_jalali_offset","title":"get_jalali_offset","text":"<pre><code>get_jalali_offset(alias: str) -&gt; type[JalaliOffset] | None\n</code></pre> <p>Get the offset class for a frequency alias.</p> <p>Parameters:</p> Name Type Description Default <code>alias</code> <code>str</code> <p>The frequency alias string.</p> required <p>Returns:</p> Type Description <code>type[JalaliOffset] | None</code> <p>The offset class, or None if not found.</p> Source code in <code>jalali_pandas/offsets/aliases.py</code> <pre><code>def get_jalali_offset(alias: str) -&gt; type[JalaliOffset] | None:\n    \"\"\"Get the offset class for a frequency alias.\n\n    Args:\n        alias: The frequency alias string.\n\n    Returns:\n        The offset class, or None if not found.\n    \"\"\"\n    return _JALALI_OFFSET_ALIASES.get(alias)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.list_jalali_aliases","title":"list_jalali_aliases","text":"<pre><code>list_jalali_aliases() -&gt; dict[str, str]\n</code></pre> <p>List all registered Jalali frequency aliases.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary mapping aliases to offset class names.</p> Source code in <code>jalali_pandas/offsets/aliases.py</code> <pre><code>def list_jalali_aliases() -&gt; dict[str, str]:\n    \"\"\"List all registered Jalali frequency aliases.\n\n    Returns:\n        Dictionary mapping aliases to offset class names.\n    \"\"\"\n    return {alias: cls.__name__ for alias, cls in _JALALI_OFFSET_ALIASES.items()}\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.parse_jalali_frequency","title":"parse_jalali_frequency","text":"<pre><code>parse_jalali_frequency(freq_str: str) -&gt; JalaliOffset\n</code></pre> <p>Parse a frequency string into a Jalali offset instance.</p> <p>Supports formats like: - \"JME\" -&gt; JalaliMonthEnd(n=1) - \"2JME\" -&gt; JalaliMonthEnd(n=2) - \"-1JQS\" -&gt; JalaliQuarterBegin(n=-1)</p> <p>Parameters:</p> Name Type Description Default <code>freq_str</code> <code>str</code> <p>The frequency string to parse.</p> required <p>Returns:</p> Type Description <code>JalaliOffset</code> <p>A Jalali offset instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the frequency string is not recognized.</p> Source code in <code>jalali_pandas/offsets/aliases.py</code> <pre><code>def parse_jalali_frequency(freq_str: str) -&gt; JalaliOffset:\n    \"\"\"Parse a frequency string into a Jalali offset instance.\n\n    Supports formats like:\n    - \"JME\" -&gt; JalaliMonthEnd(n=1)\n    - \"2JME\" -&gt; JalaliMonthEnd(n=2)\n    - \"-1JQS\" -&gt; JalaliQuarterBegin(n=-1)\n\n    Args:\n        freq_str: The frequency string to parse.\n\n    Returns:\n        A Jalali offset instance.\n\n    Raises:\n        ValueError: If the frequency string is not recognized.\n    \"\"\"\n    # Pattern: optional sign, optional number, alias\n    pattern = r\"^(-?)(\\d*)([A-Z]+)$\"\n    match = re.match(pattern, freq_str.strip().upper())\n\n    if not match:\n        raise ValueError(f\"Cannot parse frequency string: '{freq_str}'\")\n\n    sign, num_str, alias = match.groups()\n\n    # Get the offset class\n    offset_class = get_jalali_offset(alias)\n    if offset_class is None:\n        raise ValueError(f\"Unknown Jalali frequency alias: '{alias}'\")\n\n    # Parse the multiplier\n    n = int(num_str) if num_str else 1\n    if sign == \"-\":\n        n = -n\n\n    return offset_class(n=n)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.register_jalali_alias","title":"register_jalali_alias","text":"<pre><code>register_jalali_alias(alias: str, offset_class: type[JalaliOffset]) -&gt; None\n</code></pre> <p>Register a frequency alias for a Jalali offset class.</p> <p>Parameters:</p> Name Type Description Default <code>alias</code> <code>str</code> <p>The frequency alias string (e.g., \"JME\", \"JQS\").</p> required <code>offset_class</code> <code>type[JalaliOffset]</code> <p>The offset class to register.</p> required Source code in <code>jalali_pandas/offsets/aliases.py</code> <pre><code>def register_jalali_alias(alias: str, offset_class: type[JalaliOffset]) -&gt; None:\n    \"\"\"Register a frequency alias for a Jalali offset class.\n\n    Args:\n        alias: The frequency alias string (e.g., \"JME\", \"JQS\").\n        offset_class: The offset class to register.\n    \"\"\"\n    _JALALI_OFFSET_ALIASES[alias] = offset_class\n    _JALALI_OFFSET_TO_ALIAS[offset_class] = alias\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.aliases.get_jalali_alias","title":"get_jalali_alias","text":"<pre><code>get_jalali_alias(offset_class: type[JalaliOffset]) -&gt; str | None\n</code></pre> <p>Get the frequency alias for an offset class.</p> <p>Parameters:</p> Name Type Description Default <code>offset_class</code> <code>type[JalaliOffset]</code> <p>The offset class.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>The frequency alias, or None if not registered.</p> Source code in <code>jalali_pandas/offsets/aliases.py</code> <pre><code>def get_jalali_alias(offset_class: type[JalaliOffset]) -&gt; str | None:\n    \"\"\"Get the frequency alias for an offset class.\n\n    Args:\n        offset_class: The offset class.\n\n    Returns:\n        The frequency alias, or None if not registered.\n    \"\"\"\n    return _JALALI_OFFSET_TO_ALIAS.get(offset_class)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.aliases.get_jalali_offset","title":"get_jalali_offset","text":"<pre><code>get_jalali_offset(alias: str) -&gt; type[JalaliOffset] | None\n</code></pre> <p>Get the offset class for a frequency alias.</p> <p>Parameters:</p> Name Type Description Default <code>alias</code> <code>str</code> <p>The frequency alias string.</p> required <p>Returns:</p> Type Description <code>type[JalaliOffset] | None</code> <p>The offset class, or None if not found.</p> Source code in <code>jalali_pandas/offsets/aliases.py</code> <pre><code>def get_jalali_offset(alias: str) -&gt; type[JalaliOffset] | None:\n    \"\"\"Get the offset class for a frequency alias.\n\n    Args:\n        alias: The frequency alias string.\n\n    Returns:\n        The offset class, or None if not found.\n    \"\"\"\n    return _JALALI_OFFSET_ALIASES.get(alias)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.aliases.list_jalali_aliases","title":"list_jalali_aliases","text":"<pre><code>list_jalali_aliases() -&gt; dict[str, str]\n</code></pre> <p>List all registered Jalali frequency aliases.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary mapping aliases to offset class names.</p> Source code in <code>jalali_pandas/offsets/aliases.py</code> <pre><code>def list_jalali_aliases() -&gt; dict[str, str]:\n    \"\"\"List all registered Jalali frequency aliases.\n\n    Returns:\n        Dictionary mapping aliases to offset class names.\n    \"\"\"\n    return {alias: cls.__name__ for alias, cls in _JALALI_OFFSET_ALIASES.items()}\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.aliases.parse_jalali_frequency","title":"parse_jalali_frequency","text":"<pre><code>parse_jalali_frequency(freq_str: str) -&gt; JalaliOffset\n</code></pre> <p>Parse a frequency string into a Jalali offset instance.</p> <p>Supports formats like: - \"JME\" -&gt; JalaliMonthEnd(n=1) - \"2JME\" -&gt; JalaliMonthEnd(n=2) - \"-1JQS\" -&gt; JalaliQuarterBegin(n=-1)</p> <p>Parameters:</p> Name Type Description Default <code>freq_str</code> <code>str</code> <p>The frequency string to parse.</p> required <p>Returns:</p> Type Description <code>JalaliOffset</code> <p>A Jalali offset instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the frequency string is not recognized.</p> Source code in <code>jalali_pandas/offsets/aliases.py</code> <pre><code>def parse_jalali_frequency(freq_str: str) -&gt; JalaliOffset:\n    \"\"\"Parse a frequency string into a Jalali offset instance.\n\n    Supports formats like:\n    - \"JME\" -&gt; JalaliMonthEnd(n=1)\n    - \"2JME\" -&gt; JalaliMonthEnd(n=2)\n    - \"-1JQS\" -&gt; JalaliQuarterBegin(n=-1)\n\n    Args:\n        freq_str: The frequency string to parse.\n\n    Returns:\n        A Jalali offset instance.\n\n    Raises:\n        ValueError: If the frequency string is not recognized.\n    \"\"\"\n    # Pattern: optional sign, optional number, alias\n    pattern = r\"^(-?)(\\d*)([A-Z]+)$\"\n    match = re.match(pattern, freq_str.strip().upper())\n\n    if not match:\n        raise ValueError(f\"Cannot parse frequency string: '{freq_str}'\")\n\n    sign, num_str, alias = match.groups()\n\n    # Get the offset class\n    offset_class = get_jalali_offset(alias)\n    if offset_class is None:\n        raise ValueError(f\"Unknown Jalali frequency alias: '{alias}'\")\n\n    # Parse the multiplier\n    n = int(num_str) if num_str else 1\n    if sign == \"-\":\n        n = -n\n\n    return offset_class(n=n)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.aliases.register_jalali_alias","title":"register_jalali_alias","text":"<pre><code>register_jalali_alias(alias: str, offset_class: type[JalaliOffset]) -&gt; None\n</code></pre> <p>Register a frequency alias for a Jalali offset class.</p> <p>Parameters:</p> Name Type Description Default <code>alias</code> <code>str</code> <p>The frequency alias string (e.g., \"JME\", \"JQS\").</p> required <code>offset_class</code> <code>type[JalaliOffset]</code> <p>The offset class to register.</p> required Source code in <code>jalali_pandas/offsets/aliases.py</code> <pre><code>def register_jalali_alias(alias: str, offset_class: type[JalaliOffset]) -&gt; None:\n    \"\"\"Register a frequency alias for a Jalali offset class.\n\n    Args:\n        alias: The frequency alias string (e.g., \"JME\", \"JQS\").\n        offset_class: The offset class to register.\n    \"\"\"\n    _JALALI_OFFSET_ALIASES[alias] = offset_class\n    _JALALI_OFFSET_TO_ALIAS[offset_class] = alias\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.base.JalaliOffset","title":"JalaliOffset","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for Jalali calendar-aware offsets.</p> <p>This class provides the foundation for implementing calendar-aware date offsets that respect Jalali calendar rules.</p> <p>Attributes:</p> Name Type Description <code>n</code> <code>int</code> <p>Number of periods.</p> <code>normalize</code> <code>bool</code> <p>Whether to normalize to midnight.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>class JalaliOffset(ABC):\n    \"\"\"Abstract base class for Jalali calendar-aware offsets.\n\n    This class provides the foundation for implementing calendar-aware\n    date offsets that respect Jalali calendar rules.\n\n    Attributes:\n        n: Number of periods.\n        normalize: Whether to normalize to midnight.\n    \"\"\"\n\n    _prefix: str = \"J\"\n    _attributes: tuple[str, ...] = (\"n\", \"normalize\")\n\n    def __init__(self, n: int = 1, normalize: bool = False) -&gt; None:\n        \"\"\"Initialize JalaliOffset.\n\n        Args:\n            n: Number of periods. Defaults to 1.\n            normalize: Whether to normalize to midnight. Defaults to False.\n        \"\"\"\n        self._n = n\n        self._normalize = normalize\n\n    @property\n    def n(self) -&gt; int:\n        \"\"\"Number of periods.\"\"\"\n        return self._n\n\n    @property\n    def normalize(self) -&gt; bool:\n        \"\"\"Whether to normalize to midnight.\"\"\"\n        return self._normalize\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Return the name of the offset.\"\"\"\n        return f\"{self._prefix}{abs(self._n)}\"\n\n    @property\n    def freqstr(self) -&gt; str:\n        \"\"\"Return the frequency string.\"\"\"\n        return self.name\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation.\"\"\"\n        return f\"&lt;{self.__class__.__name__}: n={self._n}&gt;\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality.\"\"\"\n        if isinstance(other, JalaliOffset):\n            return type(self) is type(other) and self._n == other._n\n        return False\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Hash for use in sets and dicts.\"\"\"\n        return hash((type(self).__name__, self._n))\n\n    def __neg__(self) -&gt; JalaliOffset:\n        \"\"\"Return negated offset.\"\"\"\n        return type(self)(n=-self._n, normalize=self._normalize)\n\n    def __mul__(self, other: int) -&gt; JalaliOffset:\n        \"\"\"Multiply offset by integer.\"\"\"\n        if isinstance(other, int):\n            return type(self)(n=self._n * other, normalize=self._normalize)\n        return NotImplemented\n\n    def __rmul__(self, other: int) -&gt; JalaliOffset:\n        \"\"\"Right multiply offset by integer.\"\"\"\n        return self.__mul__(other)\n\n    @abstractmethod\n    def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Add offset to a JalaliTimestamp.\"\"\"\n        ...\n\n    def __radd__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Right add offset to a JalaliTimestamp.\"\"\"\n        return self.__add__(other)\n\n    @abstractmethod\n    def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Subtract offset from a JalaliTimestamp.\"\"\"\n        ...\n\n    @abstractmethod\n    def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll forward to next valid date.\n\n        Args:\n            dt: JalaliTimestamp to roll forward.\n\n        Returns:\n            Rolled forward JalaliTimestamp.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll back to previous valid date.\n\n        Args:\n            dt: JalaliTimestamp to roll back.\n\n        Returns:\n            Rolled back JalaliTimestamp.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n        \"\"\"Check if date is on offset boundary.\n\n        Args:\n            dt: JalaliTimestamp to check.\n\n        Returns:\n            True if on offset boundary.\n        \"\"\"\n        ...\n\n    def _apply(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Apply offset to timestamp.\n\n        Args:\n            other: JalaliTimestamp to apply offset to.\n\n        Returns:\n            New JalaliTimestamp with offset applied.\n        \"\"\"\n        result = self.__add__(other)\n        if self._normalize:\n            result = result.normalize()\n        return result\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.base.JalaliOffset.freqstr","title":"freqstr  <code>property</code>","text":"<pre><code>freqstr: str\n</code></pre> <p>Return the frequency string.</p>"},{"location":"en/api/offsets/#jalali_pandas.offsets.base.JalaliOffset.n","title":"n  <code>property</code>","text":"<pre><code>n: int\n</code></pre> <p>Number of periods.</p>"},{"location":"en/api/offsets/#jalali_pandas.offsets.base.JalaliOffset.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Return the name of the offset.</p>"},{"location":"en/api/offsets/#jalali_pandas.offsets.base.JalaliOffset.normalize","title":"normalize  <code>property</code>","text":"<pre><code>normalize: bool\n</code></pre> <p>Whether to normalize to midnight.</p>"},{"location":"en/api/offsets/#jalali_pandas.offsets.base.JalaliOffset.__add__","title":"__add__  <code>abstractmethod</code>","text":"<pre><code>__add__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Add offset to a JalaliTimestamp.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>@abstractmethod\ndef __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Add offset to a JalaliTimestamp.\"\"\"\n    ...\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.base.JalaliOffset.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality.\"\"\"\n    if isinstance(other, JalaliOffset):\n        return type(self) is type(other) and self._n == other._n\n    return False\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.base.JalaliOffset.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Hash for use in sets and dicts.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Hash for use in sets and dicts.\"\"\"\n    return hash((type(self).__name__, self._n))\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.base.JalaliOffset.__init__","title":"__init__","text":"<pre><code>__init__(n: int = 1, normalize: bool = False) -&gt; None\n</code></pre> <p>Initialize JalaliOffset.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of periods. Defaults to 1.</p> <code>1</code> <code>normalize</code> <code>bool</code> <p>Whether to normalize to midnight. Defaults to False.</p> <code>False</code> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>def __init__(self, n: int = 1, normalize: bool = False) -&gt; None:\n    \"\"\"Initialize JalaliOffset.\n\n    Args:\n        n: Number of periods. Defaults to 1.\n        normalize: Whether to normalize to midnight. Defaults to False.\n    \"\"\"\n    self._n = n\n    self._normalize = normalize\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.base.JalaliOffset.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: int) -&gt; JalaliOffset\n</code></pre> <p>Multiply offset by integer.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>def __mul__(self, other: int) -&gt; JalaliOffset:\n    \"\"\"Multiply offset by integer.\"\"\"\n    if isinstance(other, int):\n        return type(self)(n=self._n * other, normalize=self._normalize)\n    return NotImplemented\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.base.JalaliOffset.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; JalaliOffset\n</code></pre> <p>Return negated offset.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>def __neg__(self) -&gt; JalaliOffset:\n    \"\"\"Return negated offset.\"\"\"\n    return type(self)(n=-self._n, normalize=self._normalize)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.base.JalaliOffset.__radd__","title":"__radd__","text":"<pre><code>__radd__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Right add offset to a JalaliTimestamp.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>def __radd__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Right add offset to a JalaliTimestamp.\"\"\"\n    return self.__add__(other)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.base.JalaliOffset.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>String representation.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"String representation.\"\"\"\n    return f\"&lt;{self.__class__.__name__}: n={self._n}&gt;\"\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.base.JalaliOffset.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other: int) -&gt; JalaliOffset\n</code></pre> <p>Right multiply offset by integer.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>def __rmul__(self, other: int) -&gt; JalaliOffset:\n    \"\"\"Right multiply offset by integer.\"\"\"\n    return self.__mul__(other)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.base.JalaliOffset.__sub__","title":"__sub__  <code>abstractmethod</code>","text":"<pre><code>__sub__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Subtract offset from a JalaliTimestamp.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>@abstractmethod\ndef __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Subtract offset from a JalaliTimestamp.\"\"\"\n    ...\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.base.JalaliOffset.is_on_offset","title":"is_on_offset  <code>abstractmethod</code>","text":"<pre><code>is_on_offset(dt: JalaliTimestamp) -&gt; bool\n</code></pre> <p>Check if date is on offset boundary.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>JalaliTimestamp</code> <p>JalaliTimestamp to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if on offset boundary.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>@abstractmethod\ndef is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n    \"\"\"Check if date is on offset boundary.\n\n    Args:\n        dt: JalaliTimestamp to check.\n\n    Returns:\n        True if on offset boundary.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.base.JalaliOffset.rollback","title":"rollback  <code>abstractmethod</code>","text":"<pre><code>rollback(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll back to previous valid date.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>JalaliTimestamp</code> <p>JalaliTimestamp to roll back.</p> required <p>Returns:</p> Type Description <code>JalaliTimestamp</code> <p>Rolled back JalaliTimestamp.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>@abstractmethod\ndef rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll back to previous valid date.\n\n    Args:\n        dt: JalaliTimestamp to roll back.\n\n    Returns:\n        Rolled back JalaliTimestamp.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.base.JalaliOffset.rollforward","title":"rollforward  <code>abstractmethod</code>","text":"<pre><code>rollforward(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll forward to next valid date.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>JalaliTimestamp</code> <p>JalaliTimestamp to roll forward.</p> required <p>Returns:</p> Type Description <code>JalaliTimestamp</code> <p>Rolled forward JalaliTimestamp.</p> Source code in <code>jalali_pandas/offsets/base.py</code> <pre><code>@abstractmethod\ndef rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll forward to next valid date.\n\n    Args:\n        dt: JalaliTimestamp to roll forward.\n\n    Returns:\n        Rolled forward JalaliTimestamp.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.month.JalaliMonthBegin","title":"JalaliMonthBegin","text":"<p>               Bases: <code>JalaliOffset</code></p> <p>Offset to the beginning of a Jalali month.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>class JalaliMonthBegin(JalaliOffset):\n    \"\"\"Offset to the beginning of a Jalali month.\"\"\"\n\n    _prefix = \"JMS\"\n\n    def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Add months to timestamp, landing on month start.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if not isinstance(other, JalaliTimestamp):\n            return NotImplemented\n\n        # Calculate target month\n        total_months = other.year * 12 + other.month - 1 + self._n\n        new_year = total_months // 12\n        new_month = total_months % 12 + 1\n\n        return JalaliTimestamp(\n            year=new_year,\n            month=new_month,\n            day=1,\n            hour=other.hour if not self._normalize else 0,\n            minute=other.minute if not self._normalize else 0,\n            second=other.second if not self._normalize else 0,\n            microsecond=other.microsecond if not self._normalize else 0,\n            nanosecond=other.nanosecond if not self._normalize else 0,\n            tzinfo=other.tzinfo,\n        )\n\n    def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Subtract months from timestamp.\"\"\"\n        return self.__neg__().__add__(other)\n\n    def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll forward to next month start if not already on one.\"\"\"\n        if self.is_on_offset(dt):\n            return dt\n        return self.__add__(dt)\n\n    def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll back to previous month start.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if self.is_on_offset(dt):\n            return dt\n        return JalaliTimestamp(\n            year=dt.year,\n            month=dt.month,\n            day=1,\n            hour=dt.hour if not self._normalize else 0,\n            minute=dt.minute if not self._normalize else 0,\n            second=dt.second if not self._normalize else 0,\n            tzinfo=dt.tzinfo,\n        )\n\n    def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n        \"\"\"Check if date is on month start.\"\"\"\n        return dt.day == 1\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.month.JalaliMonthBegin.__add__","title":"__add__","text":"<pre><code>__add__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Add months to timestamp, landing on month start.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Add months to timestamp, landing on month start.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if not isinstance(other, JalaliTimestamp):\n        return NotImplemented\n\n    # Calculate target month\n    total_months = other.year * 12 + other.month - 1 + self._n\n    new_year = total_months // 12\n    new_month = total_months % 12 + 1\n\n    return JalaliTimestamp(\n        year=new_year,\n        month=new_month,\n        day=1,\n        hour=other.hour if not self._normalize else 0,\n        minute=other.minute if not self._normalize else 0,\n        second=other.second if not self._normalize else 0,\n        microsecond=other.microsecond if not self._normalize else 0,\n        nanosecond=other.nanosecond if not self._normalize else 0,\n        tzinfo=other.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.month.JalaliMonthBegin.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Subtract months from timestamp.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Subtract months from timestamp.\"\"\"\n    return self.__neg__().__add__(other)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.month.JalaliMonthBegin.is_on_offset","title":"is_on_offset","text":"<pre><code>is_on_offset(dt: JalaliTimestamp) -&gt; bool\n</code></pre> <p>Check if date is on month start.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n    \"\"\"Check if date is on month start.\"\"\"\n    return dt.day == 1\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.month.JalaliMonthBegin.rollback","title":"rollback","text":"<pre><code>rollback(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll back to previous month start.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll back to previous month start.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if self.is_on_offset(dt):\n        return dt\n    return JalaliTimestamp(\n        year=dt.year,\n        month=dt.month,\n        day=1,\n        hour=dt.hour if not self._normalize else 0,\n        minute=dt.minute if not self._normalize else 0,\n        second=dt.second if not self._normalize else 0,\n        tzinfo=dt.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.month.JalaliMonthBegin.rollforward","title":"rollforward","text":"<pre><code>rollforward(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll forward to next month start if not already on one.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll forward to next month start if not already on one.\"\"\"\n    if self.is_on_offset(dt):\n        return dt\n    return self.__add__(dt)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.month.JalaliMonthEnd","title":"JalaliMonthEnd","text":"<p>               Bases: <code>JalaliOffset</code></p> <p>Offset to the end of a Jalali month.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>class JalaliMonthEnd(JalaliOffset):\n    \"\"\"Offset to the end of a Jalali month.\"\"\"\n\n    _prefix = \"JME\"\n\n    def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Add months to timestamp, landing on month end.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if not isinstance(other, JalaliTimestamp):\n            return NotImplemented\n\n        # Calculate target month\n        total_months = other.year * 12 + other.month - 1 + self._n\n        new_year = total_months // 12\n        new_month = total_months % 12 + 1\n        new_day = days_in_month(new_year, new_month)\n\n        return JalaliTimestamp(\n            year=new_year,\n            month=new_month,\n            day=new_day,\n            hour=other.hour if not self._normalize else 0,\n            minute=other.minute if not self._normalize else 0,\n            second=other.second if not self._normalize else 0,\n            microsecond=other.microsecond if not self._normalize else 0,\n            nanosecond=other.nanosecond if not self._normalize else 0,\n            tzinfo=other.tzinfo,\n        )\n\n    def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Subtract months from timestamp.\"\"\"\n        return self.__neg__().__add__(other)\n\n    def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll forward to next month end if not already on one.\"\"\"\n        if self.is_on_offset(dt):\n            return dt\n        return self._get_month_end(dt)\n\n    def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll back to previous month end.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if self.is_on_offset(dt):\n            return dt\n\n        # Go to previous month's end\n        if dt.month == 1:\n            new_year = dt.year - 1\n            new_month = 12\n        else:\n            new_year = dt.year\n            new_month = dt.month - 1\n\n        new_day = days_in_month(new_year, new_month)\n        return JalaliTimestamp(\n            year=new_year,\n            month=new_month,\n            day=new_day,\n            hour=dt.hour if not self._normalize else 0,\n            minute=dt.minute if not self._normalize else 0,\n            second=dt.second if not self._normalize else 0,\n            tzinfo=dt.tzinfo,\n        )\n\n    def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n        \"\"\"Check if date is on month end.\"\"\"\n        return dt.day == days_in_month(dt.year, dt.month)\n\n    def _get_month_end(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Get the end of the current month.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        return JalaliTimestamp(\n            year=dt.year,\n            month=dt.month,\n            day=days_in_month(dt.year, dt.month),\n            hour=dt.hour if not self._normalize else 0,\n            minute=dt.minute if not self._normalize else 0,\n            second=dt.second if not self._normalize else 0,\n            tzinfo=dt.tzinfo,\n        )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.month.JalaliMonthEnd.__add__","title":"__add__","text":"<pre><code>__add__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Add months to timestamp, landing on month end.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Add months to timestamp, landing on month end.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if not isinstance(other, JalaliTimestamp):\n        return NotImplemented\n\n    # Calculate target month\n    total_months = other.year * 12 + other.month - 1 + self._n\n    new_year = total_months // 12\n    new_month = total_months % 12 + 1\n    new_day = days_in_month(new_year, new_month)\n\n    return JalaliTimestamp(\n        year=new_year,\n        month=new_month,\n        day=new_day,\n        hour=other.hour if not self._normalize else 0,\n        minute=other.minute if not self._normalize else 0,\n        second=other.second if not self._normalize else 0,\n        microsecond=other.microsecond if not self._normalize else 0,\n        nanosecond=other.nanosecond if not self._normalize else 0,\n        tzinfo=other.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.month.JalaliMonthEnd.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Subtract months from timestamp.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Subtract months from timestamp.\"\"\"\n    return self.__neg__().__add__(other)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.month.JalaliMonthEnd.is_on_offset","title":"is_on_offset","text":"<pre><code>is_on_offset(dt: JalaliTimestamp) -&gt; bool\n</code></pre> <p>Check if date is on month end.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n    \"\"\"Check if date is on month end.\"\"\"\n    return dt.day == days_in_month(dt.year, dt.month)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.month.JalaliMonthEnd.rollback","title":"rollback","text":"<pre><code>rollback(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll back to previous month end.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll back to previous month end.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if self.is_on_offset(dt):\n        return dt\n\n    # Go to previous month's end\n    if dt.month == 1:\n        new_year = dt.year - 1\n        new_month = 12\n    else:\n        new_year = dt.year\n        new_month = dt.month - 1\n\n    new_day = days_in_month(new_year, new_month)\n    return JalaliTimestamp(\n        year=new_year,\n        month=new_month,\n        day=new_day,\n        hour=dt.hour if not self._normalize else 0,\n        minute=dt.minute if not self._normalize else 0,\n        second=dt.second if not self._normalize else 0,\n        tzinfo=dt.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.month.JalaliMonthEnd.rollforward","title":"rollforward","text":"<pre><code>rollforward(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll forward to next month end if not already on one.</p> Source code in <code>jalali_pandas/offsets/month.py</code> <pre><code>def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll forward to next month end if not already on one.\"\"\"\n    if self.is_on_offset(dt):\n        return dt\n    return self._get_month_end(dt)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.quarter.JalaliQuarterBegin","title":"JalaliQuarterBegin","text":"<p>               Bases: <code>JalaliOffset</code></p> <p>Offset to the beginning of a Jalali quarter.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>class JalaliQuarterBegin(JalaliOffset):\n    \"\"\"Offset to the beginning of a Jalali quarter.\"\"\"\n\n    _prefix = \"JQS\"\n\n    def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Add quarters to timestamp, landing on quarter start.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if not isinstance(other, JalaliTimestamp):\n            return NotImplemented\n\n        # Calculate current quarter (0-indexed)\n        current_quarter = (other.month - 1) // 3\n\n        # Calculate target quarter\n        total_quarters = other.year * 4 + current_quarter + self._n\n        new_year = total_quarters // 4\n        new_quarter = total_quarters % 4\n        new_month = new_quarter * 3 + 1\n\n        return JalaliTimestamp(\n            year=new_year,\n            month=new_month,\n            day=1,\n            hour=other.hour if not self._normalize else 0,\n            minute=other.minute if not self._normalize else 0,\n            second=other.second if not self._normalize else 0,\n            microsecond=other.microsecond if not self._normalize else 0,\n            nanosecond=other.nanosecond if not self._normalize else 0,\n            tzinfo=other.tzinfo,\n        )\n\n    def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Subtract quarters from timestamp.\"\"\"\n        return self.__neg__().__add__(other)\n\n    def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll forward to next quarter start if not already on one.\"\"\"\n        if self.is_on_offset(dt):\n            return dt\n        return self.__add__(dt)\n\n    def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll back to current quarter start.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if self.is_on_offset(dt):\n            return dt\n\n        quarter_start_month = ((dt.month - 1) // 3) * 3 + 1\n        return JalaliTimestamp(\n            year=dt.year,\n            month=quarter_start_month,\n            day=1,\n            hour=dt.hour if not self._normalize else 0,\n            minute=dt.minute if not self._normalize else 0,\n            second=dt.second if not self._normalize else 0,\n            tzinfo=dt.tzinfo,\n        )\n\n    def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n        \"\"\"Check if date is on quarter start.\"\"\"\n        return dt.month in QUARTER_START_MONTHS and dt.day == 1\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.quarter.JalaliQuarterBegin.__add__","title":"__add__","text":"<pre><code>__add__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Add quarters to timestamp, landing on quarter start.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Add quarters to timestamp, landing on quarter start.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if not isinstance(other, JalaliTimestamp):\n        return NotImplemented\n\n    # Calculate current quarter (0-indexed)\n    current_quarter = (other.month - 1) // 3\n\n    # Calculate target quarter\n    total_quarters = other.year * 4 + current_quarter + self._n\n    new_year = total_quarters // 4\n    new_quarter = total_quarters % 4\n    new_month = new_quarter * 3 + 1\n\n    return JalaliTimestamp(\n        year=new_year,\n        month=new_month,\n        day=1,\n        hour=other.hour if not self._normalize else 0,\n        minute=other.minute if not self._normalize else 0,\n        second=other.second if not self._normalize else 0,\n        microsecond=other.microsecond if not self._normalize else 0,\n        nanosecond=other.nanosecond if not self._normalize else 0,\n        tzinfo=other.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.quarter.JalaliQuarterBegin.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Subtract quarters from timestamp.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Subtract quarters from timestamp.\"\"\"\n    return self.__neg__().__add__(other)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.quarter.JalaliQuarterBegin.is_on_offset","title":"is_on_offset","text":"<pre><code>is_on_offset(dt: JalaliTimestamp) -&gt; bool\n</code></pre> <p>Check if date is on quarter start.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n    \"\"\"Check if date is on quarter start.\"\"\"\n    return dt.month in QUARTER_START_MONTHS and dt.day == 1\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.quarter.JalaliQuarterBegin.rollback","title":"rollback","text":"<pre><code>rollback(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll back to current quarter start.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll back to current quarter start.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if self.is_on_offset(dt):\n        return dt\n\n    quarter_start_month = ((dt.month - 1) // 3) * 3 + 1\n    return JalaliTimestamp(\n        year=dt.year,\n        month=quarter_start_month,\n        day=1,\n        hour=dt.hour if not self._normalize else 0,\n        minute=dt.minute if not self._normalize else 0,\n        second=dt.second if not self._normalize else 0,\n        tzinfo=dt.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.quarter.JalaliQuarterBegin.rollforward","title":"rollforward","text":"<pre><code>rollforward(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll forward to next quarter start if not already on one.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll forward to next quarter start if not already on one.\"\"\"\n    if self.is_on_offset(dt):\n        return dt\n    return self.__add__(dt)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.quarter.JalaliQuarterEnd","title":"JalaliQuarterEnd","text":"<p>               Bases: <code>JalaliOffset</code></p> <p>Offset to the end of a Jalali quarter.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>class JalaliQuarterEnd(JalaliOffset):\n    \"\"\"Offset to the end of a Jalali quarter.\"\"\"\n\n    _prefix = \"JQE\"\n\n    def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Add quarters to timestamp, landing on quarter end.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if not isinstance(other, JalaliTimestamp):\n            return NotImplemented\n\n        # Calculate current quarter (0-indexed)\n        current_quarter = (other.month - 1) // 3\n\n        # Calculate target quarter\n        total_quarters = other.year * 4 + current_quarter + self._n\n        new_year = total_quarters // 4\n        new_quarter = total_quarters % 4\n        new_month = (new_quarter + 1) * 3  # End month of quarter\n        new_day = days_in_month(new_year, new_month)\n\n        return JalaliTimestamp(\n            year=new_year,\n            month=new_month,\n            day=new_day,\n            hour=other.hour if not self._normalize else 0,\n            minute=other.minute if not self._normalize else 0,\n            second=other.second if not self._normalize else 0,\n            microsecond=other.microsecond if not self._normalize else 0,\n            nanosecond=other.nanosecond if not self._normalize else 0,\n            tzinfo=other.tzinfo,\n        )\n\n    def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Subtract quarters from timestamp.\"\"\"\n        return self.__neg__().__add__(other)\n\n    def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll forward to next quarter end if not already on one.\"\"\"\n        if self.is_on_offset(dt):\n            return dt\n        return self._get_quarter_end(dt)\n\n    def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll back to previous quarter end.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if self.is_on_offset(dt):\n            return dt\n\n        # Go to previous quarter's end\n        current_quarter = (dt.month - 1) // 3\n        if current_quarter == 0:\n            new_year = dt.year - 1\n            new_month = 12\n        else:\n            new_year = dt.year\n            new_month = current_quarter * 3\n\n        new_day = days_in_month(new_year, new_month)\n        return JalaliTimestamp(\n            year=new_year,\n            month=new_month,\n            day=new_day,\n            hour=dt.hour if not self._normalize else 0,\n            minute=dt.minute if not self._normalize else 0,\n            second=dt.second if not self._normalize else 0,\n            tzinfo=dt.tzinfo,\n        )\n\n    def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n        \"\"\"Check if date is on quarter end.\"\"\"\n        if dt.month not in QUARTER_END_MONTHS:\n            return False\n        return dt.day == days_in_month(dt.year, dt.month)\n\n    def _get_quarter_end(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Get the end of the current quarter.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        quarter_end_month = ((dt.month - 1) // 3 + 1) * 3\n        return JalaliTimestamp(\n            year=dt.year,\n            month=quarter_end_month,\n            day=days_in_month(dt.year, quarter_end_month),\n            hour=dt.hour if not self._normalize else 0,\n            minute=dt.minute if not self._normalize else 0,\n            second=dt.second if not self._normalize else 0,\n            tzinfo=dt.tzinfo,\n        )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.quarter.JalaliQuarterEnd.__add__","title":"__add__","text":"<pre><code>__add__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Add quarters to timestamp, landing on quarter end.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Add quarters to timestamp, landing on quarter end.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if not isinstance(other, JalaliTimestamp):\n        return NotImplemented\n\n    # Calculate current quarter (0-indexed)\n    current_quarter = (other.month - 1) // 3\n\n    # Calculate target quarter\n    total_quarters = other.year * 4 + current_quarter + self._n\n    new_year = total_quarters // 4\n    new_quarter = total_quarters % 4\n    new_month = (new_quarter + 1) * 3  # End month of quarter\n    new_day = days_in_month(new_year, new_month)\n\n    return JalaliTimestamp(\n        year=new_year,\n        month=new_month,\n        day=new_day,\n        hour=other.hour if not self._normalize else 0,\n        minute=other.minute if not self._normalize else 0,\n        second=other.second if not self._normalize else 0,\n        microsecond=other.microsecond if not self._normalize else 0,\n        nanosecond=other.nanosecond if not self._normalize else 0,\n        tzinfo=other.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.quarter.JalaliQuarterEnd.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Subtract quarters from timestamp.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Subtract quarters from timestamp.\"\"\"\n    return self.__neg__().__add__(other)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.quarter.JalaliQuarterEnd.is_on_offset","title":"is_on_offset","text":"<pre><code>is_on_offset(dt: JalaliTimestamp) -&gt; bool\n</code></pre> <p>Check if date is on quarter end.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n    \"\"\"Check if date is on quarter end.\"\"\"\n    if dt.month not in QUARTER_END_MONTHS:\n        return False\n    return dt.day == days_in_month(dt.year, dt.month)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.quarter.JalaliQuarterEnd.rollback","title":"rollback","text":"<pre><code>rollback(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll back to previous quarter end.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll back to previous quarter end.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if self.is_on_offset(dt):\n        return dt\n\n    # Go to previous quarter's end\n    current_quarter = (dt.month - 1) // 3\n    if current_quarter == 0:\n        new_year = dt.year - 1\n        new_month = 12\n    else:\n        new_year = dt.year\n        new_month = current_quarter * 3\n\n    new_day = days_in_month(new_year, new_month)\n    return JalaliTimestamp(\n        year=new_year,\n        month=new_month,\n        day=new_day,\n        hour=dt.hour if not self._normalize else 0,\n        minute=dt.minute if not self._normalize else 0,\n        second=dt.second if not self._normalize else 0,\n        tzinfo=dt.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.quarter.JalaliQuarterEnd.rollforward","title":"rollforward","text":"<pre><code>rollforward(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll forward to next quarter end if not already on one.</p> Source code in <code>jalali_pandas/offsets/quarter.py</code> <pre><code>def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll forward to next quarter end if not already on one.\"\"\"\n    if self.is_on_offset(dt):\n        return dt\n    return self._get_quarter_end(dt)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.year.JalaliYearBegin","title":"JalaliYearBegin","text":"<p>               Bases: <code>JalaliOffset</code></p> <p>Offset to the beginning of a Jalali year (Nowruz).</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>class JalaliYearBegin(JalaliOffset):\n    \"\"\"Offset to the beginning of a Jalali year (Nowruz).\"\"\"\n\n    _prefix = \"JYS\"\n\n    def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Add years to timestamp, landing on year start (Nowruz).\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if not isinstance(other, JalaliTimestamp):\n            return NotImplemented\n\n        new_year = other.year + self._n\n\n        return JalaliTimestamp(\n            year=new_year,\n            month=1,\n            day=1,\n            hour=other.hour if not self._normalize else 0,\n            minute=other.minute if not self._normalize else 0,\n            second=other.second if not self._normalize else 0,\n            microsecond=other.microsecond if not self._normalize else 0,\n            nanosecond=other.nanosecond if not self._normalize else 0,\n            tzinfo=other.tzinfo,\n        )\n\n    def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Subtract years from timestamp.\"\"\"\n        return self.__neg__().__add__(other)\n\n    def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll forward to next year start if not already on one.\"\"\"\n        if self.is_on_offset(dt):\n            return dt\n        return self.__add__(dt)\n\n    def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll back to current year start.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if self.is_on_offset(dt):\n            return dt\n\n        return JalaliTimestamp(\n            year=dt.year,\n            month=1,\n            day=1,\n            hour=dt.hour if not self._normalize else 0,\n            minute=dt.minute if not self._normalize else 0,\n            second=dt.second if not self._normalize else 0,\n            tzinfo=dt.tzinfo,\n        )\n\n    def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n        \"\"\"Check if date is on year start (Nowruz - 1 Farvardin).\"\"\"\n        return dt.month == 1 and dt.day == 1\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.year.JalaliYearBegin.__add__","title":"__add__","text":"<pre><code>__add__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Add years to timestamp, landing on year start (Nowruz).</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Add years to timestamp, landing on year start (Nowruz).\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if not isinstance(other, JalaliTimestamp):\n        return NotImplemented\n\n    new_year = other.year + self._n\n\n    return JalaliTimestamp(\n        year=new_year,\n        month=1,\n        day=1,\n        hour=other.hour if not self._normalize else 0,\n        minute=other.minute if not self._normalize else 0,\n        second=other.second if not self._normalize else 0,\n        microsecond=other.microsecond if not self._normalize else 0,\n        nanosecond=other.nanosecond if not self._normalize else 0,\n        tzinfo=other.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.year.JalaliYearBegin.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Subtract years from timestamp.</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Subtract years from timestamp.\"\"\"\n    return self.__neg__().__add__(other)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.year.JalaliYearBegin.is_on_offset","title":"is_on_offset","text":"<pre><code>is_on_offset(dt: JalaliTimestamp) -&gt; bool\n</code></pre> <p>Check if date is on year start (Nowruz - 1 Farvardin).</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n    \"\"\"Check if date is on year start (Nowruz - 1 Farvardin).\"\"\"\n    return dt.month == 1 and dt.day == 1\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.year.JalaliYearBegin.rollback","title":"rollback","text":"<pre><code>rollback(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll back to current year start.</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll back to current year start.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if self.is_on_offset(dt):\n        return dt\n\n    return JalaliTimestamp(\n        year=dt.year,\n        month=1,\n        day=1,\n        hour=dt.hour if not self._normalize else 0,\n        minute=dt.minute if not self._normalize else 0,\n        second=dt.second if not self._normalize else 0,\n        tzinfo=dt.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.year.JalaliYearBegin.rollforward","title":"rollforward","text":"<pre><code>rollforward(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll forward to next year start if not already on one.</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll forward to next year start if not already on one.\"\"\"\n    if self.is_on_offset(dt):\n        return dt\n    return self.__add__(dt)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.year.JalaliYearEnd","title":"JalaliYearEnd","text":"<p>               Bases: <code>JalaliOffset</code></p> <p>Offset to the end of a Jalali year.</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>class JalaliYearEnd(JalaliOffset):\n    \"\"\"Offset to the end of a Jalali year.\"\"\"\n\n    _prefix = \"JYE\"\n\n    def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Add years to timestamp, landing on year end.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if not isinstance(other, JalaliTimestamp):\n            return NotImplemented\n\n        new_year = other.year + self._n\n        # Last day of Esfand (29 or 30 depending on leap year)\n        new_day = 30 if is_leap_year(new_year) else 29\n\n        return JalaliTimestamp(\n            year=new_year,\n            month=12,\n            day=new_day,\n            hour=other.hour if not self._normalize else 0,\n            minute=other.minute if not self._normalize else 0,\n            second=other.second if not self._normalize else 0,\n            microsecond=other.microsecond if not self._normalize else 0,\n            nanosecond=other.nanosecond if not self._normalize else 0,\n            tzinfo=other.tzinfo,\n        )\n\n    def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Subtract years from timestamp.\"\"\"\n        return self.__neg__().__add__(other)\n\n    def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll forward to next year end if not already on one.\"\"\"\n        if self.is_on_offset(dt):\n            return dt\n        return self._get_year_end(dt)\n\n    def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll back to previous year end.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if self.is_on_offset(dt):\n            return dt\n\n        # Go to previous year's end\n        new_year = dt.year - 1\n        new_day = 30 if is_leap_year(new_year) else 29\n\n        return JalaliTimestamp(\n            year=new_year,\n            month=12,\n            day=new_day,\n            hour=dt.hour if not self._normalize else 0,\n            minute=dt.minute if not self._normalize else 0,\n            second=dt.second if not self._normalize else 0,\n            tzinfo=dt.tzinfo,\n        )\n\n    def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n        \"\"\"Check if date is on year end (last day of Esfand).\"\"\"\n        if dt.month != 12:\n            return False\n        return dt.day == days_in_month(dt.year, 12)\n\n    def _get_year_end(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Get the end of the current year.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        return JalaliTimestamp(\n            year=dt.year,\n            month=12,\n            day=days_in_month(dt.year, 12),\n            hour=dt.hour if not self._normalize else 0,\n            minute=dt.minute if not self._normalize else 0,\n            second=dt.second if not self._normalize else 0,\n            tzinfo=dt.tzinfo,\n        )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.year.JalaliYearEnd.__add__","title":"__add__","text":"<pre><code>__add__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Add years to timestamp, landing on year end.</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Add years to timestamp, landing on year end.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if not isinstance(other, JalaliTimestamp):\n        return NotImplemented\n\n    new_year = other.year + self._n\n    # Last day of Esfand (29 or 30 depending on leap year)\n    new_day = 30 if is_leap_year(new_year) else 29\n\n    return JalaliTimestamp(\n        year=new_year,\n        month=12,\n        day=new_day,\n        hour=other.hour if not self._normalize else 0,\n        minute=other.minute if not self._normalize else 0,\n        second=other.second if not self._normalize else 0,\n        microsecond=other.microsecond if not self._normalize else 0,\n        nanosecond=other.nanosecond if not self._normalize else 0,\n        tzinfo=other.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.year.JalaliYearEnd.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Subtract years from timestamp.</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Subtract years from timestamp.\"\"\"\n    return self.__neg__().__add__(other)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.year.JalaliYearEnd.is_on_offset","title":"is_on_offset","text":"<pre><code>is_on_offset(dt: JalaliTimestamp) -&gt; bool\n</code></pre> <p>Check if date is on year end (last day of Esfand).</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n    \"\"\"Check if date is on year end (last day of Esfand).\"\"\"\n    if dt.month != 12:\n        return False\n    return dt.day == days_in_month(dt.year, 12)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.year.JalaliYearEnd.rollback","title":"rollback","text":"<pre><code>rollback(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll back to previous year end.</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll back to previous year end.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if self.is_on_offset(dt):\n        return dt\n\n    # Go to previous year's end\n    new_year = dt.year - 1\n    new_day = 30 if is_leap_year(new_year) else 29\n\n    return JalaliTimestamp(\n        year=new_year,\n        month=12,\n        day=new_day,\n        hour=dt.hour if not self._normalize else 0,\n        minute=dt.minute if not self._normalize else 0,\n        second=dt.second if not self._normalize else 0,\n        tzinfo=dt.tzinfo,\n    )\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.year.JalaliYearEnd.rollforward","title":"rollforward","text":"<pre><code>rollforward(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll forward to next year end if not already on one.</p> Source code in <code>jalali_pandas/offsets/year.py</code> <pre><code>def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll forward to next year end if not already on one.\"\"\"\n    if self.is_on_offset(dt):\n        return dt\n    return self._get_year_end(dt)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.week.JalaliWeek","title":"JalaliWeek","text":"<p>               Bases: <code>JalaliOffset</code></p> <p>Offset to a specific day of the Jalali week.</p> <p>The Jalali week starts on Saturday (weekday=0) and ends on Friday (weekday=6).</p> <p>Attributes:</p> Name Type Description <code>weekday</code> <code>int</code> <p>The target weekday (0=Saturday, 6=Friday). Defaults to 0 (Saturday).</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>class JalaliWeek(JalaliOffset):\n    \"\"\"Offset to a specific day of the Jalali week.\n\n    The Jalali week starts on Saturday (weekday=0) and ends on Friday (weekday=6).\n\n    Attributes:\n        weekday: The target weekday (0=Saturday, 6=Friday). Defaults to 0 (Saturday).\n    \"\"\"\n\n    _prefix = \"JW\"\n    _attributes = (\"n\", \"normalize\", \"weekday\")\n\n    def __init__(\n        self,\n        n: int = 1,\n        normalize: bool = False,\n        weekday: int = SATURDAY,\n    ) -&gt; None:\n        \"\"\"Initialize JalaliWeek offset.\n\n        Args:\n            n: Number of weeks. Defaults to 1.\n            normalize: Whether to normalize to midnight. Defaults to False.\n            weekday: Target weekday (0=Saturday, 6=Friday). Defaults to 0 (Saturday).\n\n        Raises:\n            ValueError: If weekday is not in range 0-6.\n        \"\"\"\n        super().__init__(n=n, normalize=normalize)\n        if not 0 &lt;= weekday &lt;= 6:\n            raise ValueError(f\"weekday must be 0-6, got {weekday}\")\n        self._weekday = weekday\n\n    @property\n    def weekday(self) -&gt; int:\n        \"\"\"Target weekday (0=Saturday, 6=Friday).\"\"\"\n        return self._weekday\n\n    def __repr__(self) -&gt; str:\n        \"\"\"String representation.\"\"\"\n        return f\"&lt;{self.__class__.__name__}: n={self._n}, weekday={self._weekday}&gt;\"\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check equality.\"\"\"\n        if isinstance(other, JalaliWeek):\n            return (\n                type(self) is type(other)\n                and self._n == other._n\n                and self._weekday == other._weekday\n            )\n        return False\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Hash for use in sets and dicts.\"\"\"\n        return hash((type(self).__name__, self._n, self._weekday))\n\n    def __neg__(self) -&gt; JalaliWeek:\n        \"\"\"Return negated offset.\"\"\"\n        return JalaliWeek(n=-self._n, normalize=self._normalize, weekday=self._weekday)\n\n    def __mul__(self, other: int) -&gt; JalaliWeek:\n        \"\"\"Multiply offset by integer.\"\"\"\n        if isinstance(other, int):\n            return JalaliWeek(\n                n=self._n * other, normalize=self._normalize, weekday=self._weekday\n            )\n        return NotImplemented\n\n    def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Add weeks to timestamp, landing on target weekday.\"\"\"\n        from jalali_pandas.core.timestamp import JalaliTimestamp\n\n        if not isinstance(other, JalaliTimestamp):\n            return NotImplemented\n\n        # Get current weekday (0=Saturday, 6=Friday)\n        current_weekday = other.dayofweek\n\n        # Calculate days to target weekday\n        days_to_target = (self._weekday - current_weekday) % 7\n\n        # If we're already on the target weekday and n &gt; 0, we need to go forward\n        # If n &lt; 0, we need to go backward\n        if self._n &gt; 0:\n            # Move forward n weeks, landing on target weekday\n            if days_to_target == 0:\n                # Already on target, move n full weeks\n                total_days = self._n * 7\n            else:\n                # Move to next target weekday, then (n-1) more weeks\n                total_days = days_to_target + (self._n - 1) * 7\n        elif self._n &lt; 0:\n            # Move backward |n| weeks, landing on target weekday\n            if days_to_target == 0:\n                # Already on target, move |n| full weeks back\n                total_days = self._n * 7\n            else:\n                # Move to previous target weekday, then (|n|-1) more weeks back\n                days_to_prev_target = days_to_target - 7  # Negative\n                total_days = days_to_prev_target + (self._n + 1) * 7\n        else:\n            # n == 0, just move to nearest target weekday (forward)\n            total_days = days_to_target\n\n        # Apply the offset using timedelta\n        new_gregorian = other.to_gregorian() + timedelta(days=total_days)\n        result = JalaliTimestamp.from_gregorian(new_gregorian)\n\n        if self._normalize:\n            result = result.normalize()\n\n        return result\n\n    def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Subtract weeks from timestamp.\"\"\"\n        return self.__neg__().__add__(other)\n\n    def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll forward to next target weekday if not already on one.\"\"\"\n        if self.is_on_offset(dt):\n            return dt\n\n        # Calculate days to next target weekday\n        current_weekday = dt.dayofweek\n        days_forward = (self._weekday - current_weekday) % 7\n        if days_forward == 0:\n            days_forward = 7  # Move to next week if already on target\n\n        new_gregorian = dt.to_gregorian() + timedelta(days=days_forward)\n        result = type(dt).from_gregorian(new_gregorian)\n\n        if self._normalize:\n            result = result.normalize()\n\n        return result\n\n    def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n        \"\"\"Roll back to previous target weekday.\"\"\"\n        if self.is_on_offset(dt):\n            return dt\n\n        # Calculate days to previous target weekday\n        current_weekday = dt.dayofweek\n        days_back = (current_weekday - self._weekday) % 7\n        if days_back == 0:\n            days_back = 7  # Move to previous week if already on target\n\n        new_gregorian = dt.to_gregorian() - timedelta(days=days_back)\n        result = type(dt).from_gregorian(new_gregorian)\n\n        if self._normalize:\n            result = result.normalize()\n\n        return result\n\n    def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n        \"\"\"Check if date is on target weekday.\"\"\"\n        return dt.dayofweek == self._weekday\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.week.JalaliWeek.weekday","title":"weekday  <code>property</code>","text":"<pre><code>weekday: int\n</code></pre> <p>Target weekday (0=Saturday, 6=Friday).</p>"},{"location":"en/api/offsets/#jalali_pandas.offsets.week.JalaliWeek.__add__","title":"__add__","text":"<pre><code>__add__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Add weeks to timestamp, landing on target weekday.</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>def __add__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Add weeks to timestamp, landing on target weekday.\"\"\"\n    from jalali_pandas.core.timestamp import JalaliTimestamp\n\n    if not isinstance(other, JalaliTimestamp):\n        return NotImplemented\n\n    # Get current weekday (0=Saturday, 6=Friday)\n    current_weekday = other.dayofweek\n\n    # Calculate days to target weekday\n    days_to_target = (self._weekday - current_weekday) % 7\n\n    # If we're already on the target weekday and n &gt; 0, we need to go forward\n    # If n &lt; 0, we need to go backward\n    if self._n &gt; 0:\n        # Move forward n weeks, landing on target weekday\n        if days_to_target == 0:\n            # Already on target, move n full weeks\n            total_days = self._n * 7\n        else:\n            # Move to next target weekday, then (n-1) more weeks\n            total_days = days_to_target + (self._n - 1) * 7\n    elif self._n &lt; 0:\n        # Move backward |n| weeks, landing on target weekday\n        if days_to_target == 0:\n            # Already on target, move |n| full weeks back\n            total_days = self._n * 7\n        else:\n            # Move to previous target weekday, then (|n|-1) more weeks back\n            days_to_prev_target = days_to_target - 7  # Negative\n            total_days = days_to_prev_target + (self._n + 1) * 7\n    else:\n        # n == 0, just move to nearest target weekday (forward)\n        total_days = days_to_target\n\n    # Apply the offset using timedelta\n    new_gregorian = other.to_gregorian() + timedelta(days=total_days)\n    result = JalaliTimestamp.from_gregorian(new_gregorian)\n\n    if self._normalize:\n        result = result.normalize()\n\n    return result\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.week.JalaliWeek.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check equality.</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check equality.\"\"\"\n    if isinstance(other, JalaliWeek):\n        return (\n            type(self) is type(other)\n            and self._n == other._n\n            and self._weekday == other._weekday\n        )\n    return False\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.week.JalaliWeek.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Hash for use in sets and dicts.</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Hash for use in sets and dicts.\"\"\"\n    return hash((type(self).__name__, self._n, self._weekday))\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.week.JalaliWeek.__init__","title":"__init__","text":"<pre><code>__init__(n: int = 1, normalize: bool = False, weekday: int = SATURDAY) -&gt; None\n</code></pre> <p>Initialize JalaliWeek offset.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of weeks. Defaults to 1.</p> <code>1</code> <code>normalize</code> <code>bool</code> <p>Whether to normalize to midnight. Defaults to False.</p> <code>False</code> <code>weekday</code> <code>int</code> <p>Target weekday (0=Saturday, 6=Friday). Defaults to 0 (Saturday).</p> <code>SATURDAY</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If weekday is not in range 0-6.</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>def __init__(\n    self,\n    n: int = 1,\n    normalize: bool = False,\n    weekday: int = SATURDAY,\n) -&gt; None:\n    \"\"\"Initialize JalaliWeek offset.\n\n    Args:\n        n: Number of weeks. Defaults to 1.\n        normalize: Whether to normalize to midnight. Defaults to False.\n        weekday: Target weekday (0=Saturday, 6=Friday). Defaults to 0 (Saturday).\n\n    Raises:\n        ValueError: If weekday is not in range 0-6.\n    \"\"\"\n    super().__init__(n=n, normalize=normalize)\n    if not 0 &lt;= weekday &lt;= 6:\n        raise ValueError(f\"weekday must be 0-6, got {weekday}\")\n    self._weekday = weekday\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.week.JalaliWeek.__mul__","title":"__mul__","text":"<pre><code>__mul__(other: int) -&gt; JalaliWeek\n</code></pre> <p>Multiply offset by integer.</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>def __mul__(self, other: int) -&gt; JalaliWeek:\n    \"\"\"Multiply offset by integer.\"\"\"\n    if isinstance(other, int):\n        return JalaliWeek(\n            n=self._n * other, normalize=self._normalize, weekday=self._weekday\n        )\n    return NotImplemented\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.week.JalaliWeek.__neg__","title":"__neg__","text":"<pre><code>__neg__() -&gt; JalaliWeek\n</code></pre> <p>Return negated offset.</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>def __neg__(self) -&gt; JalaliWeek:\n    \"\"\"Return negated offset.\"\"\"\n    return JalaliWeek(n=-self._n, normalize=self._normalize, weekday=self._weekday)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.week.JalaliWeek.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>String representation.</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"String representation.\"\"\"\n    return f\"&lt;{self.__class__.__name__}: n={self._n}, weekday={self._weekday}&gt;\"\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.week.JalaliWeek.__sub__","title":"__sub__","text":"<pre><code>__sub__(other: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Subtract weeks from timestamp.</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>def __sub__(self, other: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Subtract weeks from timestamp.\"\"\"\n    return self.__neg__().__add__(other)\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.week.JalaliWeek.is_on_offset","title":"is_on_offset","text":"<pre><code>is_on_offset(dt: JalaliTimestamp) -&gt; bool\n</code></pre> <p>Check if date is on target weekday.</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>def is_on_offset(self, dt: JalaliTimestamp) -&gt; bool:\n    \"\"\"Check if date is on target weekday.\"\"\"\n    return dt.dayofweek == self._weekday\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.week.JalaliWeek.rollback","title":"rollback","text":"<pre><code>rollback(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll back to previous target weekday.</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>def rollback(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll back to previous target weekday.\"\"\"\n    if self.is_on_offset(dt):\n        return dt\n\n    # Calculate days to previous target weekday\n    current_weekday = dt.dayofweek\n    days_back = (current_weekday - self._weekday) % 7\n    if days_back == 0:\n        days_back = 7  # Move to previous week if already on target\n\n    new_gregorian = dt.to_gregorian() - timedelta(days=days_back)\n    result = type(dt).from_gregorian(new_gregorian)\n\n    if self._normalize:\n        result = result.normalize()\n\n    return result\n</code></pre>"},{"location":"en/api/offsets/#jalali_pandas.offsets.week.JalaliWeek.rollforward","title":"rollforward","text":"<pre><code>rollforward(dt: JalaliTimestamp) -&gt; JalaliTimestamp\n</code></pre> <p>Roll forward to next target weekday if not already on one.</p> Source code in <code>jalali_pandas/offsets/week.py</code> <pre><code>def rollforward(self, dt: JalaliTimestamp) -&gt; JalaliTimestamp:\n    \"\"\"Roll forward to next target weekday if not already on one.\"\"\"\n    if self.is_on_offset(dt):\n        return dt\n\n    # Calculate days to next target weekday\n    current_weekday = dt.dayofweek\n    days_forward = (self._weekday - current_weekday) % 7\n    if days_forward == 0:\n        days_forward = 7  # Move to next week if already on target\n\n    new_gregorian = dt.to_gregorian() + timedelta(days=days_forward)\n    result = type(dt).from_gregorian(new_gregorian)\n\n    if self._normalize:\n        result = result.normalize()\n\n    return result\n</code></pre>"},{"location":"en/examples/","title":"Examples","text":"<p>All examples are available in the <code>examples/</code> directory of the repository.</p> <ul> <li><code>examples/01_basic_usage.py</code> \u2014 JalaliTimestamp basics</li> <li><code>examples/02_series_operations.py</code> \u2014 Series accessor workflow</li> <li><code>examples/03_dataframe_operations.py</code> \u2014 DataFrame grouping</li> <li><code>examples/04_offsets.py</code> \u2014 Offsets and frequency aliases</li> <li><code>examples/05_index_and_date_range.py</code> \u2014 Index creation and conversion</li> <li><code>examples/00_zero_to_hero.ipynb</code> \u2014 Notebook walkthrough</li> <li><code>examples/basic_usage.ipynb</code> \u2014 Short notebook</li> </ul> <p>Each example page below summarizes the script and includes core snippets.</p>"},{"location":"en/examples/basic-usage/","title":"Example: Basic Usage","text":"<p>Source: <code>examples/01_basic_usage.py</code></p>"},{"location":"en/examples/basic-usage/#create-timestamps-and-convert","title":"Create timestamps and convert","text":"<pre><code>from jalali_pandas import JalaliTimestamp\nimport pandas as pd\n\nts = JalaliTimestamp(1402, 6, 15)\n\ngregorian = pd.Timestamp(\"2023-09-06\")\nts_from_greg = JalaliTimestamp.from_gregorian(gregorian)\n</code></pre>"},{"location":"en/examples/basic-usage/#common-operations","title":"Common operations","text":"<pre><code>ts.normalize()\nts.replace(year=1403, month=1)\nts.strftime(\"%Y-%m-%d\")\n</code></pre>"},{"location":"en/examples/dataframe-operations/","title":"Example: DataFrame Operations","text":"<p>Source: <code>examples/03_dataframe_operations.py</code></p> <pre><code>import pandas as pd\nimport jalali_pandas\n\ndf = pd.DataFrame({\n    \"date\": pd.date_range(\"2019-01-01\", periods=6, freq=\"ME\"),\n    \"sales\": [100, 120, 90, 140, 160, 110],\n})\n\ndf[\"jdate\"] = df[\"date\"].jalali.to_jalali()\n\nyearly = df.jalali.groupby(\"year\").sum(numeric_only=True)\n</code></pre>"},{"location":"en/examples/index-and-date-range/","title":"Example: Index &amp; Date Range","text":"<p>Source: <code>examples/05_index_and_date_range.py</code></p> <pre><code>import pandas as pd\nimport jalali_pandas as jp\n\nidx = jp.JalaliDatetimeIndex([\"1402-01-01\", \"1402-01-15\"])\n\nrng = jp.jalali_date_range(\"1402-01-01\", periods=3, freq=\"JME\")\n</code></pre>"},{"location":"en/examples/index-and-date-range/#conversions","title":"Conversions","text":"<pre><code>jalali = jp.to_jalali_datetime(pd.Timestamp(\"2023-09-06\"))\nback = jp.to_gregorian_datetime(jalali)\n</code></pre>"},{"location":"en/examples/notebooks/","title":"Notebooks","text":"<p>Notebook sources:</p> <ul> <li><code>examples/00_zero_to_hero.ipynb</code></li> <li><code>examples/basic_usage.ipynb</code></li> </ul> <p>Open in Colab:</p> <ul> <li>https://colab.research.google.com/github/ghodsizadeh/jalali-pandas/blob/main/examples/00_zero_to_hero.ipynb</li> <li>https://colab.research.google.com/github/ghodsizadeh/jalali-pandas/blob/main/examples/basic_usage.ipynb</li> </ul>"},{"location":"en/examples/offsets/","title":"Example: Offsets","text":"<p>Source: <code>examples/04_offsets.py</code></p> <pre><code>from jalali_pandas import JalaliTimestamp\nfrom jalali_pandas.offsets import JalaliMonthEnd, JalaliWeek, FRIDAY\n\nts = JalaliTimestamp(1402, 6, 15)\n\nnext_month_end = ts + JalaliMonthEnd()\nnext_friday = ts + JalaliWeek(weekday=FRIDAY)\n</code></pre>"},{"location":"en/examples/offsets/#parse-aliases","title":"Parse aliases","text":"<pre><code>from jalali_pandas.offsets import parse_jalali_frequency\n\nparse_jalali_frequency(\"JME\")\nparse_jalali_frequency(\"2JQE\")\n</code></pre>"},{"location":"en/examples/series-operations/","title":"Example: Series Operations","text":"<p>Source: <code>examples/02_series_operations.py</code></p> <pre><code>import pandas as pd\nimport jalali_pandas  # registers accessors\n\ns = pd.Series(pd.date_range(\"2023-03-21\", periods=3, freq=\"D\"))\nj = s.jalali.to_jalali()\n\nj.jalali.year\nj.jalali.month\nj.jalali.day\n</code></pre>"},{"location":"en/examples/series-operations/#parse-jalali-strings","title":"Parse Jalali strings","text":"<pre><code>df = pd.DataFrame({\"date_str\": [\"1402/01/01\", \"1402/01/15\"]})\ndf[\"jdate\"] = df[\"date_str\"].jalali.parse_jalali(\"%Y/%m/%d\")\n</code></pre>"},{"location":"en/user-guide/accessors/","title":"Accessors","text":"<p>Importing <code>jalali_pandas</code> registers the <code>.jalali</code> accessor on Series and DataFrames.</p>"},{"location":"en/user-guide/accessors/#series-accessor-jalaliseriesaccessor","title":"Series accessor (<code>JalaliSeriesAccessor</code>)","text":"<p>The Series accessor expects <code>jdatetime</code> values or Jalali strings. If you have Gregorian datetimes, convert first with <code>series.jalali.to_jalali()</code>.</p>"},{"location":"en/user-guide/accessors/#conversion","title":"Conversion","text":"<ul> <li><code>to_jalali()</code></li> <li><code>to_gregorian()</code></li> <li><code>parse_jalali(format=\"%Y-%m-%d\")</code></li> </ul>"},{"location":"en/user-guide/accessors/#properties","title":"Properties","text":"<ul> <li><code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, <code>second</code>, <code>microsecond</code>, <code>nanosecond</code></li> <li><code>quarter</code>, <code>weekday</code>, <code>dayofweek</code>, <code>dayofyear</code></li> <li><code>week</code>, <code>weekofyear</code>, <code>weeknumber</code></li> <li><code>daysinmonth</code>, <code>days_in_month</code></li> </ul>"},{"location":"en/user-guide/accessors/#boolean-properties","title":"Boolean properties","text":"<ul> <li><code>is_leap_year</code></li> <li><code>is_month_start</code>, <code>is_month_end</code></li> <li><code>is_quarter_start</code>, <code>is_quarter_end</code></li> <li><code>is_year_start</code>, <code>is_year_end</code></li> </ul>"},{"location":"en/user-guide/accessors/#formatting-and-rounding","title":"Formatting and rounding","text":"<ul> <li><code>strftime(format)</code></li> <li><code>month_name(locale=\"fa\"|\"en\")</code>, <code>day_name(locale=\"fa\"|\"en\")</code></li> <li><code>normalize()</code>, <code>floor(freq)</code>, <code>ceil(freq)</code>, <code>round(freq)</code></li> </ul> <pre><code>import pandas as pd\nimport jalali_pandas  # registers accessor\n\nseries = pd.Series(pd.date_range(\"2023-03-21\", periods=3))\njseries = series.jalali.to_jalali()\n\n# English names are the default\nprint(jseries.jalali.month_name())\n\n# Farsi names\nprint(jseries.jalali.month_name(locale=\"fa\"))\n</code></pre>"},{"location":"en/user-guide/accessors/#timezone-helpers","title":"Timezone helpers","text":"<p><code>tz_localize</code> and <code>tz_convert</code> return timezone-aware Gregorian datetimes:</p> <ul> <li><code>tz_localize(tz, ambiguous=\"raise\", nonexistent=\"raise\")</code></li> <li><code>tz_convert(tz)</code></li> </ul>"},{"location":"en/user-guide/accessors/#dataframe-accessor-jalalidataframeaccessor","title":"DataFrame accessor (<code>JalaliDataFrameAccessor</code>)","text":"<p>The DataFrame accessor expects at least one column with <code>jdatetime</code> values. Create one with <code>.jalali.to_jalali()</code> and set it explicitly if you have multiple Jalali columns.</p>"},{"location":"en/user-guide/accessors/#key-methods","title":"Key methods","text":"<ul> <li><code>set_date_column(column)</code></li> <li><code>groupby(grouper)</code></li> <li><code>resample(resample_type)</code> where <code>resample_type</code> is <code>month|quarter|year|week</code></li> <li><code>convert_columns(columns, to_jalali=True, format=\"%Y-%m-%d\")</code></li> <li><code>to_period(freq=\"M\")</code></li> <li><code>filter_by_year</code>, <code>filter_by_month</code>, <code>filter_by_quarter</code>, <code>filter_by_date_range</code></li> </ul> <p>Supported groupby keys:</p> <p><code>year</code>, <code>month</code>, <code>day</code>, <code>week</code>, <code>dayofweek</code>, <code>dayofmonth</code>, <code>quarter</code>, <code>dayofyear</code>, <code>ym</code>, <code>yq</code>, <code>ymd</code>, <code>md</code></p> <pre><code>import pandas as pd\nimport jalali_pandas\n\ndf = pd.DataFrame({\"date\": pd.date_range(\"2023-03-21\", periods=10)})\ndf[\"jdate\"] = df[\"date\"].jalali.to_jalali()\n\nmonthly = df.jalali.groupby(\"month\").size()\nconverted = df.jalali.convert_columns(\"date\", to_jalali=True)\n</code></pre>"},{"location":"en/user-guide/accessors/#legacy-accessors","title":"Legacy accessors","text":"<ul> <li><code>jalali_pandas.df_handler.JalaliDataframeAccessor</code></li> <li><code>jalali_pandas.serie_handler.JalaliSerieAccessor</code></li> </ul> <p>Use the new accessors in <code>jalali_pandas.accessors.*</code> for full features.</p>"},{"location":"en/user-guide/conversion/","title":"Conversion","text":""},{"location":"en/user-guide/conversion/#public-conversion-helpers","title":"Public conversion helpers","text":"<ul> <li><code>to_jalali_datetime(...)</code></li> <li><code>to_gregorian_datetime(...)</code></li> </ul> <pre><code>import pandas as pd\nimport jalali_pandas as jp\n\njp.to_jalali_datetime(\"1402-06-15\")\n\njp.to_jalali_datetime(pd.Timestamp(\"2023-09-06\"))\n\njp.to_jalali_datetime([\"1402-01-01\", \"1402-01-02\"])\n\njidx = jp.JalaliDatetimeIndex([\"1402-01-01\", \"1402-01-02\"])\njp.to_gregorian_datetime(jidx)\n</code></pre>"},{"location":"en/user-guide/conversion/#error-handling","title":"Error handling","text":"<p><code>to_jalali_datetime(..., errors=...)</code> supports:</p> <ul> <li><code>\"raise\"</code> (default)</li> <li><code>\"coerce\"</code> \u2192 invalid values become <code>pd.NaT</code></li> <li><code>\"ignore\"</code> \u2192 return the original input (only for Series)</li> </ul>"},{"location":"en/user-guide/conversion/#supported-string-formats-when-formatnone","title":"Supported string formats (when <code>format=None</code>)","text":"<p>The parser tries these formats in order:</p> <ul> <li><code>%Y-%m-%d %H:%M:%S</code></li> <li><code>%Y-%m-%d</code></li> <li><code>%Y/%m/%d %H:%M:%S</code></li> <li><code>%Y/%m/%d</code></li> <li><code>%Y%m%d</code></li> </ul>"},{"location":"en/user-guide/conversion/#vectorized-conversion-helpers","title":"Vectorized conversion helpers","text":"<p>These are internal helpers used by arrays and indexes:</p> <ul> <li><code>gregorian_to_jalali_vectorized</code></li> <li><code>jalali_to_gregorian_vectorized</code></li> <li><code>datetime64_to_jalali</code></li> <li><code>jalali_to_datetime64</code></li> </ul> <p>Use the public API unless you need lower-level access.</p>"},{"location":"en/user-guide/core-types/","title":"Core Types","text":""},{"location":"en/user-guide/core-types/#jalalitimestamp","title":"JalaliTimestamp","text":"<p><code>JalaliTimestamp</code> is the scalar type for Jalali dates.</p> <pre><code>from jalali_pandas import JalaliTimestamp\n\nts = JalaliTimestamp(1402, 6, 15, 10, 30)\nprint(ts.year, ts.month, ts.day)\nprint(ts.to_gregorian())\n</code></pre> <p>Key methods and properties:</p> <ul> <li><code>JalaliTimestamp.from_gregorian(pd.Timestamp)</code></li> <li><code>JalaliTimestamp.strptime(string, format)</code></li> <li><code>to_gregorian()</code></li> <li><code>normalize()</code>, <code>replace(...)</code></li> <li><code>tz_localize(...)</code>, <code>tz_convert(...)</code></li> </ul>"},{"location":"en/user-guide/core-types/#jalalidatetimedtype","title":"JalaliDatetimeDtype","text":"<p>The pandas extension dtype representing Jalali timestamps.</p> <pre><code>from jalali_pandas.core.dtypes import JalaliDatetimeDtype\n\ndtype = JalaliDatetimeDtype()\n</code></pre>"},{"location":"en/user-guide/core-types/#jalalidatetimearray","title":"JalaliDatetimeArray","text":"<p>The extension array storing Jalali values.</p> <pre><code>from jalali_pandas.core.arrays import JalaliDatetimeArray\nfrom jalali_pandas import JalaliTimestamp\n\narr = JalaliDatetimeArray._from_sequence(\n    [JalaliTimestamp(1402, 1, 1), JalaliTimestamp(1402, 1, 2)]\n)\n</code></pre>"},{"location":"en/user-guide/core-types/#calendar-utilities","title":"Calendar utilities","text":"<pre><code>from jalali_pandas.core.calendar import is_leap_year, days_in_month, days_in_year\n\nis_leap_year(1403)\ndays_in_month(1402, 12)\ndays_in_year(1402)\n</code></pre>"},{"location":"en/user-guide/frequency-offsets/","title":"Frequency Offsets","text":"<p>Jalali offsets follow pandas-style DateOffset behavior but use Jalali calendar rules (month lengths, leap years, Jalali quarters, and week boundaries).</p>"},{"location":"en/user-guide/frequency-offsets/#offset-classes","title":"Offset classes","text":"<ul> <li><code>JalaliMonthBegin</code>, <code>JalaliMonthEnd</code></li> <li><code>JalaliQuarterBegin</code>, <code>JalaliQuarterEnd</code></li> <li><code>JalaliYearBegin</code>, <code>JalaliYearEnd</code></li> <li><code>JalaliWeek</code> (weekly offset, optional weekday anchor)</li> </ul> <pre><code>from jalali_pandas import JalaliTimestamp\nfrom jalali_pandas.offsets import JalaliMonthEnd, JalaliWeek, FRIDAY\n\nts = JalaliTimestamp(1402, 6, 15)\nprint(ts + JalaliMonthEnd())\nprint(ts + JalaliWeek(weekday=FRIDAY))\n</code></pre>"},{"location":"en/user-guide/frequency-offsets/#frequency-aliases","title":"Frequency aliases","text":"<p>Aliases are registered in <code>jalali_pandas.offsets.aliases</code>:</p> <ul> <li>JME / JMS</li> <li>JQE / JQS</li> <li>JYE / JYS</li> <li>JW (weekly, default weekday is Saturday)</li> </ul> <pre><code>from jalali_pandas.offsets import parse_jalali_frequency, list_jalali_aliases\n\nparse_jalali_frequency(\"JME\")\nparse_jalali_frequency(\"JW\")  # Saturday by default\nlist_jalali_aliases()\n</code></pre> <p>To target a specific weekday, use <code>JalaliWeek(weekday=...)</code> directly. You can register your own alias with <code>register_jalali_alias</code>.</p>"},{"location":"en/user-guide/index-range/","title":"Index &amp; Range Generation","text":""},{"location":"en/user-guide/index-range/#jalalidatetimeindex","title":"JalaliDatetimeIndex","text":"<p><code>JalaliDatetimeIndex</code> is the Jalali-native index type for Series and DataFrames.</p> <pre><code>import jalali_pandas as jp\n\nidx = jp.JalaliDatetimeIndex([\"1402-01-01\", \"1402-01-02\"], name=\"dates\")\ngregorian = idx.to_gregorian()\n</code></pre>"},{"location":"en/user-guide/index-range/#useful-operations","title":"Useful operations","text":"<ul> <li>Partial string indexing with <code>get_loc(\"1402\")</code> or <code>get_loc(\"1402-01\")</code></li> <li>Set ops: <code>union</code>, <code>intersection</code>, <code>difference</code></li> <li>Shifts with <code>shift(periods=..., freq=...)</code></li> <li>Snap to frequency with <code>snap(freq=\"s\")</code></li> </ul> <pre><code>idx = jp.jalali_date_range(\"1402-01-01\", periods=40)\nmask = idx.get_loc(\"1402-02\")  # boolean mask for a Jalali month\nsubset = idx[mask]\n</code></pre> <pre><code>shifted = idx.shift(periods=1, freq=\"JME\")\ndaily_shift = idx.shift(periods=1, freq=\"1D\")\n</code></pre>"},{"location":"en/user-guide/index-range/#jalali_date_range","title":"jalali_date_range","text":"<pre><code>import jalali_pandas as jp\n\njp.jalali_date_range(\"1402-01-01\", periods=5, freq=\"D\")\njp.jalali_date_range(\"1402-01-01\", \"1402-01-10\", freq=\"D\")\njp.jalali_date_range(\"1402-01-01\", periods=3, freq=\"JME\")\n</code></pre>"},{"location":"en/user-guide/index-range/#parameters","title":"Parameters","text":"<ul> <li>Provide at least two of <code>start</code>, <code>end</code>, <code>periods</code>.</li> <li>If all three are provided, <code>freq</code> is required.</li> <li><code>freq</code> accepts Jalali aliases (JME/JMS/JQE/JQS/JYE/JYS/JW) or common pandas   frequencies (D/H/MIN/S/W) and their multipliers (e.g., <code>2D</code>, <code>3MIN</code>).</li> <li><code>inclusive</code> controls boundary inclusion: <code>both</code>, <code>left</code>, <code>right</code>, <code>neither</code>.</li> </ul>"},{"location":"en/user-guide/index-range/#jalali-frequency-examples","title":"Jalali frequency examples","text":"<pre><code>jp.jalali_date_range(\"1402-01-01\", periods=6, freq=\"JME\")\njp.jalali_date_range(\"1402-01-01\", periods=4, freq=\"JQE\")\njp.jalali_date_range(\"1402-01-01\", periods=5, freq=\"JW\")\n</code></pre>"},{"location":"en/user-guide/index-range/#timezone-support","title":"Timezone support","text":"<p><code>jalali_date_range(..., tz=...)</code> stores the timezone in the dtype.</p>"},{"location":"en/user-guide/limitations/","title":"Limitations","text":"<p>Current limitations based on the implementation:</p> <ul> <li><code>JalaliDataFrameAccessor</code> requires at least one column of <code>jdatetime</code>   objects and raises if none are present.</li> <li><code>JalaliResampler</code> expects a <code>pd.DatetimeIndex</code> as index; otherwise it raises.</li> <li><code>jalali_date_range</code> requires at least two of <code>start</code>, <code>end</code>, <code>periods</code>;   if all three are provided, <code>freq</code> is required.</li> <li><code>to_jalali_datetime</code> parses a fixed set of formats unless <code>format</code> is   provided explicitly.</li> <li><code>JalaliDatetimeArray</code> stores values in an object array, which can be slower   than native <code>datetime64</code> operations for large datasets.</li> </ul> <p>If you hit a limitation, open an issue with a minimal reproduction case.</p>"},{"location":"en/user-guide/nat-handling/","title":"NaT Handling","text":"<p><code>JalaliNaT</code> is the Jalali equivalent of pandas <code>NaT</code>. Use <code>isna_jalali</code> to check values.</p> <pre><code>import pandas as pd\nfrom jalali_pandas.core.timestamp import JalaliNaT, isna_jalali\n\nisna_jalali(JalaliNaT)\nisna_jalali(pd.NaT)\n</code></pre> <p>Behavior notes:</p> <ul> <li>Comparisons against <code>JalaliNaT</code> behave like pandas <code>NaT</code> (mostly False).</li> <li><code>JalaliNaT.to_gregorian()</code> returns <code>pd.NaT</code>.</li> </ul>"},{"location":"en/user-guide/time-series/","title":"Time Series Operations","text":""},{"location":"en/user-guide/time-series/#overview","title":"Overview","text":"<p>There are two main workflows:</p> <ol> <li>Gregorian timestamps/indexes \u2192 use <code>JalaliGrouper</code>, <code>jalali_groupby</code>,    or <code>resample_jalali</code>.</li> <li>Jalali <code>jdatetime</code> columns \u2192 use the DataFrame accessor    (<code>df.jalali.groupby(...)</code>, <code>df.jalali.resample(...)</code>).</li> </ol> <p><code>JalaliGrouper</code> and <code>resample_jalali</code> expect Gregorian datetimes. If you have <code>jdatetime</code> values, convert to Gregorian or use the DataFrame accessor.</p>"},{"location":"en/user-guide/time-series/#jalaligrouper","title":"JalaliGrouper","text":"<p>Use <code>JalaliGrouper</code> to create group labels based on Jalali boundaries. The labels are Gregorian <code>pd.Timestamp</code> values.</p> <pre><code>import pandas as pd\nfrom jalali_pandas.api import JalaliGrouper\n\ndf = pd.DataFrame({\n    \"date\": pd.date_range(\"2023-03-21\", periods=10, freq=\"D\"),\n    \"value\": range(10),\n})\n\ngrouper = JalaliGrouper(key=\"date\", freq=\"JME\")\nresult = df.groupby(grouper.get_grouper(df)).sum()\n</code></pre>"},{"location":"en/user-guide/time-series/#jalali_groupby","title":"jalali_groupby","text":"<pre><code>from jalali_pandas.api import jalali_groupby\n\nresult = jalali_groupby(df, key=\"date\", freq=\"JME\").sum()\n</code></pre>"},{"location":"en/user-guide/time-series/#jalaliresampler-and-resample_jalali","title":"JalaliResampler and resample_jalali","text":"<p><code>JalaliResampler</code> groups by Jalali period boundaries but requires a <code>pd.DatetimeIndex</code> as index.</p> <pre><code>from jalali_pandas.api import resample_jalali\n\nseries = df.set_index(\"date\")[\"value\"]\nresampled = resample_jalali(series, freq=\"JME\").sum()\n</code></pre>"},{"location":"en/user-guide/time-series/#dataframe-accessor-resample","title":"DataFrame accessor resample","text":"<p><code>JalaliDataFrameAccessor.resample()</code> supports month/quarter/year/weekly grouping for DataFrames that contain a <code>jdatetime</code> column.</p> <pre><code>df[\"jdate\"] = df[\"date\"].jalali.to_jalali()\nmonthly = df.jalali.resample(\"month\")\n</code></pre>"},{"location":"en/user-guide/timezones/","title":"Timezones","text":"<p>Jalali timestamps support timezone localization and conversion by delegating to pandas' timezone handling.</p>"},{"location":"en/user-guide/timezones/#jalalitimestamp","title":"JalaliTimestamp","text":"<pre><code>from jalali_pandas import JalaliTimestamp\n\nts = JalaliTimestamp(1402, 6, 15, 12, 0)\n\nlocalized = ts.tz_localize(\"Asia/Tehran\")\nconverted = localized.tz_convert(\"UTC\")\n</code></pre> <p>Rules:</p> <ul> <li><code>tz_localize()</code> requires a naive timestamp.</li> <li><code>tz_convert()</code> requires a timezone-aware timestamp.</li> </ul>"},{"location":"en/user-guide/timezones/#series-accessor","title":"Series accessor","text":"<pre><code>import pandas as pd\n\ns = pd.Series(pd.date_range(\"2023-03-21\", periods=2, freq=\"D\"))\nj = s.jalali.to_jalali()\n\nj_local = j.jalali.tz_localize(\"Asia/Tehran\")\nj_utc = j_local.jalali.tz_convert(\"UTC\")\n</code></pre>"},{"location":"fa/","title":"jalali_pandas","text":"<p>\u067e\u0634\u062a\u06cc\u0628\u0627\u0646\u06cc \u06a9\u0627\u0645\u0644 \u0627\u0632 \u062a\u0642\u0648\u06cc\u0645 \u062c\u0644\u0627\u0644\u06cc (\u0634\u0645\u0633\u06cc) \u0628\u0631\u0627\u06cc pandas \u0628\u0627 \u0627\u0646\u0648\u0627\u0639 \u062f\u0627\u062f\u0647\u060c \u0627\u06cc\u0646\u062f\u06a9\u0633\u060c \u0627\u0641\u0633\u062a\u200c\u0647\u0627 \u0648 \u0627\u06a9\u0633\u0633\u0648\u0631\u0647\u0627\u06cc \u0627\u062e\u062a\u0635\u0627\u0635\u06cc.</p>"},{"location":"fa/#_1","title":"\u0646\u06a9\u0627\u062a \u06a9\u0644\u06cc\u062f\u06cc","text":"<ul> <li>\u0646\u0648\u0639 <code>JalaliTimestamp</code> \u0628\u0631\u0627\u06cc \u062a\u0627\u0631\u06cc\u062e \u062c\u0644\u0627\u0644\u06cc</li> <li><code>JalaliDatetimeIndex</code> \u0648 <code>jalali_date_range</code> \u0628\u0631\u0627\u06cc \u0633\u0631\u06cc\u200c\u0647\u0627\u06cc \u0632\u0645\u0627\u0646\u06cc</li> <li>\u062a\u0628\u062f\u06cc\u0644 \u0628\u0631\u062f\u0627\u0631\u06cc \u062a\u0627\u0631\u06cc\u062e\u200c\u0647\u0627</li> <li>\u0627\u0641\u0633\u062a\u200c\u0647\u0627\u06cc \u062c\u0644\u0627\u0644\u06cc \u0628\u0627 alias \u0647\u0627\u06cc JME/JMS/JQE/JQS/JYE/JYS/JW</li> <li>\u0627\u06a9\u0633\u0633\u0648\u0631\u0647\u0627\u06cc <code>.jalali</code> \u0628\u0631\u0627\u06cc Series \u0648 DataFrame</li> <li>\u0627\u0628\u0632\u0627\u0631\u0647\u0627\u06cc \u06af\u0631\u0648\u0647\u200c\u0628\u0646\u062f\u06cc \u0648 \u0628\u0627\u0632\u0646\u0645\u0648\u0646\u0647\u200c\u06af\u06cc\u0631\u06cc \u0628\u0631 \u0627\u0633\u0627\u0633 \u0645\u0631\u0632\u0647\u0627\u06cc \u062c\u0644\u0627\u0644\u06cc</li> </ul>"},{"location":"fa/#_2","title":"\u0645\u062b\u0627\u0644 \u0633\u0631\u06cc\u0639","text":"<pre><code>import pandas as pd\nimport jalali_pandas as jp\n\ns = pd.Series(pd.date_range(\"2023-03-21\", periods=3, freq=\"D\"))\nj = s.jalali.to_jalali()\n\nidx = jp.jalali_date_range(\"1402-01-01\", periods=3, freq=\"D\")\n</code></pre>"},{"location":"fa/#_3","title":"\u0645\u0633\u06cc\u0631 \u0628\u0639\u062f\u06cc","text":"<ul> <li>\u0646\u0635\u0628: \u0646\u0635\u0628</li> <li>\u0634\u0631\u0648\u0639 \u0633\u0631\u06cc\u0639: \u0634\u0631\u0648\u0639 \u0633\u0631\u06cc\u0639</li> <li>\u0631\u0627\u0647\u0646\u0645\u0627\u06cc \u06a9\u0627\u0631\u0628\u0631: \u0627\u0646\u0648\u0627\u0639 \u0627\u0635\u0644\u06cc</li> <li>\u0645\u062b\u0627\u0644\u200c\u0647\u0627: \u0646\u0645\u0627\u06cc \u06a9\u0644\u06cc \u0645\u062b\u0627\u0644\u200c\u0647\u0627</li> </ul>"},{"location":"fa/benchmarks/","title":"\u0628\u0646\u0686\u0645\u0627\u0631\u06a9","text":"<p>\u062f\u0631 \u062d\u0627\u0644 \u062d\u0627\u0636\u0631 \u0628\u0646\u0686\u0645\u0627\u0631\u06a9\u200c\u0647\u0627\u06cc ASV \u0628\u0647 \u0635\u0648\u0631\u062a \u067e\u06cc\u0634\u200c\u0641\u0631\u0636 \u062f\u0631 \u0645\u062e\u0632\u0646 \u0648\u062c\u0648\u062f \u0646\u062f\u0627\u0631\u0646\u062f. \u0627\u06af\u0631 \u0642\u0635\u062f \u062f\u0627\u0631\u06cc\u062f \u0639\u0645\u0644\u06a9\u0631\u062f \u0631\u0627 \u062f\u0646\u0628\u0627\u0644 \u06a9\u0646\u06cc\u062f\u060c \u0645\u06cc\u200c\u062a\u0648\u0627\u0646\u06cc\u062f \u062f\u0631 \u0641\u0648\u0631\u06a9 \u062e\u0648\u062f\u062a\u0627\u0646 ASV \u0631\u0627 \u0628\u0631\u06af\u0631\u062f\u0627\u0646\u06cc\u062f:</p> <p>1) \u0627\u0641\u0632\u0648\u062f\u0646 <code>asv</code> \u0628\u0647 \u0648\u0627\u0628\u0633\u062a\u06af\u06cc\u200c\u0647\u0627\u06cc \u0627\u062e\u062a\u06cc\u0627\u0631\u06cc \u062f\u0631 <code>pyproject.toml</code> 2) \u0627\u0641\u0632\u0648\u062f\u0646 <code>asv.conf.json</code> \u0648 \u067e\u0648\u0634\u0647 <code>benchmarks/</code> 3) \u0627\u062c\u0631\u0627\u06cc <code>uv run asv run --quick</code></p> <p>\u0628\u0631\u0627\u06cc \u0628\u0631\u0631\u0633\u06cc \u0633\u0631\u06cc\u0639 \u0639\u0645\u0644\u06a9\u0631\u062f\u060c \u0645\u06cc\u200c\u062a\u0648\u0627\u0646\u06cc\u062f \u0627\u0632 \u0627\u06cc\u0646 \u0627\u0633\u06a9\u0631\u06cc\u067e\u062a \u0627\u0633\u062a\u0641\u0627\u062f\u0647 \u06a9\u0646\u06cc\u062f:</p> <ul> <li><code>scripts/profile_conversion.py</code></li> </ul>"},{"location":"fa/changelog/","title":"\u062a\u063a\u06cc\u06cc\u0631\u0627\u062a","text":"<p>\u0641\u0647\u0631\u0633\u062a \u06a9\u0627\u0645\u0644 \u062a\u063a\u06cc\u06cc\u0631\u0627\u062a \u062f\u0631 \u0645\u062e\u0632\u0646:</p> <p>https://github.com/ghodsizadeh/jalali-pandas/blob/main/CHANGELOG.md</p>"},{"location":"fa/contributing/","title":"\u0645\u0634\u0627\u0631\u06a9\u062a","text":"<p>\u0627\u0632 \u0645\u0634\u0627\u0631\u06a9\u062a \u0634\u0645\u0627 \u062f\u0631 jalali_pandas \u062e\u0648\u0634\u062d\u0627\u0644 \u0645\u06cc\u200c\u0634\u0648\u06cc\u0645.</p>"},{"location":"fa/contributing/#_2","title":"\u0631\u0627\u0647\u200c\u0627\u0646\u062f\u0627\u0632\u06cc \u062a\u0648\u0633\u0639\u0647","text":"<pre><code>uv sync --extra dev\n</code></pre>"},{"location":"fa/contributing/#_3","title":"\u062a\u0633\u062a\u200c\u0647\u0627","text":"<pre><code>uv run pytest\nuv run pytest --cov=jalali_pandas --cov-report=xml\n</code></pre>"},{"location":"fa/contributing/#_4","title":"\u0644\u06cc\u0646\u062a \u0648 \u0641\u0631\u0645\u062a","text":"<pre><code>uv run ruff check jalali_pandas tests\nuv run ruff format --check jalali_pandas tests\n</code></pre>"},{"location":"fa/contributing/#_5","title":"\u0628\u0631\u0631\u0633\u06cc \u0646\u0648\u0639\u200c\u0647\u0627","text":"<pre><code>uv run mypy jalali_pandas\nuv run pyright jalali_pandas\n</code></pre>"},{"location":"fa/contributing/#_6","title":"\u0633\u0627\u062e\u062a \u0645\u0633\u062a\u0646\u062f\u0627\u062a","text":"<pre><code>uv sync --extra docs\nuv run mkdocs build --strict\n</code></pre>"},{"location":"fa/deployment/","title":"\u0627\u0646\u062a\u0634\u0627\u0631","text":"<p>\u0645\u0633\u062a\u0646\u062f\u0627\u062a \u0628\u0627 MkDocs + Material \u0633\u0627\u062e\u062a\u0647 \u0645\u06cc\u200c\u0634\u0648\u062f \u0648 \u062f\u0631 GitHub Pages \u0645\u0646\u062a\u0634\u0631 \u0645\u06cc\u200c\u0634\u0648\u062f.</p> <p>\u0645\u0631\u0627\u062d\u0644 \u06a9\u0644\u06cc:</p> <pre><code>uv sync --extra docs\nuv run mkdocs build --strict\n</code></pre> <p>\u062f\u0631 \u06af\u0631\u062f\u0634\u200c\u06a9\u0627\u0631 \u0627\u0646\u062a\u0634\u0627\u0631 \u0628\u0627\u06cc\u062f \u0641\u0627\u06cc\u0644 <code>.nojekyll</code> \u0628\u0647 \u062e\u0631\u0648\u062c\u06cc \u0627\u0636\u0627\u0641\u0647 \u0634\u0648\u062f.</p>"},{"location":"fa/installation/","title":"\u0646\u0635\u0628","text":""},{"location":"fa/installation/#_2","title":"\u067e\u06cc\u0634\u200c\u0646\u06cc\u0627\u0632\u0647\u0627","text":"<ul> <li>\u067e\u0627\u06cc\u062a\u0648\u0646 3.9+</li> <li>pandas &gt;= 2.0</li> <li>numpy &gt;= 1.23</li> <li>jdatetime &gt;= 4.0</li> </ul>"},{"location":"fa/installation/#pip","title":"\u0646\u0635\u0628 \u0628\u0627 pip","text":"<pre><code>pip install -U jalali-pandas\n</code></pre>"},{"location":"fa/installation/#uv","title":"\u0646\u0635\u0628 \u0628\u0627 uv","text":"<pre><code>uv pip install jalali-pandas\n</code></pre>"},{"location":"fa/installation/#_3","title":"\u0627\u0641\u0632\u0648\u0646\u0647\u200c\u0647\u0627\u06cc \u0627\u062e\u062a\u06cc\u0627\u0631\u06cc (\u0628\u0631\u0627\u06cc \u0645\u0634\u0627\u0631\u06a9\u062a)","text":"<pre><code>uv sync --extra dev\nuv sync --extra docs\n</code></pre>"},{"location":"fa/installation/#_4","title":"\u062a\u0623\u06cc\u06cc\u062f \u0646\u0635\u0628","text":"<pre><code>import jalali_pandas as jp\nimport pandas as pd\n\nprint(f\"\u0646\u0633\u062e\u0647 jalali-pandas: {jp.__version__}\")\nts = jp.JalaliTimestamp(1402, 6, 15)\ngregorian = pd.Timestamp(\"2023-09-06\")\njalali = jp.JalaliTimestamp.from_gregorian(gregorian)\nprint(f\"\u062a\u0627\u06cc\u0645\u200c\u0627\u0633\u062a\u0645\u067e \u0627\u06cc\u062c\u0627\u062f \u0634\u062f\u0647: {ts}\")\nprint(f\"\u062a\u0628\u062f\u06cc\u0644 \u0634\u062f\u0647: {gregorian} -&gt; {jalali}\")\n</code></pre> <p>\u062e\u0631\u0648\u062c\u06cc \u0645\u0648\u0631\u062f \u0627\u0646\u062a\u0638\u0627\u0631:</p> <pre><code>\u0646\u0633\u062e\u0647 jalali-pandas: 1.0.0a1\n\u062a\u0627\u06cc\u0645\u200c\u0627\u0633\u062a\u0645\u067e \u0627\u06cc\u062c\u0627\u062f \u0634\u062f\u0647: 1402-06-15 00:00:00\n\u062a\u0628\u062f\u06cc\u0644 \u0634\u062f\u0647: 2023-09-06 00:00:00 -&gt; 1402-06-15 00:00:00\n</code></pre>"},{"location":"fa/quickstart/","title":"\u0634\u0631\u0648\u0639 \u0633\u0631\u06cc\u0639","text":"<p>\u0627\u06cc\u0646 \u0628\u062e\u0634 \u062f\u0631 \u0686\u0646\u062f \u062f\u0642\u06cc\u0642\u0647 \u0634\u0645\u0627 \u0631\u0627 \u0628\u0627 \u0628\u062e\u0634\u200c\u0647\u0627\u06cc \u0627\u0635\u0644\u06cc \u0622\u0634\u0646\u0627 \u0645\u06cc\u200c\u06a9\u0646\u062f.</p>"},{"location":"fa/quickstart/#1","title":"1) \u0627\u06cc\u0645\u067e\u0648\u0631\u062a \u0648 \u062b\u0628\u062a \u0627\u06a9\u0633\u0633\u0648\u0631\u0647\u0627","text":"<pre><code>import pandas as pd\nimport jalali_pandas as jp\n</code></pre>"},{"location":"fa/quickstart/#2-jalalitimestamp","title":"2) \u0633\u0627\u062e\u062a JalaliTimestamp","text":"<pre><code>from jalali_pandas import JalaliTimestamp\n\nts = JalaliTimestamp(1402, 6, 15)\n</code></pre>"},{"location":"fa/quickstart/#3","title":"3) \u062a\u0628\u062f\u06cc\u0644 \u0645\u06cc\u0644\u0627\u062f\u06cc \u2192 \u062c\u0644\u0627\u0644\u06cc","text":"<pre><code>gregorian = pd.Timestamp(\"2023-09-06\")\njalali = jp.to_jalali_datetime(gregorian)\n</code></pre>"},{"location":"fa/quickstart/#4","title":"4) \u0633\u0627\u062e\u062a \u0628\u0627\u0632\u0647 \u062a\u0627\u0631\u06cc\u062e \u062c\u0644\u0627\u0644\u06cc","text":"<pre><code>idx = jp.jalali_date_range(\"1402-01-01\", periods=5, freq=\"D\")\n</code></pre>"},{"location":"fa/quickstart/#5","title":"5) \u0627\u0633\u062a\u0641\u0627\u062f\u0647 \u0627\u0632 \u0627\u06a9\u0633\u0633\u0648\u0631\u0647\u0627","text":"<pre><code>s = pd.Series(pd.date_range(\"2023-03-21\", periods=3, freq=\"D\"))\njalali_series = s.jalali.to_jalali()\nmonths = jalali_series.jalali.month\n</code></pre>"},{"location":"fa/quickstart/#6","title":"6) \u06af\u0631\u0648\u0647\u200c\u0628\u0646\u062f\u06cc \u0628\u0631 \u0627\u0633\u0627\u0633 \u0633\u0627\u0644 \u062c\u0644\u0627\u0644\u06cc","text":"<pre><code>df = pd.DataFrame({\"date\": s, \"value\": [1, 2, 3]})\ndf[\"jdate\"] = df[\"date\"].jalali.to_jalali()\nresult = df.jalali.groupby(\"year\").sum(numeric_only=True)\n</code></pre>"},{"location":"fa/api/","title":"\u0645\u0631\u062c\u0639 API","text":"<p>\u0645\u0631\u062c\u0639 \u06a9\u0627\u0645\u0644 API \u0628\u0647 \u0632\u0628\u0627\u0646 \u0627\u0646\u06af\u0644\u06cc\u0633\u06cc \u062f\u0631 \u0627\u06cc\u0646 \u0645\u0633\u06cc\u0631 \u0627\u0633\u062a:</p> <ul> <li>\u0646\u0645\u0627\u06cc \u06a9\u0644\u06cc API</li> </ul> <p>\u0628\u0631\u0627\u06cc \u0645\u0634\u0627\u0647\u062f\u0647 \u062c\u0632\u0626\u06cc\u0627\u062a \u06a9\u0644\u0627\u0633\u200c\u0647\u0627 \u0648 \u062a\u0648\u0627\u0628\u0639\u060c \u0627\u0632 \u0647\u0645\u0627\u0646 \u0635\u0641\u062d\u0627\u062a \u0627\u0633\u062a\u0641\u0627\u062f\u0647 \u06a9\u0646\u06cc\u062f.</p>"},{"location":"fa/api/accessors/","title":"\u0627\u06a9\u0633\u0633\u0648\u0631\u0647\u0627","text":"<p>\u0627\u06cc\u0646 \u0628\u062e\u0634 \u062f\u0631 \u0646\u0633\u062e\u0647 \u0627\u0646\u06af\u0644\u06cc\u0633\u06cc \u062a\u0648\u0644\u06cc\u062f \u0645\u06cc\u200c\u0634\u0648\u062f:</p> <ul> <li>\u0627\u06a9\u0633\u0633\u0648\u0631\u0647\u0627</li> </ul>"},{"location":"fa/api/api/","title":"API \u0639\u0645\u0648\u0645\u06cc","text":"<p>\u0627\u06cc\u0646 \u0628\u062e\u0634 \u062f\u0631 \u0646\u0633\u062e\u0647 \u0627\u0646\u06af\u0644\u06cc\u0633\u06cc \u062a\u0648\u0644\u06cc\u062f \u0645\u06cc\u200c\u0634\u0648\u062f:</p> <ul> <li>API \u0639\u0645\u0648\u0645\u06cc</li> </ul>"},{"location":"fa/api/core/","title":"\u0647\u0633\u062a\u0647","text":"<p>\u0627\u06cc\u0646 \u0628\u062e\u0634 \u062f\u0631 \u0646\u0633\u062e\u0647 \u0627\u0646\u06af\u0644\u06cc\u0633\u06cc \u062a\u0648\u0644\u06cc\u062f \u0645\u06cc\u200c\u0634\u0648\u062f:</p> <ul> <li>\u0647\u0633\u062a\u0647</li> </ul>"},{"location":"fa/api/offsets/","title":"\u0627\u0641\u0633\u062a\u200c\u0647\u0627","text":"<p>\u0627\u06cc\u0646 \u0628\u062e\u0634 \u062f\u0631 \u0646\u0633\u062e\u0647 \u0627\u0646\u06af\u0644\u06cc\u0633\u06cc \u062a\u0648\u0644\u06cc\u062f \u0645\u06cc\u200c\u0634\u0648\u062f:</p> <ul> <li>\u0627\u0641\u0633\u062a\u200c\u0647\u0627</li> </ul>"},{"location":"fa/examples/","title":"\u0645\u062b\u0627\u0644\u200c\u0647\u0627","text":"<p>\u0647\u0645\u0647 \u0645\u062b\u0627\u0644\u200c\u0647\u0627 \u062f\u0631 \u0645\u0633\u06cc\u0631 <code>examples/</code> \u0642\u0631\u0627\u0631 \u062f\u0627\u0631\u0646\u062f.</p> <ul> <li><code>examples/01_basic_usage.py</code> \u2014 \u0645\u0642\u062f\u0645\u0627\u062a JalaliTimestamp</li> <li><code>examples/02_series_operations.py</code> \u2014 \u06a9\u0627\u0631 \u0628\u0627 \u0627\u06a9\u0633\u0633\u0648\u0631 \u0633\u0631\u06cc</li> <li><code>examples/03_dataframe_operations.py</code> \u2014 \u06af\u0631\u0648\u0647\u200c\u0628\u0646\u062f\u06cc \u062f\u06cc\u062a\u0627\u0641\u0631\u06cc\u0645</li> <li><code>examples/04_offsets.py</code> \u2014 \u0627\u0641\u0633\u062a\u200c\u0647\u0627 \u0648 alias \u0647\u0627</li> <li><code>examples/05_index_and_date_range.py</code> \u2014 \u0627\u06cc\u0646\u062f\u06a9\u0633 \u0648 \u062a\u0628\u062f\u06cc\u0644</li> <li><code>examples/00_zero_to_hero.ipynb</code> \u2014 \u0646\u0648\u062a\u200c\u0628\u0648\u06a9 \u0622\u0645\u0648\u0632\u0634\u06cc</li> <li><code>examples/basic_usage.ipynb</code> \u2014 \u0646\u0648\u062a\u200c\u0628\u0648\u06a9 \u06a9\u0648\u062a\u0627\u0647</li> </ul>"},{"location":"fa/examples/basic-usage/","title":"\u0645\u062b\u0627\u0644: \u0627\u0633\u062a\u0641\u0627\u062f\u0647 \u067e\u0627\u06cc\u0647","text":"<p>\u0645\u0646\u0628\u0639: <code>examples/01_basic_usage.py</code></p> <pre><code>from jalali_pandas import JalaliTimestamp\nimport pandas as pd\n\nts = JalaliTimestamp(1402, 6, 15)\n\ngregorian = pd.Timestamp(\"2023-09-06\")\nts_from_greg = JalaliTimestamp.from_gregorian(gregorian)\n</code></pre> <pre><code>ts.normalize()\nts.replace(year=1403, month=1)\nts.strftime(\"%Y-%m-%d\")\n</code></pre>"},{"location":"fa/examples/dataframe-operations/","title":"\u0645\u062b\u0627\u0644: \u0639\u0645\u0644\u06cc\u0627\u062a \u062f\u06cc\u062a\u0627\u0641\u0631\u06cc\u0645","text":"<p>\u0645\u0646\u0628\u0639: <code>examples/03_dataframe_operations.py</code></p> <pre><code>import pandas as pd\nimport jalali_pandas\n\ndf = pd.DataFrame({\n    \"date\": pd.date_range(\"2019-01-01\", periods=6, freq=\"ME\"),\n    \"sales\": [100, 120, 90, 140, 160, 110],\n})\n\ndf[\"jdate\"] = df[\"date\"].jalali.to_jalali()\n\nyearly = df.jalali.groupby(\"year\").sum(numeric_only=True)\n</code></pre>"},{"location":"fa/examples/index-and-date-range/","title":"\u0645\u062b\u0627\u0644: \u0627\u06cc\u0646\u062f\u06a9\u0633 \u0648 \u0628\u0627\u0632\u0647 \u062a\u0627\u0631\u06cc\u062e","text":"<p>\u0645\u0646\u0628\u0639: <code>examples/05_index_and_date_range.py</code></p> <pre><code>import pandas as pd\nimport jalali_pandas as jp\n\nidx = jp.JalaliDatetimeIndex([\"1402-01-01\", \"1402-01-15\"])\n\nrng = jp.jalali_date_range(\"1402-01-01\", periods=3, freq=\"JME\")\n</code></pre> <pre><code>jalali = jp.to_jalali_datetime(pd.Timestamp(\"2023-09-06\"))\nback = jp.to_gregorian_datetime(jalali)\n</code></pre>"},{"location":"fa/examples/notebooks/","title":"\u0646\u0648\u062a\u200c\u0628\u0648\u06a9\u200c\u0647\u0627","text":"<p>\u0645\u0646\u0627\u0628\u0639 \u0646\u0648\u062a\u200c\u0628\u0648\u06a9:</p> <ul> <li><code>examples/00_zero_to_hero.ipynb</code></li> <li><code>examples/basic_usage.ipynb</code></li> </ul> <p>\u0628\u0627\u0632 \u06a9\u0631\u062f\u0646 \u062f\u0631 Colab:</p> <ul> <li>https://colab.research.google.com/github/ghodsizadeh/jalali-pandas/blob/main/examples/00_zero_to_hero.ipynb</li> <li>https://colab.research.google.com/github/ghodsizadeh/jalali-pandas/blob/main/examples/basic_usage.ipynb</li> </ul>"},{"location":"fa/examples/offsets/","title":"\u0645\u062b\u0627\u0644: \u0627\u0641\u0633\u062a\u200c\u0647\u0627","text":"<p>\u0645\u0646\u0628\u0639: <code>examples/04_offsets.py</code></p> <pre><code>from jalali_pandas import JalaliTimestamp\nfrom jalali_pandas.offsets import JalaliMonthEnd, JalaliWeek, FRIDAY\n\nts = JalaliTimestamp(1402, 6, 15)\n\nnext_month_end = ts + JalaliMonthEnd()\nnext_friday = ts + JalaliWeek(weekday=FRIDAY)\n</code></pre> <pre><code>from jalali_pandas.offsets import parse_jalali_frequency\n\nparse_jalali_frequency(\"JME\")\nparse_jalali_frequency(\"2JQE\")\n</code></pre>"},{"location":"fa/examples/series-operations/","title":"\u0645\u062b\u0627\u0644: \u0639\u0645\u0644\u06cc\u0627\u062a \u0633\u0631\u06cc","text":"<p>\u0645\u0646\u0628\u0639: <code>examples/02_series_operations.py</code></p> <pre><code>import pandas as pd\nimport jalali_pandas\n\ns = pd.Series(pd.date_range(\"2023-03-21\", periods=3, freq=\"D\"))\nj = s.jalali.to_jalali()\n\nj.jalali.year\nj.jalali.month\nj.jalali.day\n</code></pre> <pre><code>df = pd.DataFrame({\"date_str\": [\"1402/01/01\", \"1402/01/15\"]})\ndf[\"jdate\"] = df[\"date_str\"].jalali.parse_jalali(\"%Y/%m/%d\")\n</code></pre>"},{"location":"fa/user-guide/accessors/","title":"\u0627\u06a9\u0633\u0633\u0648\u0631\u0647\u0627","text":"<p>\u0628\u0627 <code>import jalali_pandas</code> \u0627\u06a9\u0633\u0633\u0648\u0631 <code>.jalali</code> \u0631\u0648\u06cc Series \u0648 DataFrame \u062b\u0628\u062a \u0645\u06cc\u200c\u0634\u0648\u062f.</p>"},{"location":"fa/user-guide/accessors/#series-jalaliseriesaccessor","title":"\u0627\u06a9\u0633\u0633\u0648\u0631 Series (<code>JalaliSeriesAccessor</code>)","text":"<p>\u0627\u06a9\u0633\u0633\u0648\u0631 Series \u0627\u0646\u062a\u0638\u0627\u0631 \u0645\u0642\u0627\u062f\u06cc\u0631 <code>jdatetime</code> \u06cc\u0627 \u0631\u0634\u062a\u0647\u200c\u0647\u0627\u06cc \u062c\u0644\u0627\u0644\u06cc \u0631\u0627 \u062f\u0627\u0631\u062f. \u0627\u06af\u0631 \u062a\u0627\u0631\u06cc\u062e\u200c\u0647\u0627\u06cc \u0645\u06cc\u0644\u0627\u062f\u06cc \u062f\u0627\u0631\u06cc\u062f \u0627\u0628\u062a\u062f\u0627 \u0628\u0627 <code>series.jalali.to_jalali()</code> \u062a\u0628\u062f\u06cc\u0644 \u06a9\u0646\u06cc\u062f.</p>"},{"location":"fa/user-guide/accessors/#_2","title":"\u062a\u0628\u062f\u06cc\u0644","text":"<ul> <li><code>to_jalali()</code></li> <li><code>to_gregorian()</code></li> <li><code>parse_jalali(format=\"%Y-%m-%d\")</code></li> </ul>"},{"location":"fa/user-guide/accessors/#_3","title":"\u0648\u06cc\u0698\u06af\u06cc\u200c\u0647\u0627","text":"<ul> <li><code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, <code>second</code>, <code>microsecond</code>, <code>nanosecond</code></li> <li><code>quarter</code>, <code>weekday</code>, <code>dayofweek</code>, <code>dayofyear</code></li> <li><code>week</code>, <code>weekofyear</code>, <code>weeknumber</code></li> <li><code>daysinmonth</code>, <code>days_in_month</code></li> </ul>"},{"location":"fa/user-guide/accessors/#_4","title":"\u0648\u06cc\u0698\u06af\u06cc\u200c\u0647\u0627\u06cc \u0628\u0648\u0644\u06cc","text":"<ul> <li><code>is_leap_year</code></li> <li><code>is_month_start</code>, <code>is_month_end</code></li> <li><code>is_quarter_start</code>, <code>is_quarter_end</code></li> <li><code>is_year_start</code>, <code>is_year_end</code></li> </ul>"},{"location":"fa/user-guide/accessors/#_5","title":"\u0642\u0627\u0644\u0628\u200c\u0628\u0646\u062f\u06cc \u0648 \u0631\u0646\u062f \u06a9\u0631\u062f\u0646","text":"<ul> <li><code>strftime(format)</code></li> <li><code>month_name(locale=\"fa\"|\"en\")</code>, <code>day_name(locale=\"fa\"|\"en\")</code></li> <li><code>normalize()</code>, <code>floor(freq)</code>, <code>ceil(freq)</code>, <code>round(freq)</code></li> </ul> <pre><code>import pandas as pd\nimport jalali_pandas  # registers accessor\n\nseries = pd.Series(pd.date_range(\"2023-03-21\", periods=3))\njseries = series.jalali.to_jalali()\n\n# \u067e\u06cc\u0634\u200c\u0641\u0631\u0636 \u0627\u0646\u06af\u0644\u06cc\u0633\u06cc \u0627\u0633\u062a\nprint(jseries.jalali.month_name())\n\n# \u0646\u0627\u0645 \u0641\u0627\u0631\u0633\u06cc\nprint(jseries.jalali.month_name(locale=\"fa\"))\n</code></pre>"},{"location":"fa/user-guide/accessors/#_6","title":"\u0645\u0646\u0637\u0642\u0647 \u0632\u0645\u0627\u0646\u06cc","text":"<p><code>tz_localize</code> \u0648 <code>tz_convert</code> \u062e\u0631\u0648\u062c\u06cc \u0631\u0627 \u0628\u0647 \u0635\u0648\u0631\u062a \u062a\u0627\u0631\u06cc\u062e\u200c\u0647\u0627\u06cc \u0645\u06cc\u0644\u0627\u062f\u06cc\u0650 \u0622\u06af\u0627\u0647 \u0627\u0632 \u0645\u0646\u0637\u0642\u0647 \u0632\u0645\u0627\u0646\u06cc \u0628\u0631\u0645\u06cc\u200c\u06af\u0631\u062f\u0627\u0646\u0646\u062f:</p> <ul> <li><code>tz_localize(tz, ambiguous=\"raise\", nonexistent=\"raise\")</code></li> <li><code>tz_convert(tz)</code></li> </ul>"},{"location":"fa/user-guide/accessors/#dataframe-jalalidataframeaccessor","title":"\u0627\u06a9\u0633\u0633\u0648\u0631 DataFrame (<code>JalaliDataFrameAccessor</code>)","text":"<p>\u0627\u06a9\u0633\u0633\u0648\u0631 \u062f\u06cc\u062a\u0627\u0641\u0631\u06cc\u0645 \u0646\u06cc\u0627\u0632 \u0628\u0647 \u062d\u062f\u0627\u0642\u0644 \u06cc\u06a9 \u0633\u062a\u0648\u0646 \u0627\u0632 \u0646\u0648\u0639 <code>jdatetime</code> \u062f\u0627\u0631\u062f. \u0622\u0646 \u0631\u0627 \u0628\u0627 <code>.jalali.to_jalali()</code> \u0628\u0633\u0627\u0632\u06cc\u062f \u0648 \u0627\u06af\u0631 \u0686\u0646\u062f \u0633\u062a\u0648\u0646 \u062f\u0627\u0631\u06cc\u062f \u0627\u0632 <code>set_date_column</code> \u0627\u0633\u062a\u0641\u0627\u062f\u0647 \u06a9\u0646\u06cc\u062f.</p>"},{"location":"fa/user-guide/accessors/#_7","title":"\u0645\u062a\u062f\u0647\u0627\u06cc \u0627\u0635\u0644\u06cc","text":"<ul> <li><code>set_date_column(column)</code></li> <li><code>groupby(grouper)</code></li> <li><code>resample(resample_type)</code> \u0628\u0627 \u0645\u0642\u0627\u062f\u06cc\u0631 <code>month|quarter|year|week</code></li> <li><code>convert_columns(columns, to_jalali=True, format=\"%Y-%m-%d\")</code></li> <li><code>to_period(freq=\"M\")</code></li> <li><code>filter_by_year</code>, <code>filter_by_month</code>, <code>filter_by_quarter</code>, <code>filter_by_date_range</code></li> </ul> <p>\u06a9\u0644\u06cc\u062f\u0647\u0627\u06cc groupby:</p> <p><code>year</code>, <code>month</code>, <code>day</code>, <code>week</code>, <code>dayofweek</code>, <code>dayofmonth</code>, <code>quarter</code>, <code>dayofyear</code>, <code>ym</code>, <code>yq</code>, <code>ymd</code>, <code>md</code></p> <pre><code>import pandas as pd\nimport jalali_pandas\n\ndf = pd.DataFrame({\"date\": pd.date_range(\"2023-03-21\", periods=10)})\ndf[\"jdate\"] = df[\"date\"].jalali.to_jalali()\n\nmonthly = df.jalali.groupby(\"month\").size()\nconverted = df.jalali.convert_columns(\"date\", to_jalali=True)\n</code></pre>"},{"location":"fa/user-guide/accessors/#_8","title":"\u0627\u06a9\u0633\u0633\u0648\u0631\u0647\u0627\u06cc \u0642\u062f\u06cc\u0645\u06cc","text":"<ul> <li><code>jalali_pandas.df_handler.JalaliDataframeAccessor</code></li> <li><code>jalali_pandas.serie_handler.JalaliSerieAccessor</code></li> </ul> <p>\u0628\u0631\u0627\u06cc \u0627\u0645\u06a9\u0627\u0646\u0627\u062a \u06a9\u0627\u0645\u0644 \u0627\u0632 \u0627\u06a9\u0633\u0633\u0648\u0631\u0647\u0627\u06cc \u062c\u062f\u06cc\u062f \u0627\u0633\u062a\u0641\u0627\u062f\u0647 \u06a9\u0646\u06cc\u062f.</p>"},{"location":"fa/user-guide/conversion/","title":"\u062a\u0628\u062f\u06cc\u0644\u200c\u0647\u0627","text":""},{"location":"fa/user-guide/conversion/#_2","title":"\u062a\u0648\u0627\u0628\u0639 \u0639\u0645\u0648\u0645\u06cc","text":"<ul> <li><code>to_jalali_datetime(...)</code></li> <li><code>to_gregorian_datetime(...)</code></li> </ul> <pre><code>import pandas as pd\nimport jalali_pandas as jp\n\njp.to_jalali_datetime(\"1402-06-15\")\n\njp.to_jalali_datetime(pd.Timestamp(\"2023-09-06\"))\n\njp.to_jalali_datetime([\"1402-01-01\", \"1402-01-02\"])\n\njidx = jp.JalaliDatetimeIndex([\"1402-01-01\", \"1402-01-02\"])\njp.to_gregorian_datetime(jidx)\n</code></pre>"},{"location":"fa/user-guide/conversion/#_3","title":"\u0645\u062f\u06cc\u0631\u06cc\u062a \u062e\u0637\u0627","text":"<p><code>to_jalali_datetime(..., errors=...)</code> \u0627\u0632 \u0627\u06cc\u0646 \u062d\u0627\u0644\u062a\u200c\u0647\u0627 \u067e\u0634\u062a\u06cc\u0628\u0627\u0646\u06cc \u0645\u06cc\u200c\u06a9\u0646\u062f:</p> <ul> <li><code>\"raise\"</code> (\u067e\u06cc\u0634\u200c\u0641\u0631\u0636)</li> <li><code>\"coerce\"</code> \u2192 \u0645\u0642\u062f\u0627\u0631 \u0646\u0627\u0645\u0639\u062a\u0628\u0631 \u0628\u0647 <code>pd.NaT</code> \u062a\u0628\u062f\u06cc\u0644 \u0645\u06cc\u200c\u0634\u0648\u062f</li> <li><code>\"ignore\"</code> \u2192 \u0641\u0642\u0637 \u0628\u0631\u0627\u06cc Series\u060c \u0648\u0631\u0648\u062f\u06cc \u0628\u062f\u0648\u0646 \u062a\u063a\u06cc\u06cc\u0631 \u0628\u0631\u06af\u0631\u062f\u0627\u0646\u062f\u0647 \u0645\u06cc\u200c\u0634\u0648\u062f</li> </ul>"},{"location":"fa/user-guide/conversion/#_4","title":"\u0641\u0631\u0645\u062a\u200c\u0647\u0627\u06cc \u067e\u06cc\u0634\u200c\u0641\u0631\u0636 \u0631\u0634\u062a\u0647\u200c\u0627\u06cc","text":"<p>\u062f\u0631 \u0635\u0648\u0631\u062a <code>format=None</code> \u0627\u06cc\u0646 \u0641\u0631\u0645\u062a\u200c\u0647\u0627 \u0628\u0647 \u062a\u0631\u062a\u06cc\u0628 \u062a\u0633\u062a \u0645\u06cc\u200c\u0634\u0648\u0646\u062f:</p> <ul> <li><code>%Y-%m-%d %H:%M:%S</code></li> <li><code>%Y-%m-%d</code></li> <li><code>%Y/%m/%d %H:%M:%S</code></li> <li><code>%Y/%m/%d</code></li> <li><code>%Y%m%d</code></li> </ul>"},{"location":"fa/user-guide/conversion/#_5","title":"\u062a\u0648\u0627\u0628\u0639 \u0628\u0631\u062f\u0627\u0631\u06cc \u062f\u0627\u062e\u0644\u06cc","text":"<ul> <li><code>gregorian_to_jalali_vectorized</code></li> <li><code>jalali_to_gregorian_vectorized</code></li> <li><code>datetime64_to_jalali</code></li> <li><code>jalali_to_datetime64</code></li> </ul>"},{"location":"fa/user-guide/core-types/","title":"\u0627\u0646\u0648\u0627\u0639 \u0627\u0635\u0644\u06cc","text":""},{"location":"fa/user-guide/core-types/#jalalitimestamp","title":"JalaliTimestamp","text":"<p><code>JalaliTimestamp</code> \u0646\u0648\u0639 \u0627\u0633\u06a9\u0627\u0644\u0631 \u0628\u0631\u0627\u06cc \u062a\u0627\u0631\u06cc\u062e\u200c\u0647\u0627\u06cc \u062c\u0644\u0627\u0644\u06cc \u0627\u0633\u062a.</p> <pre><code>from jalali_pandas import JalaliTimestamp\n\nts = JalaliTimestamp(1402, 6, 15, 10, 30)\nprint(ts.year, ts.month, ts.day)\nprint(ts.to_gregorian())\n</code></pre> <p>\u0645\u062a\u062f\u0647\u0627 \u0648 \u0648\u06cc\u0698\u06af\u06cc\u200c\u0647\u0627\u06cc \u0645\u0647\u0645:</p> <ul> <li><code>JalaliTimestamp.from_gregorian(pd.Timestamp)</code></li> <li><code>JalaliTimestamp.strptime(string, format)</code></li> <li><code>to_gregorian()</code></li> <li><code>normalize()</code>, <code>replace(...)</code></li> <li><code>tz_localize(...)</code>, <code>tz_convert(...)</code></li> </ul>"},{"location":"fa/user-guide/core-types/#jalalidatetimedtype","title":"JalaliDatetimeDtype","text":"<p>\u0646\u0648\u0639 \u062f\u0627\u062f\u0647 \u0627\u0641\u0632\u0648\u0646\u0647\u200c\u0627\u06cc pandas \u0628\u0631\u0627\u06cc \u062a\u0627\u0631\u06cc\u062e \u062c\u0644\u0627\u0644\u06cc.</p> <pre><code>from jalali_pandas.core.dtypes import JalaliDatetimeDtype\n\ndtype = JalaliDatetimeDtype()\n</code></pre>"},{"location":"fa/user-guide/core-types/#jalalidatetimearray","title":"JalaliDatetimeArray","text":"<p>\u0622\u0631\u0627\u06cc\u0647 \u0627\u0641\u0632\u0648\u0646\u0647\u200c\u0627\u06cc \u0628\u0631\u0627\u06cc \u0646\u06af\u0647\u200c\u062f\u0627\u0631\u06cc \u0645\u0642\u0627\u062f\u06cc\u0631 \u062c\u0644\u0627\u0644\u06cc.</p> <pre><code>from jalali_pandas.core.arrays import JalaliDatetimeArray\nfrom jalali_pandas import JalaliTimestamp\n\narr = JalaliDatetimeArray._from_sequence(\n    [JalaliTimestamp(1402, 1, 1), JalaliTimestamp(1402, 1, 2)]\n)\n</code></pre>"},{"location":"fa/user-guide/core-types/#_2","title":"\u0627\u0628\u0632\u0627\u0631\u0647\u0627\u06cc \u062a\u0642\u0648\u06cc\u0645","text":"<pre><code>from jalali_pandas.core.calendar import is_leap_year, days_in_month, days_in_year\n\nis_leap_year(1403)\ndays_in_month(1402, 12)\ndays_in_year(1402)\n</code></pre>"},{"location":"fa/user-guide/frequency-offsets/","title":"\u0627\u0641\u0633\u062a\u200c\u0647\u0627\u06cc \u0641\u0631\u06a9\u0627\u0646\u0633\u06cc","text":"<p>\u0627\u0641\u0633\u062a\u200c\u0647\u0627\u06cc \u062c\u0644\u0627\u0644\u06cc \u0634\u0628\u06cc\u0647 DateOffset\u200c\u0647\u0627\u06cc pandas \u0647\u0633\u062a\u0646\u062f \u0627\u0645\u0627 \u0642\u0648\u0627\u0639\u062f \u062a\u0642\u0648\u06cc\u0645 \u062c\u0644\u0627\u0644\u06cc \u0631\u0627 \u0631\u0639\u0627\u06cc\u062a \u0645\u06cc\u200c\u06a9\u0646\u0646\u062f (\u0637\u0648\u0644 \u0645\u0627\u0647\u200c\u0647\u0627\u060c \u0633\u0627\u0644 \u06a9\u0628\u06cc\u0633\u0647\u060c \u0641\u0635\u0644\u200c\u0647\u0627 \u0648 \u0645\u0631\u0632 \u0647\u0641\u062a\u0647).</p>"},{"location":"fa/user-guide/frequency-offsets/#_2","title":"\u06a9\u0644\u0627\u0633\u200c\u0647\u0627","text":"<ul> <li><code>JalaliMonthBegin</code>, <code>JalaliMonthEnd</code></li> <li><code>JalaliQuarterBegin</code>, <code>JalaliQuarterEnd</code></li> <li><code>JalaliYearBegin</code>, <code>JalaliYearEnd</code></li> <li><code>JalaliWeek</code> (\u0627\u0641\u0633\u062a \u0647\u0641\u062a\u06af\u06cc \u0628\u0627 \u0627\u0645\u06a9\u0627\u0646 \u062a\u0639\u06cc\u06cc\u0646 \u0631\u0648\u0632 \u0647\u0641\u062a\u0647)</li> </ul> <pre><code>from jalali_pandas import JalaliTimestamp\nfrom jalali_pandas.offsets import JalaliMonthEnd, JalaliWeek, FRIDAY\n\nts = JalaliTimestamp(1402, 6, 15)\nprint(ts + JalaliMonthEnd())\nprint(ts + JalaliWeek(weekday=FRIDAY))\n</code></pre>"},{"location":"fa/user-guide/frequency-offsets/#_3","title":"\u0646\u0627\u0645\u200c\u0647\u0627\u06cc \u0645\u0633\u062a\u0639\u0627\u0631 \u0641\u0631\u06a9\u0627\u0646\u0633","text":"<ul> <li>JME / JMS</li> <li>JQE / JQS</li> <li>JYE / JYS</li> <li>JW (\u0647\u0641\u062a\u06af\u06cc\u060c \u067e\u06cc\u0634\u200c\u0641\u0631\u0636 \u0634\u0646\u0628\u0647)</li> </ul> <pre><code>from jalali_pandas.offsets import parse_jalali_frequency, list_jalali_aliases\n\nparse_jalali_frequency(\"JME\")\nparse_jalali_frequency(\"JW\")  # \u067e\u06cc\u0634\u200c\u0641\u0631\u0636 \u0634\u0646\u0628\u0647\nlist_jalali_aliases()\n</code></pre> <p>\u0628\u0631\u0627\u06cc \u062a\u0639\u06cc\u06cc\u0646 \u0631\u0648\u0632 \u0647\u0641\u062a\u0647 \u062e\u0627\u0635 \u0627\u0632 <code>JalaliWeek(weekday=...)</code> \u0627\u0633\u062a\u0641\u0627\u062f\u0647 \u06a9\u0646\u06cc\u062f. \u0628\u0627 <code>register_jalali_alias</code> \u0645\u06cc\u200c\u062a\u0648\u0627\u0646\u06cc\u062f \u0646\u0627\u0645 \u0645\u0633\u062a\u0639\u0627\u0631 \u062c\u062f\u06cc\u062f \u062b\u0628\u062a \u06a9\u0646\u06cc\u062f.</p>"},{"location":"fa/user-guide/index-range/","title":"\u0627\u06cc\u0646\u062f\u06a9\u0633 \u0648 \u0628\u0627\u0632\u0647 \u062a\u0627\u0631\u06cc\u062e","text":""},{"location":"fa/user-guide/index-range/#jalalidatetimeindex","title":"JalaliDatetimeIndex","text":"<p><code>JalaliDatetimeIndex</code> \u0627\u06cc\u0646\u062f\u06a9\u0633 \u0628\u0648\u0645\u06cc \u062c\u0644\u0627\u0644\u06cc \u0628\u0631\u0627\u06cc Series \u0648 DataFrame \u0627\u0633\u062a.</p> <pre><code>import jalali_pandas as jp\n\nidx = jp.JalaliDatetimeIndex([\"1402-01-01\", \"1402-01-02\"], name=\"dates\")\ngregorian = idx.to_gregorian()\n</code></pre>"},{"location":"fa/user-guide/index-range/#_2","title":"\u0639\u0645\u0644\u06cc\u0627\u062a \u0645\u0647\u0645","text":"<ul> <li>\u0627\u06cc\u0646\u062f\u06a9\u0633 \u0628\u062e\u0634\u06cc \u0628\u0627 <code>get_loc(\"1402\")</code> \u06cc\u0627 <code>get_loc(\"1402-01\")</code></li> <li>\u0645\u062c\u0645\u0648\u0639\u0647\u200c\u0647\u0627: <code>union</code>, <code>intersection</code>, <code>difference</code></li> <li>\u0634\u06cc\u0641\u062a \u0628\u0627 <code>shift(periods=..., freq=...)</code></li> <li>\u0647\u0645\u200c\u0631\u0627\u0633\u062a\u0627 \u06a9\u0631\u062f\u0646 \u0628\u0627 <code>snap(freq=\"s\")</code></li> </ul> <pre><code>idx = jp.jalali_date_range(\"1402-01-01\", periods=40)\nmask = idx.get_loc(\"1402-02\")  # \u0645\u0627\u0633\u06a9 \u0628\u0648\u0644\u06cc \u0628\u0631\u0627\u06cc \u06cc\u06a9 \u0645\u0627\u0647\nsubset = idx[mask]\n</code></pre> <pre><code>shifted = idx.shift(periods=1, freq=\"JME\")\ndaily_shift = idx.shift(periods=1, freq=\"1D\")\n</code></pre>"},{"location":"fa/user-guide/index-range/#jalali_date_range","title":"jalali_date_range","text":"<pre><code>import jalali_pandas as jp\n\njp.jalali_date_range(\"1402-01-01\", periods=5, freq=\"D\")\njp.jalali_date_range(\"1402-01-01\", \"1402-01-10\", freq=\"D\")\njp.jalali_date_range(\"1402-01-01\", periods=3, freq=\"JME\")\n</code></pre>"},{"location":"fa/user-guide/index-range/#_3","title":"\u0646\u06a9\u0627\u062a","text":"<ul> <li>\u062d\u062f\u0627\u0642\u0644 \u062f\u0648 \u0645\u0648\u0631\u062f \u0627\u0632 <code>start</code>, <code>end</code>, <code>periods</code> \u0628\u0627\u06cc\u062f \u0645\u0634\u062e\u0635 \u0634\u0648\u062f.</li> <li>\u0627\u06af\u0631 \u0647\u0631 \u0633\u0647 \u0645\u0648\u0631\u062f \u062f\u0627\u062f\u0647 \u0634\u0648\u062f\u060c <code>freq</code> \u0627\u0644\u0632\u0627\u0645\u06cc \u0627\u0633\u062a.</li> <li><code>freq</code> \u0645\u06cc\u200c\u062a\u0648\u0627\u0646\u062f \u0627\u0641\u0633\u062a\u200c\u0647\u0627\u06cc \u062c\u0644\u0627\u0644\u06cc (JME/JMS/JQE/JQS/JYE/JYS/JW) \u06cc\u0627 \u0641\u0631\u06a9\u0627\u0646\u0633\u200c\u0647\u0627\u06cc   \u0631\u0627\u06cc\u062c pandas (D/H/MIN/S/W) \u0648 \u0636\u0631\u06cc\u0628 \u0622\u0646\u200c\u0647\u0627 \u0628\u0627\u0634\u062f (\u0645\u062b\u0644\u0627\u064b <code>2D</code>, <code>3MIN</code>).</li> <li><code>inclusive</code> \u0628\u0631\u0627\u06cc \u06a9\u0646\u062a\u0631\u0644 \u0645\u0631\u0632\u0647\u0627: <code>both</code>, <code>left</code>, <code>right</code>, <code>neither</code>.</li> </ul>"},{"location":"fa/user-guide/index-range/#_4","title":"\u0646\u0645\u0648\u0646\u0647\u200c\u0647\u0627\u06cc \u0641\u0631\u06a9\u0627\u0646\u0633 \u062c\u0644\u0627\u0644\u06cc","text":"<pre><code>jp.jalali_date_range(\"1402-01-01\", periods=6, freq=\"JME\")\njp.jalali_date_range(\"1402-01-01\", periods=4, freq=\"JQE\")\njp.jalali_date_range(\"1402-01-01\", periods=5, freq=\"JW\")\n</code></pre>"},{"location":"fa/user-guide/index-range/#_5","title":"\u0645\u0646\u0637\u0642\u0647 \u0632\u0645\u0627\u0646\u06cc","text":"<p>\u062f\u0631 <code>jalali_date_range(..., tz=...)</code> \u0645\u0646\u0637\u0642\u0647 \u0632\u0645\u0627\u0646\u06cc \u062f\u0631 dtype \u0630\u062e\u06cc\u0631\u0647 \u0645\u06cc\u200c\u0634\u0648\u062f.</p>"},{"location":"fa/user-guide/limitations/","title":"\u0645\u062d\u062f\u0648\u062f\u06cc\u062a\u200c\u0647\u0627","text":"<p>\u0645\u062d\u062f\u0648\u062f\u06cc\u062a\u200c\u0647\u0627\u06cc \u0641\u0639\u0644\u06cc \u0628\u0631 \u0627\u0633\u0627\u0633 \u067e\u06cc\u0627\u062f\u0647\u200c\u0633\u0627\u0632\u06cc:</p> <ul> <li><code>JalaliDataFrameAccessor</code> \u0646\u06cc\u0627\u0632 \u0628\u0647 \u062d\u062f\u0627\u0642\u0644 \u06cc\u06a9 \u0633\u062a\u0648\u0646 <code>jdatetime</code> \u062f\u0627\u0631\u062f.</li> <li><code>JalaliResampler</code> \u0641\u0642\u0637 \u0628\u0627 <code>pd.DatetimeIndex</code> \u06a9\u0627\u0631 \u0645\u06cc\u200c\u06a9\u0646\u062f.</li> <li><code>jalali_date_range</code> \u0628\u0627\u06cc\u062f \u062d\u062f\u0627\u0642\u0644 \u062f\u0648 \u0645\u0648\u0631\u062f \u0627\u0632 <code>start</code>, <code>end</code>, <code>periods</code> \u0631\u0627 \u062f\u0627\u0634\u062a\u0647   \u0628\u0627\u0634\u062f\u061b \u0627\u06af\u0631 \u0647\u0631 \u0633\u0647 \u0645\u0642\u062f\u0627\u0631 \u062f\u0627\u062f\u0647 \u0634\u0648\u062f\u060c <code>freq</code> \u0627\u062c\u0628\u0627\u0631\u06cc \u0627\u0633\u062a.</li> <li><code>to_jalali_datetime</code> \u0641\u0642\u0637 \u0686\u0646\u062f \u0641\u0631\u0645\u062a \u0645\u0634\u062e\u0635 \u0631\u0627 \u0628\u062f\u0648\u0646 <code>format</code> \u067e\u0634\u062a\u06cc\u0628\u0627\u0646\u06cc \u0645\u06cc\u200c\u06a9\u0646\u062f.</li> <li><code>JalaliDatetimeArray</code> \u0627\u0632 \u0622\u0631\u0627\u06cc\u0647 object \u0627\u0633\u062a\u0641\u0627\u062f\u0647 \u0645\u06cc\u200c\u06a9\u0646\u062f \u0648 \u0645\u0645\u06a9\u0646 \u0627\u0633\u062a \u06a9\u0646\u062f\u062a\u0631 \u0628\u0627\u0634\u062f.</li> </ul> <p>\u062f\u0631 \u0635\u0648\u0631\u062a \u0645\u0634\u0627\u0647\u062f\u0647 \u0645\u0634\u06a9\u0644\u060c \u06cc\u06a9 issue \u0628\u0627 \u0645\u062b\u0627\u0644 \u062d\u062f\u0627\u0642\u0644\u06cc \u062b\u0628\u062a \u06a9\u0646\u06cc\u062f.</p>"},{"location":"fa/user-guide/nat-handling/","title":"NaT","text":"<p><code>JalaliNaT</code> \u0645\u0639\u0627\u062f\u0644 \u062c\u0644\u0627\u0644\u06cc \u0628\u0631\u0627\u06cc <code>NaT</code> \u062f\u0631 pandas \u0627\u0633\u062a. \u0628\u0631\u0627\u06cc \u0628\u0631\u0631\u0633\u06cc \u0627\u0632 <code>isna_jalali</code> \u0627\u0633\u062a\u0641\u0627\u062f\u0647 \u06a9\u0646\u06cc\u062f.</p> <pre><code>import pandas as pd\nfrom jalali_pandas.core.timestamp import JalaliNaT, isna_jalali\n\nisna_jalali(JalaliNaT)\nisna_jalali(pd.NaT)\n</code></pre> <p>\u0646\u06a9\u0627\u062a:</p> <ul> <li>\u0645\u0642\u0627\u06cc\u0633\u0647 \u0628\u0627 <code>JalaliNaT</code> \u0645\u0634\u0627\u0628\u0647 \u0631\u0641\u062a\u0627\u0631 <code>NaT</code> \u0627\u0633\u062a.</li> <li><code>JalaliNaT.to_gregorian()</code> \u0645\u0642\u062f\u0627\u0631 <code>pd.NaT</code> \u0628\u0631\u0645\u06cc\u200c\u06af\u0631\u062f\u0627\u0646\u062f.</li> </ul>"},{"location":"fa/user-guide/time-series/","title":"\u0639\u0645\u0644\u06cc\u0627\u062a \u0633\u0631\u06cc \u0632\u0645\u0627\u0646\u06cc","text":""},{"location":"fa/user-guide/time-series/#_2","title":"\u0645\u0631\u0648\u0631 \u06a9\u0644\u06cc","text":"<p>\u062f\u0648 \u0645\u0633\u06cc\u0631 \u0627\u0635\u0644\u06cc \u0648\u062c\u0648\u062f \u062f\u0627\u0631\u062f:</p> <ol> <li>\u062a\u0627\u0631\u06cc\u062e\u200c\u0647\u0627\u06cc \u0645\u06cc\u0644\u0627\u062f\u06cc/\u0627\u06cc\u0646\u062f\u06a9\u0633 \u0645\u06cc\u0644\u0627\u062f\u06cc \u2192 \u0627\u0632 <code>JalaliGrouper</code>\u060c    <code>jalali_groupby</code> \u06cc\u0627 <code>resample_jalali</code> \u0627\u0633\u062a\u0641\u0627\u062f\u0647 \u06a9\u0646\u06cc\u062f.</li> <li>\u0633\u062a\u0648\u0646\u200c\u0647\u0627\u06cc <code>jdatetime</code> \u2192 \u0627\u0632 \u0627\u06a9\u0633\u0633\u0648\u0631 \u062f\u06cc\u062a\u0627\u0641\u0631\u06cc\u0645    (<code>df.jalali.groupby(...)</code> \u0648 <code>df.jalali.resample(...)</code>) \u0627\u0633\u062a\u0641\u0627\u062f\u0647 \u06a9\u0646\u06cc\u062f.</li> </ol> <p><code>JalaliGrouper</code> \u0648 <code>resample_jalali</code> \u062a\u0627\u0631\u06cc\u062e\u200c\u0647\u0627\u06cc \u0645\u06cc\u0644\u0627\u062f\u06cc \u0631\u0627 \u0627\u0646\u062a\u0638\u0627\u0631 \u062f\u0627\u0631\u0646\u062f. \u0627\u06af\u0631 \u0645\u0642\u0627\u062f\u06cc\u0631 <code>jdatetime</code> \u062f\u0627\u0631\u06cc\u062f\u060c \u0622\u0646\u200c\u0647\u0627 \u0631\u0627 \u0628\u0647 \u0645\u06cc\u0644\u0627\u062f\u06cc \u062a\u0628\u062f\u06cc\u0644 \u06a9\u0646\u06cc\u062f \u06cc\u0627 \u0627\u0632 \u0627\u06a9\u0633\u0633\u0648\u0631 \u062f\u06cc\u062a\u0627\u0641\u0631\u06cc\u0645 \u0627\u0633\u062a\u0641\u0627\u062f\u0647 \u06a9\u0646\u06cc\u062f.</p>"},{"location":"fa/user-guide/time-series/#jalaligrouper","title":"JalaliGrouper","text":"<p><code>JalaliGrouper</code> \u06af\u0631\u0648\u0647\u200c\u0628\u0646\u062f\u06cc \u0631\u0627 \u0628\u0631 \u0627\u0633\u0627\u0633 \u0645\u0631\u0632\u0647\u0627\u06cc \u062c\u0644\u0627\u0644\u06cc \u0627\u0646\u062c\u0627\u0645 \u0645\u06cc\u200c\u062f\u0647\u062f \u0648 \u0628\u0631\u0686\u0633\u0628\u200c\u0647\u0627 \u0628\u0647 \u0635\u0648\u0631\u062a <code>pd.Timestamp</code> (\u0645\u06cc\u0644\u0627\u062f\u06cc) \u0647\u0633\u062a\u0646\u062f.</p> <pre><code>import pandas as pd\nfrom jalali_pandas.api import JalaliGrouper\n\ndf = pd.DataFrame({\n    \"date\": pd.date_range(\"2023-03-21\", periods=10, freq=\"D\"),\n    \"value\": range(10),\n})\n\ngrouper = JalaliGrouper(key=\"date\", freq=\"JME\")\nresult = df.groupby(grouper.get_grouper(df)).sum()\n</code></pre>"},{"location":"fa/user-guide/time-series/#jalali_groupby","title":"jalali_groupby","text":"<pre><code>from jalali_pandas.api import jalali_groupby\n\nresult = jalali_groupby(df, key=\"date\", freq=\"JME\").sum()\n</code></pre>"},{"location":"fa/user-guide/time-series/#jalaliresampler-resample_jalali","title":"JalaliResampler \u0648 resample_jalali","text":"<p><code>JalaliResampler</code> \u0646\u06cc\u0627\u0632 \u0628\u0647 <code>pd.DatetimeIndex</code> \u062f\u0627\u0631\u062f.</p> <pre><code>from jalali_pandas.api import resample_jalali\n\nseries = df.set_index(\"date\")[\"value\"]\nresampled = resample_jalali(series, freq=\"JME\").sum()\n</code></pre>"},{"location":"fa/user-guide/time-series/#resample","title":"resample \u062f\u0631 \u0627\u06a9\u0633\u0633\u0648\u0631 \u062f\u06cc\u062a\u0627\u0641\u0631\u06cc\u0645","text":"<p><code>JalaliDataFrameAccessor.resample()</code> \u0627\u0632 \u06af\u0631\u0648\u0647\u200c\u0628\u0646\u062f\u06cc \u0645\u0627\u0647/\u0641\u0635\u0644/\u0633\u0627\u0644/\u0647\u0641\u062a\u0647 \u067e\u0634\u062a\u06cc\u0628\u0627\u0646\u06cc \u0645\u06cc\u200c\u06a9\u0646\u062f (\u0628\u0631\u0627\u06cc \u062f\u06cc\u062a\u0627\u0641\u0631\u06cc\u0645 \u0628\u0627 \u0633\u062a\u0648\u0646 <code>jdatetime</code>).</p> <pre><code>df[\"jdate\"] = df[\"date\"].jalali.to_jalali()\nmonthly = df.jalali.resample(\"month\")\n</code></pre>"},{"location":"fa/user-guide/timezones/","title":"\u0645\u0646\u0637\u0642\u0647\u200c\u0647\u0627\u06cc \u0632\u0645\u0627\u0646\u06cc","text":"<p>\u0645\u062f\u06cc\u0631\u06cc\u062a \u0645\u0646\u0637\u0642\u0647 \u0632\u0645\u0627\u0646\u06cc \u0628\u0627 \u0627\u0633\u062a\u0641\u0627\u062f\u0647 \u0627\u0632 pandas \u0627\u0646\u062c\u0627\u0645 \u0645\u06cc\u200c\u0634\u0648\u062f.</p>"},{"location":"fa/user-guide/timezones/#jalalitimestamp","title":"JalaliTimestamp","text":"<pre><code>from jalali_pandas import JalaliTimestamp\n\nts = JalaliTimestamp(1402, 6, 15, 12, 0)\n\nlocalized = ts.tz_localize(\"Asia/Tehran\")\nconverted = localized.tz_convert(\"UTC\")\n</code></pre> <p>\u0642\u0648\u0627\u0639\u062f:</p> <ul> <li><code>tz_localize()</code> \u0641\u0642\u0637 \u0628\u0631\u0627\u06cc \u062f\u0627\u062f\u0647\u200c\u0647\u0627\u06cc \u0628\u062f\u0648\u0646 tz.</li> <li><code>tz_convert()</code> \u0641\u0642\u0637 \u0628\u0631\u0627\u06cc \u062f\u0627\u062f\u0647\u200c\u0647\u0627\u06cc \u062f\u0627\u0631\u0627\u06cc tz.</li> </ul>"},{"location":"fa/user-guide/timezones/#series","title":"\u0627\u06a9\u0633\u0633\u0648\u0631 Series","text":"<pre><code>import pandas as pd\n\ns = pd.Series(pd.date_range(\"2023-03-21\", periods=2, freq=\"D\"))\nj = s.jalali.to_jalali()\n\nj_local = j.jalali.tz_localize(\"Asia/Tehran\")\nj_utc = j_local.jalali.tz_convert(\"UTC\")\n</code></pre>"}]}